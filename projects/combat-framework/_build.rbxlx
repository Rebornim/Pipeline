<roblox version="4">
  <Item class="ReplicatedStorage" referent="0">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="Folder" referent="1">
      <Properties>
        <string name="Name">CombatFramework</string>
      </Properties>
      <Item class="ModuleScript" referent="2">
        <Properties>
          <string name="Name">CombatConfig</string>
          <string name="Source"><![CDATA[--!strict

local CombatConfig = {}

CombatConfig.Weapons = {
	blaster_turret = {
		weaponClass = "projectile",
		damageType = "blaster",
		damage = 40,
		fireRate = 3,
		projectileSpeed = 850,
		maxRange = 900,
		lockRange = 600,
		unlockedSpread = 2.4,
		autoAimSpread = 0.9,
		heatMax = 100,
		heatPerShot = 9,
		heatDecayPerSecond = 8,
		heatRecoverThreshold = 50,
	},
	blaster_turret_burst = {
		weaponClass = "burst_projectile",
		damageType = "blaster",
		damage = 32,
		fireRate = 1.8,
		projectileSpeed = 850,
		maxRange = 900,
		lockRange = 600,
		unlockedSpread = 2.9,
		autoAimSpread = 1.1,
		burstCount = 3,
		burstInterval = 0.08,
		heatMax = 100,
		heatPerShot = 4,
		heatDecayPerSecond = 10,
		heatRecoverThreshold = 45,
	},
	turbolaser_turret = {
		weaponClass = "projectile",
		damageType = "turbolaser",
		damage = 120,
		fireRate = 0.5,
		projectileSpeed = 900,
		maxRange = 1800,
		lockRange = 1200,
		unlockedSpread = 1.4,
		autoAimSpread = 0.55,
		heatMax = 100,
		heatPerShot = 25,
		heatDecayPerSecond = 6,
		heatRecoverThreshold = 40,
		boltColor = Color3.fromRGB(0, 255, 0),
	},
	ion_turret = {
		weaponClass = "projectile",
		damageType = "ion",
		damage = 60,
		fireRate = 1.5,
		projectileSpeed = 800,
		maxRange = 900,
		lockRange = 600,
		unlockedSpread = 2.0,
		autoAimSpread = 0.75,
		heatMax = 100,
		heatPerShot = 18,
		heatDecayPerSecond = 7,
		heatRecoverThreshold = 45,
		boltColor = Color3.fromRGB(100, 140, 255),
	},
	torpedo_launcher = {
		weaponClass = "projectile",
		damageType = "proton_torpedo",
		damage = 200,
		fireRate = 0.33,
		projectileSpeed = 300,
		maxRange = 1600,
		lockRange = 1000,
		autoAimSpread = 0.65,
		requiresLock = true,
		ammoCapacity = 6,
		boltColor = Color3.fromRGB(255, 200, 60),
	},
	missile_battery = {
		weaponClass = "projectile",
		damageType = "concussion_missile",
		damage = 80,
		fireRate = 1.0,
		projectileSpeed = 340,
		maxRange = 1400,
		lockRange = 900,
		unlockedSpread = 2.2,
		autoAimSpread = 0.45,
		requiresLock = true,
		homingTurnRate = 45,
		ammoCapacity = 12,
		boltColor = Color3.fromRGB(255, 120, 40),
	},
}

CombatConfig.Entities = {
	blaster_turret = {
		hullHP = 100,
		weaponId = "blaster_turret",
		turretExposed = true,
		respawnTime = 15,
	},
	blaster_turret_burst = {
		hullHP = 100,
		weaponId = "blaster_turret_burst",
		turretExposed = true,
		respawnTime = 15,
	},
	shielded_turret = {
		hullHP = 100,
		shieldHP = 140,
		shieldRegenRate = 8,
		shieldRegenDelay = 5,
		weaponId = "blaster_turret",
		turretExposed = true,
		respawnTime = 15,
	},
	turbolaser_turret = {
		hullHP = 150,
		shieldHP = 100,
		shieldRegenRate = 10,
		shieldRegenDelay = 4,
		weaponId = "turbolaser_turret",
		turretExposed = false,
		respawnTime = 20,
	},
	ion_turret = {
		hullHP = 80,
		weaponId = "ion_turret",
		turretExposed = true,
		respawnTime = 15,
	},
	torpedo_turret = {
		hullHP = 120,
		weaponId = "torpedo_launcher",
		turretExposed = true,
		respawnTime = 25,
	},
	missile_turret = {
		hullHP = 100,
		weaponId = "missile_battery",
		turretExposed = true,
		respawnTime = 20,
	},
	target_dummy = {
		hullHP = 200,
		weaponId = nil,
		respawnTime = 10,
	},
	shielded_target = {
		hullHP = 200,
		shieldHP = 150,
		shieldRegenRate = 25,
		shieldRegenDelay = 3,
		weaponId = nil,
		respawnTime = 10,
	},
	shield_test_target = {
		hullHP = 100,
		shieldHP = 60,
		shieldRegenRate = 0,
		shieldRegenDelay = 999,
		weaponId = nil,
		respawnTime = 10,
	},
	shield_regen_target = {
		hullHP = 200,
		shieldHP = 100,
		shieldRegenRate = 50,
		shieldRegenDelay = 2,
		weaponId = nil,
		respawnTime = 10,
	},
	ion_test_target = {
		hullHP = 200,
		shieldHP = 200,
		shieldRegenRate = 0,
		shieldRegenDelay = 999,
		weaponId = nil,
		respawnTime = 10,
	},
	torpedo_test_target = {
		hullHP = 500,
		shieldHP = 150,
		shieldRegenRate = 0,
		shieldRegenDelay = 999,
		weaponId = nil,
		respawnTime = 10,
	},
	ammo_test_target = {
		hullHP = 10000,
		weaponId = nil,
		respawnTime = 999,
	},
}

CombatConfig.DamageTypeMultipliers = {
	blaster = { shieldMult = 1.0, hullMult = 1.0, bypass = 0 },
	turbolaser = { shieldMult = 1.5, hullMult = 1.5, bypass = 0 },
	ion = { shieldMult = 3.0, hullMult = 0.15, bypass = 0 },
	proton_torpedo = { shieldMult = 0.3, hullMult = 2.5, bypass = 0.7 },
	concussion_missile = { shieldMult = 1.0, hullMult = 1.0, bypass = 0 },
	explosion = { shieldMult = 1.0, hullMult = 1.0, bypass = 0 },
}

CombatConfig.ProjectileRayRadius = 0.5
CombatConfig.DefaultShieldRegenDelay = 3
CombatConfig.LockOnScanRadius = 8
CombatConfig.LockValidationInterval = 0.2
CombatConfig.LockBreakRange = 1.0

CombatConfig.TurretPromptText = "Man Turret"
CombatConfig.TurretPromptDistance = 10

CombatConfig.BoltLength = 2
CombatConfig.BoltWidth = 0.2
CombatConfig.BoltColor = Color3.fromRGB(255, 0, 0)
CombatConfig.BoltMaterial = Enum.Material.Neon

-- Turret destruction explosion tuning.
CombatConfig.TurretDeathExplosionRadius = 30
CombatConfig.TurretDeathExplosionDamage = 220
CombatConfig.TurretDeathExplosionFalloffExponent = 1.6
CombatConfig.TurretDeathExplosionMinDamageScale = 0.12
CombatConfig.TurretDeathExplosionVisualRadius = 30
CombatConfig.TurretDeathExplosionShakeRadius = 85
CombatConfig.TurretDeathExplosionShakeStrength = 1.1
CombatConfig.TurretDeathExplosionShakeDuration = 0.55
CombatConfig.TurretDeathExplosionParticleScale = 1.8
CombatConfig.TurretDeathExplosionParticleEmitMultiplier = 2.2

-- Temporary testing toggle.
CombatConfig.FriendlyFireEnabled = true

return CombatConfig
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="3">
        <Properties>
          <string name="Name">CombatEnums</string>
          <string name="Source"><![CDATA[--!strict

local CombatEnums = {}

CombatEnums.DamageType = {
	Blaster = "blaster",
	Turbolaser = "turbolaser",
	Ion = "ion",
	ProtonTorpedo = "proton_torpedo",
	ConcussionMissile = "concussion_missile",
	Explosion = "explosion",
}

CombatEnums.Faction = {
	Empire = "empire",
	Rebel = "rebel",
	Neutral = "neutral",
}

CombatEnums.EntityState = {
	Active = "active",
	Destroyed = "destroyed",
	Respawning = "respawning",
}

CombatEnums.ImpactType = {
	Shield = "shield",
	Hull = "hull",
	Environment = "environment",
}

return CombatEnums
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="4">
        <Properties>
          <string name="Name">CombatTypes</string>
          <string name="Source"><![CDATA[--!strict

local CombatTypes = {}

export type DamageTypeMultiplier = {
	shieldMult: number,
	hullMult: number,
	bypass: number?,
}

export type WeaponConfig = {
	weaponClass: string?,
	damageType: string,
	damage: number,
	fireRate: number,
	projectileSpeed: number,
	maxRange: number,
	lockRange: number?,
	unlockedSpread: number?,
	autoAimSpread: number?,
	requiresLock: boolean?,
	homingTurnRate: number?,
	boltColor: Color3?,
	splashRadius: number?,
	burstCount: number?,
	burstInterval: number?,
	heatMax: number?,
	heatPerShot: number?,
	heatDecayPerSecond: number?,
	heatRecoverThreshold: number?,
	ammoCapacity: number?,
}

export type EntityConfig = {
	hullHP: number,
	shieldHP: number?,
	shieldRegenRate: number?,
	shieldRegenDelay: number?,
	weaponId: string?,
	turretExposed: boolean?,
	respawnTime: number?,
}

export type LockState = {
	attackerEntityId: string,
	targetEntityId: string,
	lockedAt: number,
}

export type HealthState = {
	entityId: string,
	instance: Model,
	faction: string,
	config: EntityConfig,
	currentHP: number,
	maxHP: number,
	currentShieldHP: number,
	maxShieldHP: number,
	state: string,
	respawnTimer: thread?,
}

export type ProjectileData = {
	projectileId: string,
	sourceEntityId: string,
	sourceInstance: Model,
	sourceCharacter: Model?,
	origin: Vector3,
	direction: Vector3,
	speed: number,
	maxRange: number,
	damage: number,
	damageType: string,
	faction: string,
	boltColor: Color3?,
	splashRadius: number?,
	targetEntityId: string?,
	homingTurnRate: number?,
	currentPosition: Vector3?,
	createdAt: number,
}

export type ValidatedEntity = {
	instance: Model,
	configId: string,
	faction: string,
	weaponMount: BasePart?,
	muzzlePoint: Attachment?,
	turretSeat: Seat?,
}

export type ProjectileFiredPayload = {
	projectileId: string,
	origin: Vector3,
	direction: Vector3,
	speed: number,
	maxRange: number,
	damageType: string?,
	targetEntityId: string?,
	homingTurnRate: number?,
	boltColor: Color3?,
}

export type ProjectileImpactPayload = {
	projectileId: string,
	hitPosition: Vector3,
	hitNormal: Vector3,
	impactType: string?,
	shieldBroken: boolean?,
}

export type DamagePayload = {
	entityId: string,
	newHP: number,
	maxHP: number,
	hitPosition: Vector3,
	newShieldHP: number?,
	maxShieldHP: number?,
}

export type HitConfirmPayload = {
	targetEntityId: string,
	hitPosition: Vector3,
	isKill: boolean,
}

export type EntityDestroyedPayload = {
	entityId: string,
	explosionPosition: Vector3?,
	explosionRadius: number?,
}

export type RespawnedPayload = {
	entityId: string,
	hullHP: number,
	shieldHP: number?,
}

return CombatTypes
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="5">
        <Properties>
          <string name="Name">LeadSolver</string>
          <string name="Source"><![CDATA[--!strict

local LeadSolver = {}

local EPSILON = 1e-6

function LeadSolver.solveInterceptPoint(
	sourcePosition: Vector3,
	targetPosition: Vector3,
	targetVelocity: Vector3,
	projectileSpeed: number
): (Vector3?, number?)
	if projectileSpeed <= EPSILON then
		return nil, nil
	end

	local relative = targetPosition - sourcePosition
	local relativeDistanceSquared = relative:Dot(relative)
	if relativeDistanceSquared <= EPSILON then
		return targetPosition, 0
	end

	local speedSquared = projectileSpeed * projectileSpeed
	local velocitySquared = targetVelocity:Dot(targetVelocity)
	local relativeVelocityDot = relative:Dot(targetVelocity)

	local a = velocitySquared - speedSquared
	local b = 2 * relativeVelocityDot
	local c = relativeDistanceSquared

	local interceptTime: number? = nil
	if math.abs(a) < EPSILON then
		if math.abs(b) > EPSILON then
			local t = -c / b
			if t > 0 then
				interceptTime = t
			end
		end
	else
		local discriminant = b * b - 4 * a * c
		if discriminant >= 0 then
			local sqrtDiscriminant = math.sqrt(discriminant)
			local inv = 1 / (2 * a)
			local t1 = (-b - sqrtDiscriminant) * inv
			local t2 = (-b + sqrtDiscriminant) * inv
			if t1 > 0 and t2 > 0 then
				interceptTime = math.min(t1, t2)
			elseif t1 > 0 then
				interceptTime = t1
			elseif t2 > 0 then
				interceptTime = t2
			end
		end
	end

	if interceptTime == nil then
		interceptTime = math.sqrt(relativeDistanceSquared) / projectileSpeed
	end

	if interceptTime < 0 then
		interceptTime = 0
	end

	return targetPosition + targetVelocity * interceptTime, interceptTime
end

return LeadSolver
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="6">
        <Properties>
          <string name="Name">WeaponRig</string>
          <string name="Source"><![CDATA[--!strict

local WeaponRig = {}

local FORWARD_AXIS = Vector3.new(0, 0, -1)
local DEFAULT_PIVOT_ATTACHMENT_NAME = "AimPivot"
local DEFAULT_AIM_MODE = "yawpitch"
local DEFAULT_MIN_YAW_DEG = -180
local DEFAULT_MAX_YAW_DEG = 180
local DEFAULT_MIN_PITCH_DEG = -89
local DEFAULT_MAX_PITCH_DEG = 89

local AXIS_LOOKUP: { [string]: Vector3 } = {
	["x"] = Vector3.new(1, 0, 0),
	["+x"] = Vector3.new(1, 0, 0),
	["-x"] = Vector3.new(-1, 0, 0),
	["y"] = Vector3.new(0, 1, 0),
	["+y"] = Vector3.new(0, 1, 0),
	["-y"] = Vector3.new(0, -1, 0),
	["z"] = Vector3.new(0, 0, 1),
	["+z"] = Vector3.new(0, 0, 1),
	["-z"] = Vector3.new(0, 0, -1),
}

local AXIS_CANONICAL: { [string]: string } = {
	["x"] = "+X",
	["+x"] = "+X",
	["-x"] = "-X",
	["y"] = "+Y",
	["+y"] = "+Y",
	["-y"] = "-Y",
	["z"] = "+Z",
	["+z"] = "+Z",
	["-z"] = "-Z",
}

local AXIS_CANDIDATES = {
	{ label = "+X", vector = Vector3.new(1, 0, 0) },
	{ label = "-X", vector = Vector3.new(-1, 0, 0) },
	{ label = "+Y", vector = Vector3.new(0, 1, 0) },
	{ label = "-Y", vector = Vector3.new(0, -1, 0) },
	{ label = "+Z", vector = Vector3.new(0, 0, 1) },
	{ label = "-Z", vector = Vector3.new(0, 0, -1) },
}

local inferredAimAxisCache = setmetatable({}, { __mode = "k" }) :: { [BasePart]: { vector: Vector3?, label: string? } }

local function trim(raw: string): string
	return string.gsub(raw, "^%s*(.-)%s*$", "%1")
end

local function findAttachmentByName(root: Instance, attachmentName: string): Attachment?
	local matches: { Attachment } = {}
	for _, descendant in ipairs(root:GetDescendants()) do
		if descendant:IsA("Attachment") and descendant.Name == attachmentName then
			table.insert(matches, descendant)
		end
	end

	table.sort(matches, function(a: Attachment, b: Attachment)
		return a:GetFullName() < b:GetFullName()
	end)

	return matches[1]
end

local function parseVector3String(raw: string): Vector3?
	local xRaw, yRaw, zRaw = string.match(raw, "^%s*([%+%-]?[%d%.]+)%s*,%s*([%+%-]?[%d%.]+)%s*,%s*([%+%-]?[%d%.]+)%s*$")
	if xRaw == nil or yRaw == nil or zRaw == nil then
		return nil
	end

	local x = tonumber(xRaw)
	local y = tonumber(yRaw)
	local z = tonumber(zRaw)
	if x == nil or y == nil or z == nil then
		return nil
	end

	return Vector3.new(x, y, z)
end

local function getMountOrModelAttribute(mount: BasePart, attributeName: string): any
	local fromMount = mount:GetAttribute(attributeName)
	if fromMount ~= nil then
		return fromMount
	end

	local model = mount:FindFirstAncestorOfClass("Model")
	if model ~= nil then
		local fromModel = model:GetAttribute(attributeName)
		if fromModel ~= nil then
			return fromModel
		end

		local rigFolder = model:FindFirstChild("TurretRig")
		if rigFolder ~= nil then
			local fromRigFolder = rigFolder:GetAttribute(attributeName)
			if fromRigFolder ~= nil then
				return fromRigFolder
			end
		end
	end

	return nil
end

local function getMountOrModelNumber(mount: BasePart, attributeName: string): number?
	local raw = getMountOrModelAttribute(mount, attributeName)
	if type(raw) == "number" then
		return raw
	end
	if type(raw) == "string" then
		return tonumber(raw)
	end
	return nil
end

local function rotationFromTo(fromDirection: Vector3, toDirection: Vector3): CFrame
	if fromDirection.Magnitude < 1e-4 or toDirection.Magnitude < 1e-4 then
		return CFrame.new()
	end

	local fromUnit = fromDirection.Unit
	local toUnit = toDirection.Unit
	local dot = math.clamp(fromUnit:Dot(toUnit), -1, 1)

	if dot > 0.9999 then
		return CFrame.new()
	end

	if dot < -0.9999 then
		-- Opposite vectors have infinite valid 180-degree axes.
		-- Prefer a stable world axis to avoid unexpected roll/up inversion.
		local preferredAxes = {
			Vector3.new(0, 1, 0),
			Vector3.new(1, 0, 0),
			Vector3.new(0, 0, 1),
		}
		for _, axis in ipairs(preferredAxes) do
			if math.abs(fromUnit:Dot(axis)) < 0.999 then
				return CFrame.fromAxisAngle(axis, math.pi)
			end
		end
		return CFrame.new()
	end

	local axis = fromUnit:Cross(toUnit)
	if axis.Magnitude < 1e-4 then
		return CFrame.new()
	end

	return CFrame.fromAxisAngle(axis.Unit, math.acos(dot))
end

local function isMuzzleAttachment(candidate: Instance): boolean
	if not candidate:IsA("Attachment") then
		return false
	end

	if candidate.Name == "MuzzlePoint" or string.sub(candidate.Name, 1, 11) == "MuzzlePoint" then
		return true
	end

	return false
end

local function findPrimaryMuzzleAttachment(mount: BasePart): Attachment?
	local attachments: { Attachment } = {}
	for _, descendant in ipairs(mount:GetDescendants()) do
		if isMuzzleAttachment(descendant) then
			table.insert(attachments, descendant :: Attachment)
		end
	end

	table.sort(attachments, function(a: Attachment, b: Attachment)
		return a:GetFullName() < b:GetFullName()
	end)

	return attachments[1]
end

local function inferAimAxisFromMuzzle(mount: BasePart): (Vector3?, string?)
	local cached = inferredAimAxisCache[mount]
	if cached ~= nil then
		return cached.vector, cached.label
	end

	local muzzle = findPrimaryMuzzleAttachment(mount)
	if muzzle == nil then
		inferredAimAxisCache[mount] = { vector = nil, label = nil }
		return nil, nil
	end

	-- Attachment authoring direction is its Axis (X), not CFrame.LookVector (-Z).
	local muzzleForward = muzzle.WorldAxis
	if muzzleForward.Magnitude < 1e-4 then
		muzzleForward = muzzle.WorldCFrame.LookVector
	end
	local localLook = mount.CFrame:VectorToObjectSpace(muzzleForward)
	if localLook.Magnitude < 1e-4 then
		inferredAimAxisCache[mount] = { vector = nil, label = nil }
		return nil, nil
	end

	local unitLook = localLook.Unit
	local bestVector: Vector3? = nil
	local bestLabel: string? = nil
	local bestDot = -math.huge
	for _, candidate in ipairs(AXIS_CANDIDATES) do
		local dot = unitLook:Dot(candidate.vector)
		if dot > bestDot then
			bestDot = dot
			bestVector = candidate.vector
			bestLabel = candidate.label
		end
	end

	inferredAimAxisCache[mount] = {
		vector = bestVector,
		label = bestLabel,
	}
	return bestVector, bestLabel
end

local function resolveAimAxisInternal(mount: BasePart): (Vector3?, string?)
	local rawAxis = getMountOrModelAttribute(mount, "AimAxis")
	if type(rawAxis) == "string" then
		local normalized = string.lower(trim(rawAxis))
		local vector = AXIS_LOOKUP[normalized]
		if vector ~= nil then
			return vector, AXIS_CANONICAL[normalized] or string.upper(normalized)
		end
	end

	local inferredVector, inferredLabel = inferAimAxisFromMuzzle(mount)
	if inferredVector ~= nil then
		return inferredVector, inferredLabel
	end

	return nil, nil
end

local function getAimAxis(mount: BasePart): Vector3?
	local axis, _axisLabel = resolveAimAxisInternal(mount)
	return axis
end

local function getAngleOffset(mount: BasePart): CFrame
	local rawOffset = getMountOrModelAttribute(mount, "AimOffsetDegrees")
	local angleDegrees: Vector3? = nil

	if typeof(rawOffset) == "Vector3" then
		angleDegrees = rawOffset :: Vector3
	elseif type(rawOffset) == "string" then
		angleDegrees = parseVector3String(rawOffset)
	end

	if angleDegrees == nil then
		return CFrame.new()
	end

	return CFrame.fromOrientation(math.rad(angleDegrees.X), math.rad(angleDegrees.Y), math.rad(angleDegrees.Z))
end

local function getMountAimOffset(mount: BasePart): CFrame
	local axis = getAimAxis(mount)
	local axisOffset = if axis ~= nil then rotationFromTo(axis, FORWARD_AXIS) else CFrame.new()
	return axisOffset * getAngleOffset(mount)
end

local function getLogicalAimFrameFromMount(mount: BasePart): CFrame
	return mount.CFrame * getMountAimOffset(mount):Inverse()
end

local function directionToYawPitch(direction: Vector3): (number, number)
	local unitDirection = direction.Unit
	local yaw = math.atan2(-unitDirection.X, -unitDirection.Z)
	local pitch = math.asin(math.clamp(unitDirection.Y, -1, 1))
	return yaw, pitch
end

local function yawPitchToDirection(yaw: number, pitch: number): Vector3
	local cosPitch = math.cos(pitch)
	return Vector3.new(-math.sin(yaw) * cosPitch, math.sin(pitch), -math.cos(yaw) * cosPitch).Unit
end

local function getAimMode(mount: BasePart): string
	local raw = getMountOrModelAttribute(mount, "AimMode")
	if type(raw) ~= "string" then
		return DEFAULT_AIM_MODE
	end
	local normalized = string.lower(trim(raw))
	normalized = string.gsub(normalized, "[%s_%-]", "")
	return normalized
end

local function getAimLimitsRadians(
	mount: BasePart,
	minYawDegOverride: number?,
	maxYawDegOverride: number?,
	minPitchDegOverride: number?,
	maxPitchDegOverride: number?
): (number, number, number, number)
	local minYawDeg = minYawDegOverride
	if minYawDeg == nil then
		minYawDeg = getMountOrModelNumber(mount, "MinYawDeg")
	end
	if minYawDeg == nil then
		minYawDeg = DEFAULT_MIN_YAW_DEG
	end

	local maxYawDeg = maxYawDegOverride
	if maxYawDeg == nil then
		maxYawDeg = getMountOrModelNumber(mount, "MaxYawDeg")
	end
	if maxYawDeg == nil then
		maxYawDeg = DEFAULT_MAX_YAW_DEG
	end

	local minPitchDeg = minPitchDegOverride
	if minPitchDeg == nil then
		minPitchDeg = getMountOrModelNumber(mount, "MinPitchDeg")
	end
	if minPitchDeg == nil then
		minPitchDeg = DEFAULT_MIN_PITCH_DEG
	end

	local maxPitchDeg = maxPitchDegOverride
	if maxPitchDeg == nil then
		maxPitchDeg = getMountOrModelNumber(mount, "MaxPitchDeg")
	end
	if maxPitchDeg == nil then
		maxPitchDeg = DEFAULT_MAX_PITCH_DEG
	end

	if minYawDeg > maxYawDeg then
		minYawDeg, maxYawDeg = maxYawDeg, minYawDeg
	end
	if minPitchDeg > maxPitchDeg then
		minPitchDeg, maxPitchDeg = maxPitchDeg, minPitchDeg
	end

	return math.rad(minYawDeg), math.rad(maxYawDeg), math.rad(minPitchDeg), math.rad(maxPitchDeg)
end

type ClampOverrides = {
	mode: string?,
	minYawDeg: number?,
	maxYawDeg: number?,
	minPitchDeg: number?,
	maxPitchDeg: number?,
	pivotName: string?,
	pivotAttachment: Attachment?,
}

local function getPivotAttachment(mount: BasePart): Attachment?
	local nameOverride = getMountOrModelAttribute(mount, "AimPivotName")
	local pivotName = if type(nameOverride) == "string" and trim(nameOverride) ~= ""
		then trim(nameOverride)
		else DEFAULT_PIVOT_ATTACHMENT_NAME

	local attachment = findAttachmentByName(mount, pivotName)
	if attachment ~= nil then
		return attachment
	end

	local model = mount:FindFirstAncestorOfClass("Model")
	if model ~= nil then
		return findAttachmentByName(model, pivotName)
	end

	return nil
end

local function getPivotAttachmentWithOverrides(mount: BasePart, overrides: ClampOverrides?): Attachment?
	if overrides ~= nil then
		if overrides.pivotAttachment ~= nil and overrides.pivotAttachment.Parent ~= nil then
			return overrides.pivotAttachment
		end

		if overrides.pivotName ~= nil then
			local overridePivotName = trim(overrides.pivotName)
			if overridePivotName ~= "" then
				local attachment = findAttachmentByName(mount, overridePivotName)
				if attachment ~= nil then
					return attachment
				end

				local model = mount:FindFirstAncestorOfClass("Model")
				if model ~= nil then
					local modelAttachment = findAttachmentByName(model, overridePivotName)
					if modelAttachment ~= nil then
						return modelAttachment
					end
				end
			end
		end
	end

	return getPivotAttachment(mount)
end

local function getPivotWorldPosition(mount: BasePart, overrides: ClampOverrides?): Vector3
	local pivotAttachment = getPivotAttachmentWithOverrides(mount, overrides)
	if pivotAttachment ~= nil then
		return pivotAttachment.WorldPosition
	end
	return mount.Position
end

local function getPivotLocalOffset(mount: BasePart, overrides: ClampOverrides?): Vector3
	local pivotWorld = getPivotWorldPosition(mount, overrides)
	return mount.CFrame:PointToObjectSpace(pivotWorld)
end

function WeaponRig.getMountAimOffset(mount: BasePart): CFrame
	return getMountAimOffset(mount)
end

function WeaponRig.getAimPivotWorldPosition(mount: BasePart, overrides: ClampOverrides?): Vector3
	return getPivotWorldPosition(mount, overrides)
end

function WeaponRig.resolveAimAxis(mount: BasePart): (Vector3?, string?)
	return resolveAimAxisInternal(mount)
end

function WeaponRig.getCurrentAimDirection(mount: BasePart): Vector3
	return getLogicalAimFrameFromMount(mount).LookVector
end

function WeaponRig.getNeutralAimFrame(mount: BasePart): CFrame
	return getLogicalAimFrameFromMount(mount)
end

function WeaponRig.clampDirectionToMountLimits(
	mount: BasePart,
	neutralAimFrame: CFrame,
	direction: Vector3,
	overrides: ClampOverrides?
): Vector3
	if direction.Magnitude < 1e-4 then
		return direction
	end

	local localDirection = neutralAimFrame:VectorToObjectSpace(direction.Unit)
	local yaw, pitch = directionToYawPitch(localDirection)
	local mode = getAimMode(mount)
	local minYawDegOverride: number? = nil
	local maxYawDegOverride: number? = nil
	local minPitchDegOverride: number? = nil
	local maxPitchDegOverride: number? = nil
	if overrides ~= nil then
		if overrides.mode ~= nil then
			mode = string.lower(trim(overrides.mode))
		end
		mode = string.gsub(mode, "[%s_%-]", "")
		minYawDegOverride = overrides.minYawDeg
		maxYawDegOverride = overrides.maxYawDeg
		minPitchDegOverride = overrides.minPitchDeg
		maxPitchDegOverride = overrides.maxPitchDeg
	end
	local minYaw, maxYaw, minPitch, maxPitch =
		getAimLimitsRadians(mount, minYawDegOverride, maxYawDegOverride, minPitchDegOverride, maxPitchDegOverride)

	if mode == "yawonly" then
		pitch = 0
	elseif mode == "pitchonly" then
		-- Pitch-only parts should still inherit turret yaw.
		-- Keep yaw unconstrained and only apply pitch constraints.
		minYaw = -math.pi
		maxYaw = math.pi
	end

	yaw = math.clamp(yaw, minYaw, maxYaw)
	pitch = math.clamp(pitch, minPitch, maxPitch)

	local clampedLocalDirection = yawPitchToDirection(yaw, pitch)
	return neutralAimFrame:VectorToWorldSpace(clampedLocalDirection).Unit
end

function WeaponRig.getAimFrame(mount: BasePart, direction: Vector3, overrides: ClampOverrides?): CFrame
	if direction.Magnitude < 1e-4 then
		return mount.CFrame
	end

	local logicalAimFrame = CFrame.lookAt(Vector3.zero, direction.Unit)
	local mountAimFrame = logicalAimFrame * getMountAimOffset(mount)
	local orientationOnly = CFrame.fromMatrix(Vector3.zero, mountAimFrame.XVector, mountAimFrame.YVector, mountAimFrame.ZVector)

	local pivotWorld = getPivotWorldPosition(mount, overrides)
	local pivotLocal = getPivotLocalOffset(mount, overrides)
	return CFrame.new(pivotWorld) * orientationOnly * CFrame.new(-pivotLocal)
end

return WeaponRig
]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="7">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Folder" referent="8">
      <Properties>
        <string name="Name">CombatFramework</string>
      </Properties>
      <Item class="Folder" referent="9">
        <Properties>
          <string name="Name">Authoring</string>
        </Properties>
        <Item class="ModuleScript" referent="10">
          <Properties>
            <string name="Name">StartupValidator</string>
            <string name="Source"><![CDATA[--!strict

local CollectionService = game:GetService("CollectionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local sharedRoot = ReplicatedStorage:WaitForChild("CombatFramework")
local CombatConfig = require(sharedRoot:WaitForChild("CombatConfig"))
local CombatEnums = require(sharedRoot:WaitForChild("CombatEnums"))
local CombatTypes = require(sharedRoot:WaitForChild("CombatTypes"))
local WeaponRig = require(sharedRoot:WaitForChild("WeaponRig"))

type ValidatedEntity = CombatTypes.ValidatedEntity

local StartupValidator = {}

local validFactionSet = {
	[CombatEnums.Faction.Empire] = true,
	[CombatEnums.Faction.Rebel] = true,
	[CombatEnums.Faction.Neutral] = true,
}

local function normalizeFaction(rawFaction: string): string
	return string.lower(string.gsub(rawFaction, "^%s*(.-)%s*$", "%1"))
end

local function fail(modelName: string, message: string)
	warn(string.format("[VALIDATE_FAIL] %s: %s", modelName, message))
end

local function findTaggedDescendant(model: Model, tagName: string, className: string?): Instance?
	for _, descendant in ipairs(model:GetDescendants()) do
		if CollectionService:HasTag(descendant, tagName) then
			if className == nil or descendant:IsA(className) then
				return descendant
			end
		end
	end
	return nil
end

local function collectTaggedDescendants(model: Model, tagName: string, className: string?): { Instance }
	local tagged: { Instance } = {}
	for _, descendant in ipairs(model:GetDescendants()) do
		if CollectionService:HasTag(descendant, tagName) then
			if className == nil or descendant:IsA(className) then
				table.insert(tagged, descendant)
			end
		end
	end

	table.sort(tagged, function(a: Instance, b: Instance)
		return a:GetFullName() < b:GetFullName()
	end)

	return tagged
end

local function isMuzzleAttachment(candidate: Instance): boolean
	if not candidate:IsA("Attachment") then
		return false
	end

	if CollectionService:HasTag(candidate, "MuzzlePoint") then
		return true
	end

	return candidate.Name == "MuzzlePoint" or string.sub(candidate.Name, 1, 11) == "MuzzlePoint"
end

local function hasCameraPoint(model: Model): boolean
	for _, descendant in ipairs(model:GetDescendants()) do
		if descendant.Name == "CameraPoint" and (descendant:IsA("BasePart") or descendant:IsA("Attachment")) then
			return true
		end
	end
	return false
end

local function validateConfigContracts(): boolean
	local hasFailure = false

	for weaponId, weaponConfig in pairs(CombatConfig.Weapons) do
		if type(weaponConfig.lockRange) == "number" then
			if type(weaponConfig.maxRange) ~= "number" or weaponConfig.lockRange >= weaponConfig.maxRange then
				warn(
					string.format(
						"[VALIDATE] Weapon '%s' lockRange (%d) must be less than maxRange (%d)",
						weaponId,
						math.floor(weaponConfig.lockRange + 0.5),
						math.floor((weaponConfig.maxRange or 0) + 0.5)
					)
				)
				hasFailure = true
			end
		end

		if type(weaponConfig.unlockedSpread) == "number" and weaponConfig.unlockedSpread < 0 then
			warn(string.format("[VALIDATE] Weapon '%s' unlockedSpread must be >= 0", weaponId))
			hasFailure = true
		end

		if type(weaponConfig.autoAimSpread) == "number" and weaponConfig.autoAimSpread < 0 then
			warn(string.format("[VALIDATE] Weapon '%s' autoAimSpread must be >= 0", weaponId))
			hasFailure = true
		end
	end

	for entityId, entityConfig in pairs(CombatConfig.Entities) do
		if entityConfig.turretExposed ~= nil and type(entityConfig.turretExposed) ~= "boolean" then
			warn(string.format("[VALIDATE] Entity '%s' turretExposed must be boolean", entityId))
			hasFailure = true
		end
	end

	return not hasFailure
end

function StartupValidator.validate(): { ValidatedEntity }
	local validated: { ValidatedEntity } = {}
	if not validateConfigContracts() then
		return validated
	end

	local entities = CollectionService:GetTagged("CombatEntity")

	for _, instance in ipairs(entities) do
		if not instance:IsA("Model") then
			fail(instance:GetFullName(), "CombatEntity tag must be on a Model")
			continue
		end

		local model = instance
		local modelName = model.Name
		local faction = model:GetAttribute("Faction")
		local configId = model:GetAttribute("ConfigId")

		if type(faction) ~= "string" then
			fail(modelName, "missing Faction attribute")
			continue
		end

		local normalizedFaction = normalizeFaction(faction)
		if not validFactionSet[normalizedFaction] then
			fail(modelName, string.format("invalid Faction '%s'", tostring(faction)))
			continue
		end

		if type(configId) ~= "string" then
			fail(modelName, "missing ConfigId attribute")
			continue
		end

		local entityConfig = CombatConfig.Entities[configId]
		if entityConfig == nil then
			fail(modelName, string.format("unknown ConfigId '%s'", configId))
			continue
		end

		local weaponMount: BasePart? = nil
		local muzzlePoint: Attachment? = nil
		local turretSeat: Seat? = nil
		local mountCount = 0

		if entityConfig.weaponId ~= nil then
			if CombatConfig.Weapons[entityConfig.weaponId] == nil then
				fail(modelName, string.format("weaponId '%s' not found in CombatConfig.Weapons", entityConfig.weaponId))
				continue
			end

			local mountCandidates = collectTaggedDescendants(model, "WeaponMount", "BasePart")
			mountCount = #mountCandidates
			if mountCount == 0 then
				fail(modelName, "has weaponId but no WeaponMount tagged child")
				continue
			end

			weaponMount = mountCandidates[1] :: BasePart
			local resolvedAimAxis, _aimAxisLabel = WeaponRig.resolveAimAxis(weaponMount)
			if resolvedAimAxis == nil then
				fail(
					modelName,
					string.format(
						"mount '%s' has no resolved facing; set AimAxis (+X/-X/+Y/-Y/+Z/-Z) or orient MuzzlePoint.Axis forward",
						weaponMount:GetFullName()
					)
				)
				continue
			end

			for _, mount in ipairs(mountCandidates) do
				for _, descendant in ipairs((mount :: Instance):GetDescendants()) do
					if isMuzzleAttachment(descendant) then
						if muzzlePoint == nil then
							muzzlePoint = descendant :: Attachment
						end
					end
				end
			end

			local seatCandidate = findTaggedDescendant(model, "TurretSeat", "Seat")
			if seatCandidate == nil then
				fail(modelName, "has weaponId but no TurretSeat tagged child")
				continue
			end

			turretSeat = seatCandidate :: Seat

			if not hasCameraPoint(model) then
				fail(modelName, "has weaponId but no CameraPoint part/attachment")
				continue
			end
		end

		table.insert(validated, {
			instance = model,
			configId = configId,
			faction = normalizedFaction,
			weaponMount = weaponMount,
			muzzlePoint = muzzlePoint,
			turretSeat = turretSeat,
		})
	end

	return validated
end

return StartupValidator
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="Script" referent="11">
        <Properties>
          <string name="Name">CombatInit</string>
          <token name="RunContext">0</token>
          <string name="Source"><![CDATA[--!strict

local CollectionService = game:GetService("CollectionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

local sharedRoot = ReplicatedStorage:WaitForChild("CombatFramework")
local CombatConfig = require(sharedRoot:WaitForChild("CombatConfig"))
local CombatTypes = require(sharedRoot:WaitForChild("CombatTypes"))

local serverRoot = ServerScriptService:WaitForChild("CombatFramework")
local StartupValidator = require(serverRoot:WaitForChild("Authoring"):WaitForChild("StartupValidator"))
local HealthManager = require(serverRoot:WaitForChild("Health"):WaitForChild("HealthManager"))
local ProjectileServer = require(serverRoot:WaitForChild("Projectiles"):WaitForChild("ProjectileServer"))
local TargetingServer = require(serverRoot:WaitForChild("Targeting"):WaitForChild("TargetingServer"))
local WeaponServer = require(serverRoot:WaitForChild("Weapons"):WaitForChild("WeaponServer"))

type ValidatedEntity = CombatTypes.ValidatedEntity

local function normalizeTeamOrFaction(raw: string?): string?
	if raw == nil then
		return nil
	end

	local trimmed = string.match(raw, "^%s*(.-)%s*$")
	if trimmed == nil or trimmed == "" then
		return nil
	end

	return string.lower(trimmed)
end

local function createRemoteEvent(parent: Folder, name: string): RemoteEvent
	local existing = parent:FindFirstChild(name)
	if existing ~= nil then
		if existing:IsA("RemoteEvent") then
			return existing
		end
		existing:Destroy()
	end

	local remote = Instance.new("RemoteEvent")
	remote.Name = name
	remote.Parent = parent
	return remote
end

local function createRemotesFolder(): Folder
	local existing = ReplicatedStorage:FindFirstChild("CombatRemotes")
	if existing ~= nil and not existing:IsA("Folder") then
		existing:Destroy()
		existing = nil
	end

	local folder = existing :: Folder?
	if folder == nil then
		folder = Instance.new("Folder")
		folder.Name = "CombatRemotes"
		folder.Parent = ReplicatedStorage
	end

	createRemoteEvent(folder, "FireWeapon")
	createRemoteEvent(folder, "UpdateTurretAim")
	createRemoteEvent(folder, "ProjectileFired")
	createRemoteEvent(folder, "ProjectileImpact")
	createRemoteEvent(folder, "DamageApplied")
	createRemoteEvent(folder, "HitConfirm")
	createRemoteEvent(folder, "EntityDestroyed")
	createRemoteEvent(folder, "EntityRespawned")
	createRemoteEvent(folder, "RequestLockOn")
	createRemoteEvent(folder, "ClearLockOn")
	createRemoteEvent(folder, "LockOnState")

	return folder
end

local function addTurretPrompt(turretSeat: Seat, entityId: string)
	local prompt = turretSeat:FindFirstChildOfClass("ProximityPrompt")
	if prompt == nil then
		prompt = Instance.new("ProximityPrompt")
		prompt.Name = "ManTurretPrompt"
		prompt.Parent = turretSeat
	end

	prompt.ActionText = CombatConfig.TurretPromptText
	prompt.ObjectText = "Turret"
	prompt.HoldDuration = 0
	prompt.MaxActivationDistance = CombatConfig.TurretPromptDistance
	prompt.RequiresLineOfSight = false
	prompt.KeyboardKeyCode = Enum.KeyCode.E

	prompt.Triggered:Connect(function(player: Player)
		if not HealthManager.isAlive(entityId) then
			return
		end

		local turretFaction = normalizeTeamOrFaction(HealthManager.getFaction(entityId))
		if turretFaction == nil then
			return
		end

		local team = player.Team
		if team == nil then
			print(string.format("[P1_TURRET_DENY] player=%s entity=%s reason=no_team", player.Name, entityId))
			return
		end

		local playerFaction = normalizeTeamOrFaction(team.Name)
		if playerFaction == nil or playerFaction ~= turretFaction then
			print(
				string.format(
					"[P1_TURRET_DENY] player=%s entity=%s team=%s faction=%s reason=faction_mismatch",
					player.Name,
					entityId,
					tostring(team.Name),
					tostring(turretFaction)
				)
			)
			return
		end

		local character = player.Character
		if character == nil then
			return
		end

		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid == nil then
			return
		end

		turretSeat:Sit(humanoid)
	end)
end

local remotesFolder = createRemotesFolder()

HealthManager.init(remotesFolder)
ProjectileServer.init(remotesFolder)
TargetingServer.init(remotesFolder)
WeaponServer.init(remotesFolder)
HealthManager.setRespawnCallback(function(entityId: string)
	TargetingServer.clearLock(entityId)
	WeaponServer.resetEntity(entityId)
end)

local validatedEntities: { ValidatedEntity } = StartupValidator.validate()
local nextEntityIndex = 0

for _, validatedEntity in ipairs(validatedEntities) do
	nextEntityIndex += 1
	local entityId = "entity_" .. tostring(nextEntityIndex)

	validatedEntity.instance:SetAttribute("EntityId", entityId)
	local entityConfig = CombatConfig.Entities[validatedEntity.configId]
	local turretExposed = false
	if entityConfig ~= nil and entityConfig.turretExposed == true then
		turretExposed = true
	end
	validatedEntity.instance:SetAttribute("TurretExposed", turretExposed)
	HealthManager.registerEntity(entityId, validatedEntity)
	WeaponServer.registerEntity(entityId)

	if validatedEntity.turretSeat ~= nil then
		CollectionService:AddTag(validatedEntity.turretSeat, "TurretSeat")
		addTurretPrompt(validatedEntity.turretSeat, entityId)
	end
end
]]></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="12">
        <Properties>
          <string name="Name">Health</string>
        </Properties>
        <Item class="ModuleScript" referent="13">
          <Properties>
            <string name="Name">HealthManager</string>
            <string name="Source"><![CDATA[--!strict

local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local sharedRoot = ReplicatedStorage:WaitForChild("CombatFramework")
local CombatConfig = require(sharedRoot:WaitForChild("CombatConfig"))
local CombatEnums = require(sharedRoot:WaitForChild("CombatEnums"))
local CombatTypes = require(sharedRoot:WaitForChild("CombatTypes"))

type EntityConfig = CombatTypes.EntityConfig
type HealthState = CombatTypes.HealthState
type ValidatedEntity = CombatTypes.ValidatedEntity
type EntityDestroyedPayload = CombatTypes.EntityDestroyedPayload
type DamageTypeMultiplier = CombatTypes.DamageTypeMultiplier

type PartState = {
	part: BasePart,
	transparency: number,
	canCollide: boolean,
	canTouch: boolean,
}

type PromptState = {
	prompt: ProximityPrompt,
	enabled: boolean,
}

type HealthStateInternal = HealthState & {
	partStates: { PartState }?,
	promptStates: { PromptState }?,
	lastShieldDamageTime: number,
}

local HealthManager = {}

local entitiesById: { [string]: HealthStateInternal } = {}
local modelToEntityId: { [Model]: string } = {}

local remotesFolder: Folder? = nil
local damageAppliedRemote: RemoteEvent? = nil
local entityDestroyedRemote: RemoteEvent? = nil
local entityRespawnedRemote: RemoteEvent? = nil
local explosionOverlapParams = OverlapParams.new()
local heartbeatConnection: RBXScriptConnection? = nil
local respawnCallback: ((string) -> ())? = nil

local function readConfigNumber(name: string, defaultValue: number): number
	local raw = CombatConfig[name]
	if type(raw) == "number" then
		return raw
	end
	return defaultValue
end

local function distancePointToPartBounds(point: Vector3, part: BasePart): number
	local localPoint = part.CFrame:PointToObjectSpace(point)
	local halfSize = part.Size * 0.5
	local dx = math.max(math.abs(localPoint.X) - halfSize.X, 0)
	local dy = math.max(math.abs(localPoint.Y) - halfSize.Y, 0)
	local dz = math.max(math.abs(localPoint.Z) - halfSize.Z, 0)
	return math.sqrt(dx * dx + dy * dy + dz * dz)
end

local function computeExplosionFalloffScale(distance: number, radius: number): number
	local safeRadius = math.max(radius, 1e-4)
	local normalized = math.clamp(distance / safeRadius, 0, 1)
	local exponent = math.max(0.1, readConfigNumber("TurretDeathExplosionFalloffExponent", 1.6))
	local minScale = math.clamp(readConfigNumber("TurretDeathExplosionMinDamageScale", 0.12), 0, 1)
	local curved = math.clamp(1 - math.pow(normalized, exponent), 0, 1)
	return math.max(minScale, curved)
end

local function getRemotes(): (RemoteEvent, RemoteEvent, RemoteEvent)
	local damageRemote = damageAppliedRemote
	local destroyedRemote = entityDestroyedRemote
	local respawnedRemote = entityRespawnedRemote
	if damageRemote == nil or destroyedRemote == nil or respawnedRemote == nil then
		error("HealthManager not initialized with remotes")
	end
	return damageRemote, destroyedRemote, respawnedRemote
end

local function setModelHealthAttributes(
	model: Model,
	currentHP: number,
	maxHP: number,
	currentShieldHP: number,
	maxShieldHP: number
)
	model:SetAttribute("HullHP", currentHP)
	model:SetAttribute("MaxHullHP", maxHP)
	model:SetAttribute("ShieldHP", currentShieldHP)
	model:SetAttribute("MaxShieldHP", maxShieldHP)
end

local function getShieldRegenRate(config: EntityConfig): number
	if type(config.shieldRegenRate) == "number" and config.shieldRegenRate > 0 then
		return config.shieldRegenRate
	end
	return 0
end

local function getShieldRegenDelay(config: EntityConfig): number
	if type(config.shieldRegenDelay) == "number" and config.shieldRegenDelay >= 0 then
		return config.shieldRegenDelay
	end
	return math.max(0, readConfigNumber("DefaultShieldRegenDelay", 3))
end

local function getDamageTypeMultiplier(damageType: string): DamageTypeMultiplier
	local defaults: DamageTypeMultiplier = {
		shieldMult = 1,
		hullMult = 1,
		bypass = 0,
	}

	local allMultipliers = CombatConfig.DamageTypeMultipliers
	if type(allMultipliers) ~= "table" then
		return defaults
	end

	local raw = allMultipliers[damageType]
	if type(raw) ~= "table" then
		return defaults
	end

	local shieldMult = if type(raw.shieldMult) == "number" then math.max(0, raw.shieldMult) else defaults.shieldMult
	local hullMult = if type(raw.hullMult) == "number" then math.max(0, raw.hullMult) else defaults.hullMult
	local bypass = if type(raw.bypass) == "number" then math.clamp(raw.bypass, 0, 1) else defaults.bypass

	return {
		shieldMult = shieldMult,
		hullMult = hullMult,
		bypass = bypass,
	}
end

local function stepShieldRegen(dt: number)
	if dt <= 0 then
		return
	end

	local now = tick()
	for _, state in pairs(entitiesById) do
		if state.state ~= CombatEnums.EntityState.Active then
			continue
		end
		if state.maxShieldHP <= 0 or state.currentShieldHP >= state.maxShieldHP then
			continue
		end

		local regenRate = getShieldRegenRate(state.config)
		if regenRate <= 0 then
			continue
		end

		local regenDelay = getShieldRegenDelay(state.config)
		if now - state.lastShieldDamageTime < regenDelay then
			continue
		end

		local previousShieldHP = state.currentShieldHP
		local nextShieldHP = math.min(state.maxShieldHP, previousShieldHP + regenRate * dt)
		if nextShieldHP == previousShieldHP then
			continue
		end

		state.currentShieldHP = nextShieldHP
		setModelHealthAttributes(state.instance, state.currentHP, state.maxHP, state.currentShieldHP, state.maxShieldHP)

	end
end

local function collectAndHideParts(model: Model): { PartState }
	local partStates: { PartState } = {}

	for _, descendant in ipairs(model:GetDescendants()) do
		if descendant:IsA("BasePart") then
			table.insert(partStates, {
				part = descendant,
				transparency = descendant.Transparency,
				canCollide = descendant.CanCollide,
				canTouch = descendant.CanTouch,
			})
			descendant.Transparency = 1
			descendant.CanCollide = false
			descendant.CanTouch = false
		end
	end

	return partStates
end

local function collectAndDisablePrompts(model: Model): { PromptState }
	local promptStates: { PromptState } = {}

	for _, descendant in ipairs(model:GetDescendants()) do
		if descendant:IsA("ProximityPrompt") then
			table.insert(promptStates, {
				prompt = descendant,
				enabled = descendant.Enabled,
			})
			descendant.Enabled = false
		end
	end

	return promptStates
end

local function restoreParts(state: HealthStateInternal)
	if state.partStates == nil then
		return
	end

	for _, saved in ipairs(state.partStates) do
		if saved.part.Parent ~= nil then
			local restoredTransparency = saved.transparency
			if saved.part:IsA("Seat") and CollectionService:HasTag(saved.part, "TurretSeat") then
				restoredTransparency = 1
			end
			saved.part.Transparency = restoredTransparency
			saved.part.CanCollide = saved.canCollide
			saved.part.CanTouch = saved.canTouch
		end
	end

	state.partStates = nil
end

local function restorePrompts(state: HealthStateInternal)
	if state.promptStates == nil then
		return
	end

	for _, saved in ipairs(state.promptStates) do
		if saved.prompt.Parent ~= nil then
			saved.prompt.Enabled = saved.enabled
		end
	end

	state.promptStates = nil
end

local function findEntityIdFromInstance(instance: Instance): string?
	local current: Instance? = instance
	while current ~= nil do
		if current:IsA("Model") then
			local knownEntityId = modelToEntityId[current]
			if knownEntityId ~= nil then
				return knownEntityId
			end

			local attributeId = current:GetAttribute("EntityId")
			if type(attributeId) == "string" and entitiesById[attributeId] ~= nil then
				return attributeId
			end
		end
		current = current.Parent
	end

	return nil
end

local function applyTurretDeathExplosion(state: HealthStateInternal, turretSeat: Seat?, operatorHumanoid: Humanoid?)
	if turretSeat == nil then
		return
	end

	local damageRadius = math.max(0, readConfigNumber("TurretDeathExplosionRadius", 22))
	local visualRadius = math.max(
		damageRadius,
		readConfigNumber("TurretDeathExplosionVisualRadius", damageRadius > 0 and damageRadius * 1.35 or 30)
	)
	local maxDamage = math.max(0, readConfigNumber("TurretDeathExplosionDamage", 220))
	if damageRadius <= 0 or maxDamage <= 0 then
		return
	end

	local center = turretSeat.Position
	local explosionVisual = Instance.new("Explosion")
	explosionVisual.Position = center
	explosionVisual.BlastRadius = visualRadius
	explosionVisual.BlastPressure = 0
	explosionVisual.DestroyJointRadiusPercent = 0
	explosionVisual.Parent = Workspace

	-- The turret operator always dies when their turret is destroyed.
	if operatorHumanoid ~= nil and operatorHumanoid.Health > 0 then
		operatorHumanoid:TakeDamage(1_000_000)
	end

	explosionOverlapParams.FilterType = Enum.RaycastFilterType.Exclude
	explosionOverlapParams.FilterDescendantsInstances = { state.instance }
	explosionOverlapParams.MaxParts = 256
	local nearbyParts = Workspace:GetPartBoundsInRadius(center, damageRadius, explosionOverlapParams)
	local closestDistanceByEntityId: { [string]: number } = {}
	local closestDistanceByModel: { [Model]: number } = {}

	for _, part in ipairs(nearbyParts) do
		local distance = distancePointToPartBounds(center, part)
		if distance > damageRadius then
			continue
		end

		local targetEntityId = findEntityIdFromInstance(part)
		if targetEntityId ~= nil then
			if targetEntityId ~= state.entityId and HealthManager.isAlive(targetEntityId) then
				local previous = closestDistanceByEntityId[targetEntityId]
				if previous == nil or distance < previous then
					closestDistanceByEntityId[targetEntityId] = distance
				end
			end
		else
			local model = part:FindFirstAncestorOfClass("Model")
			if model ~= nil then
				local previous = closestDistanceByModel[model]
				if previous == nil or distance < previous then
					closestDistanceByModel[model] = distance
				end
			end
		end
	end

	for targetEntityId, distance in pairs(closestDistanceByEntityId) do
		local scale = computeExplosionFalloffScale(distance, damageRadius)
		local damage = math.max(0, math.floor(maxDamage * scale + 0.5))
		if damage > 0 then
			HealthManager.applyDamage(targetEntityId, damage, "explosion", state.faction, center, true)
		end
	end

	for model, distance in pairs(closestDistanceByModel) do
		if model ~= state.instance then
			local humanoid = model:FindFirstChildOfClass("Humanoid")
			if humanoid ~= nil and humanoid.Health > 0 then
				local scale = computeExplosionFalloffScale(distance, damageRadius)
				local damage = math.max(0, math.floor(maxDamage * scale + 0.5))
				if damage > 0 then
					humanoid:TakeDamage(damage)
				end
			end
		end
	end

	print(
		string.format(
			"[P1_TURRET_EXPLOSION] entity=%s damageRadius=%.1f visualRadius=%.1f maxDamage=%.1f",
			state.entityId,
			damageRadius,
			visualRadius,
			maxDamage
		)
	)
end

local function destroyEntity(state: HealthStateInternal)
	if state.state ~= CombatEnums.EntityState.Active then
		return
	end

	state.state = CombatEnums.EntityState.Destroyed

	local seat = state.instance:FindFirstChildWhichIsA("Seat", true)
	local operatorHumanoid: Humanoid? = nil
	if seat ~= nil and seat.Occupant ~= nil then
		operatorHumanoid = seat.Occupant
		seat.Occupant.Sit = false
	end
	applyTurretDeathExplosion(state, seat, operatorHumanoid)

	state.partStates = collectAndHideParts(state.instance)
	state.promptStates = collectAndDisablePrompts(state.instance)

	local _, destroyedRemote = getRemotes()
	local destroyPayload: EntityDestroyedPayload = {
		entityId = state.entityId,
		explosionPosition = if seat ~= nil then seat.Position else state.instance:GetPivot().Position,
		explosionRadius = readConfigNumber("TurretDeathExplosionRadius", 22),
	}
	destroyedRemote:FireAllClients(destroyPayload)
	print(string.format("[P1_DESTROYED] entity=%s tick=%.3f", state.entityId, tick()))

	if state.config.respawnTime ~= nil and state.config.respawnTime > 0 then
		local respawnTime = state.config.respawnTime
		state.respawnTimer = task.spawn(function()
			task.wait(respawnTime)
			if entitiesById[state.entityId] ~= state then
				return
			end

			restoreParts(state)
			restorePrompts(state)
			state.currentHP = state.maxHP
				state.currentShieldHP = state.maxShieldHP
				state.lastShieldDamageTime = tick()
				state.state = CombatEnums.EntityState.Active
				state.respawnTimer = nil
				setModelHealthAttributes(state.instance, state.currentHP, state.maxHP, state.currentShieldHP, state.maxShieldHP)
				if respawnCallback ~= nil then
					local ok, callbackErr = pcall(respawnCallback, state.entityId)
					if not ok then
						warn(string.format("[P3_RESPAWN_CALLBACK] entity=%s error=%s", state.entityId, tostring(callbackErr)))
					end
				end

				local _, _, respawnedRemote = getRemotes()
			local payload: CombatTypes.RespawnedPayload = {
				entityId = state.entityId,
				hullHP = state.maxHP,
				shieldHP = if state.maxShieldHP > 0 then state.maxShieldHP else nil,
			}
			respawnedRemote:FireAllClients(payload)
			print(string.format("[P1_RESPAWNED] entity=%s hullHP=%d tick=%.3f", state.entityId, state.maxHP, tick()))
		end)
	end
end

function HealthManager.init(remotes: Folder)
	remotesFolder = remotes
	damageAppliedRemote = remotesFolder:WaitForChild("DamageApplied") :: RemoteEvent
	entityDestroyedRemote = remotesFolder:WaitForChild("EntityDestroyed") :: RemoteEvent
	entityRespawnedRemote = remotesFolder:WaitForChild("EntityRespawned") :: RemoteEvent

	Players.PlayerRemoving:Connect(function(_player)
		-- No per-player state in pass 1.
	end)

	if heartbeatConnection == nil then
		heartbeatConnection = RunService.Heartbeat:Connect(stepShieldRegen)
	end
end

function HealthManager.registerEntity(entityId: string, validated: ValidatedEntity)
	local entityConfig: EntityConfig? = CombatConfig.Entities[validated.configId]
	if entityConfig == nil then
		warn(string.format("[P1_REGISTER_FAIL] entity=%s missing config '%s'", entityId, validated.configId))
		return
	end

	local maxHP = entityConfig.hullHP
	local maxShieldHP = 0
	if type(entityConfig.shieldHP) == "number" then
		maxShieldHP = math.max(0, entityConfig.shieldHP)
	end
	local state: HealthStateInternal = {
		entityId = entityId,
		instance = validated.instance,
		faction = validated.faction,
		config = entityConfig,
		currentHP = maxHP,
		maxHP = maxHP,
		currentShieldHP = maxShieldHP,
		maxShieldHP = maxShieldHP,
		state = CombatEnums.EntityState.Active,
		respawnTimer = nil,
		partStates = nil,
		promptStates = nil,
		lastShieldDamageTime = 0,
	}

	entitiesById[entityId] = state
	modelToEntityId[validated.instance] = entityId
	setModelHealthAttributes(validated.instance, maxHP, maxHP, maxShieldHP, maxShieldHP)
end

function HealthManager.applyDamage(
	entityId: string,
	damage: number,
	damageType: string,
	attackerFaction: string,
	hitPosition: Vector3,
	ignoreFactionCheck: boolean?
): (boolean, string?, boolean)
	local state = entitiesById[entityId]
	if state == nil then
		return false, nil, false
	end

	if state.state ~= CombatEnums.EntityState.Active then
		return false, nil, false
	end

	if not ignoreFactionCheck and not CombatConfig.FriendlyFireEnabled and state.faction == attackerFaction then
		print(string.format("[P1_FACTION_BLOCK] attackerFaction=%s targetEntityId=%s", attackerFaction, entityId))
		return false, nil, false
	end

	local appliedDamage = math.max(0, damage)
	if appliedDamage <= 0 then
		return false, nil, false
	end

	local multiplier = getDamageTypeMultiplier(damageType)
	local shieldMult = multiplier.shieldMult
	local hullMult = multiplier.hullMult
	local bypassFraction = if type(multiplier.bypass) == "number" then multiplier.bypass else 0
	if math.abs(shieldMult - 1) > 1e-4 or math.abs(hullMult - 1) > 1e-4 or bypassFraction > 1e-4 then
		print(
			string.format(
				"[P3_MULT] entity=%s type=%s shieldM=%.2f hullM=%.2f bypass=%.0f%%",
				entityId,
				damageType,
				shieldMult,
				hullMult,
				bypassFraction * 100
			)
		)
	end

	local impactType = CombatEnums.ImpactType.Hull
	local didBreakShield = false
	local oldShieldHP = state.currentShieldHP
	local oldHP = state.currentHP
	local hullDamage = 0
	if oldShieldHP > 0 then
		impactType = CombatEnums.ImpactType.Shield
		local bypassBase = appliedDamage * bypassFraction
		local shieldFacingBase = appliedDamage * (1 - bypassFraction)
		local shieldDamage = shieldFacingBase * shieldMult
		local absorbedShieldDamage = math.min(oldShieldHP, shieldDamage)
		state.currentShieldHP = math.max(0, oldShieldHP - absorbedShieldDamage)

		local overflowShieldDamage = math.max(0, shieldDamage - absorbedShieldDamage)
		local overflowBase = overflowShieldDamage / math.max(shieldMult, 0.001)
		local bypassHullDamage = bypassBase * hullMult
		local overflowHullDamage = overflowBase * hullMult
		hullDamage = math.max(0, bypassHullDamage + overflowHullDamage)

		if absorbedShieldDamage > 0 then
			state.lastShieldDamageTime = tick()
		end
		if bypassHullDamage > 0 then
			print(string.format("[P3_BYPASS] entity=%s bypassDmg=%.1f", entityId, bypassHullDamage))
		end

		if state.currentShieldHP <= 0 then
			didBreakShield = true
		end
	else
		hullDamage = math.max(0, appliedDamage * hullMult)
	end

	local nextHP = oldHP
	if hullDamage > 0 then
		nextHP = math.max(0, oldHP - hullDamage)
		state.currentHP = nextHP
		print(
			string.format(
				"[P1_DAMAGE] entity=%s %d->%d (%s, -%d)",
				entityId,
				math.floor(oldHP + 0.5),
				math.floor(nextHP + 0.5),
				damageType,
				math.floor(hullDamage + 0.5)
			)
		)
	end

	setModelHealthAttributes(state.instance, state.currentHP, state.maxHP, state.currentShieldHP, state.maxShieldHP)

	local damageRemote = getRemotes()
	local payload: CombatTypes.DamagePayload = {
		entityId = entityId,
		newHP = nextHP,
		maxHP = state.maxHP,
		hitPosition = hitPosition,
		newShieldHP = if state.maxShieldHP > 0 then state.currentShieldHP else nil,
		maxShieldHP = if state.maxShieldHP > 0 then state.maxShieldHP else nil,
	}
	damageRemote:FireAllClients(payload)

	if nextHP <= 0 then
		destroyEntity(state)
	end

	return true, impactType, didBreakShield
end

function HealthManager.setRespawnCallback(callback: (string) -> ())
	respawnCallback = callback
end

function HealthManager.getHealth(entityId: string): HealthState?
	return entitiesById[entityId]
end

function HealthManager.getShieldHP(entityId: string): (number?, number?)
	local state = entitiesById[entityId]
	if state == nil then
		return nil, nil
	end
	return state.currentShieldHP, state.maxShieldHP
end

function HealthManager.isAlive(entityId: string): boolean
	local state = entitiesById[entityId]
	return state ~= nil and state.state == CombatEnums.EntityState.Active
end

function HealthManager.getFaction(entityId: string): string?
	local state = entitiesById[entityId]
	if state == nil then
		return nil
	end
	return state.faction
end

function HealthManager.findEntityFromInstance(instance: Instance): string?
	return findEntityIdFromInstance(instance)
end

return HealthManager
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="14">
        <Properties>
          <string name="Name">Projectiles</string>
        </Properties>
        <Item class="ModuleScript" referent="15">
          <Properties>
            <string name="Name">ProjectileServer</string>
            <string name="Source"><![CDATA[--!strict

local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")

local sharedRoot = ReplicatedStorage:WaitForChild("CombatFramework")
local CombatConfig = require(sharedRoot:WaitForChild("CombatConfig"))
local CombatEnums = require(sharedRoot:WaitForChild("CombatEnums"))
local CombatTypes = require(sharedRoot:WaitForChild("CombatTypes"))

local ServerScriptService = game:GetService("ServerScriptService")
local serverRoot = ServerScriptService:WaitForChild("CombatFramework")
local HealthManager = require(serverRoot:WaitForChild("Health"):WaitForChild("HealthManager"))

type ProjectileData = CombatTypes.ProjectileData
type ProjectileImpactPayload = CombatTypes.ProjectileImpactPayload
type HitConfirmPayload = CombatTypes.HitConfirmPayload

local ProjectileServer = {}

local remotesFolder: Folder? = nil
local projectileFiredRemote: RemoteEvent? = nil
local projectileImpactRemote: RemoteEvent? = nil
local hitConfirmRemote: RemoteEvent? = nil
local heartbeatConnection: RBXScriptConnection? = nil

local activeProjectiles: { [string]: ProjectileData } = {}
local raycastParams = RaycastParams.new()
local raycastExcludeList: { Instance } = {}
local overlapParams = OverlapParams.new()
local projectileIdsToRemove: { string } = {}
local homingLogTimeByProjectileId: { [string]: number } = {}
local homingLostLoggedByProjectileId: { [string]: boolean } = {}

local function distancePointToPartBounds(point: Vector3, part: BasePart): number
	local localPoint = part.CFrame:PointToObjectSpace(point)
	local halfSize = part.Size * 0.5
	local dx = math.max(math.abs(localPoint.X) - halfSize.X, 0)
	local dy = math.max(math.abs(localPoint.Y) - halfSize.Y, 0)
	local dz = math.max(math.abs(localPoint.Z) - halfSize.Z, 0)
	return math.sqrt(dx * dx + dy * dy + dz * dz)
end

local function normalizeTeamOrFaction(raw: string?): string?
	if raw == nil then
		return nil
	end
	local trimmed = string.match(raw, "^%s*(.-)%s*$")
	if trimmed == nil or trimmed == "" then
		return nil
	end
	return string.lower(trimmed)
end

local function applyDamageToHumanoidTarget(
	projectile: ProjectileData,
	targetModel: Model,
	hitPosition: Vector3,
	damageAmount: number?
): (boolean, boolean, string?, string?, boolean)
	local humanoid = targetModel:FindFirstChildOfClass("Humanoid")
	if humanoid == nil or humanoid.Health <= 0 then
		return false, false, nil, nil, false
	end

	local targetPlayer = Players:GetPlayerFromCharacter(targetModel)
	if projectile.sourceCharacter ~= nil and targetModel == projectile.sourceCharacter then
		return false, false, nil, nil, false
	end

	if not CombatConfig.FriendlyFireEnabled and targetPlayer ~= nil then
		local attackerFaction = normalizeTeamOrFaction(projectile.faction)
		local targetFaction = normalizeTeamOrFaction(if targetPlayer.Team ~= nil then targetPlayer.Team.Name else nil)
		if attackerFaction ~= nil and targetFaction ~= nil and attackerFaction == targetFaction then
			print(string.format("[P1_FACTION_BLOCK] attackerFaction=%s targetPlayer=%s", attackerFaction, targetPlayer.Name))
			return false, false, nil, nil, false
		end
	end

	local seatPart = humanoid.SeatPart
	if seatPart ~= nil and CollectionService:HasTag(seatPart, "TurretSeat") then
		local seatedTurret = seatPart:FindFirstAncestorWhichIsA("Model")
		if seatedTurret ~= nil and seatedTurret:GetAttribute("TurretExposed") ~= true then
			local turretEntityId = seatedTurret:GetAttribute("EntityId")
			local playerName = if targetPlayer ~= nil then targetPlayer.Name else targetModel.Name
			print(string.format(
				"[P4_ENCLOSED_BLOCK] projectile=%s player=%s turret=%s",
				projectile.projectileId,
				playerName,
				tostring(turretEntityId)
			))
			return false, false, nil, nil, false
		end
	end

	local appliedDamage = math.max(0, damageAmount or projectile.damage)
	if appliedDamage <= 0 then
		return false, false, nil, nil, false
	end

	local previousHealth = humanoid.Health
	humanoid:TakeDamage(appliedDamage)
	local killed = previousHealth > 0 and humanoid.Health <= 0
	local targetId = if targetPlayer ~= nil then ("player_" .. tostring(targetPlayer.UserId)) else targetModel:GetFullName()
	print(
		string.format(
			"[P1_HIT_PLAYER] projectile=%s target=%s %.1f->%.1f",
			projectile.projectileId,
			targetId,
			previousHealth,
			humanoid.Health
		)
	)
	return true, killed, targetId, CombatEnums.ImpactType.Hull, false
end

local function applyDamageToCombatEntity(
	projectile: ProjectileData,
	targetEntityId: string,
	hitPosition: Vector3,
	damageAmount: number?
): (boolean, boolean, string, string?, boolean)
	local previousState = HealthManager.getHealth(targetEntityId)
	local previousHP = if previousState ~= nil then previousState.currentHP else 0
	local appliedDamage = math.max(0, damageAmount or projectile.damage)
	if appliedDamage <= 0 then
		return false, false, targetEntityId, nil, false
	end

	print(string.format("[P1_HIT] projectile=%s target=%s hitPos=%s", projectile.projectileId, targetEntityId, tostring(hitPosition)))
	local didApplyDamage, impactType, didBreakShield = HealthManager.applyDamage(
		targetEntityId,
		appliedDamage,
		projectile.damageType,
		projectile.faction,
		hitPosition
	)
	local nextState = HealthManager.getHealth(targetEntityId)
	local nextHP = if nextState ~= nil then nextState.currentHP else 0
	local didKill = didApplyDamage and previousHP > 0 and nextHP <= 0
	return didApplyDamage, didKill, targetEntityId, impactType, didBreakShield
end

local function applyDamageForHitInstance(
	projectile: ProjectileData,
	hitInstance: Instance,
	hitPosition: Vector3,
	damageAmount: number?
): (boolean, boolean, string?, string?, boolean)
	local targetEntityId = HealthManager.findEntityFromInstance(hitInstance)
	if targetEntityId ~= nil and HealthManager.isAlive(targetEntityId) then
		local didApplyDamage, didKill, targetId, impactType, didBreakShield =
			applyDamageToCombatEntity(projectile, targetEntityId, hitPosition, damageAmount)
		return didApplyDamage, didKill, targetId, impactType, didBreakShield
	end

	local targetModel = hitInstance:FindFirstAncestorOfClass("Model")
	if targetModel ~= nil then
		return applyDamageToHumanoidTarget(projectile, targetModel, hitPosition, damageAmount)
	end

	return false, false, nil, nil, false
end

local function applySplashDamage(
	projectile: ProjectileData,
	hitPosition: Vector3,
	directTargetId: string?,
	directTargetModel: Model?
): (boolean, boolean, string?)
	local radius = if type(projectile.splashRadius) == "number" then projectile.splashRadius else 0
	if radius <= 0 then
		return false, false, nil
	end

	table.clear(raycastExcludeList)
	raycastExcludeList[1] = projectile.sourceInstance
	if projectile.sourceCharacter ~= nil then
		raycastExcludeList[2] = projectile.sourceCharacter
	end
	overlapParams.FilterType = Enum.RaycastFilterType.Exclude
	overlapParams.FilterDescendantsInstances = raycastExcludeList
	overlapParams.MaxParts = 128

	local nearbyParts = Workspace:GetPartBoundsInRadius(hitPosition, radius, overlapParams)
	local closestDistanceByEntityId: { [string]: number } = {}
	local closestDistanceByModel: { [Model]: number } = {}
	local didAnyDamage = false
	local didAnyKill = false
	local firstTargetId: string? = nil

	for _, part in ipairs(nearbyParts) do
		local distance = distancePointToPartBounds(hitPosition, part)
		if distance > radius then
			continue
		end

		local entityId = HealthManager.findEntityFromInstance(part)
		if entityId ~= nil then
			if entityId ~= directTargetId then
				local previous = closestDistanceByEntityId[entityId]
				if previous == nil or distance < previous then
					closestDistanceByEntityId[entityId] = distance
				end
			end
		else
			local model = part:FindFirstAncestorOfClass("Model")
			if model ~= nil and model ~= directTargetModel then
				local previous = closestDistanceByModel[model]
				if previous == nil or distance < previous then
					closestDistanceByModel[model] = distance
				end
			end
		end
	end

	for entityId, distance in pairs(closestDistanceByEntityId) do
		if HealthManager.isAlive(entityId) then
			local scale = math.clamp(1 - (distance / math.max(radius, 1e-4)), 0, 1)
			local splashDamage = math.max(0, math.floor(projectile.damage * scale + 0.5))
			if splashDamage > 0 then
				local didDamage, didKill, targetId = applyDamageToCombatEntity(projectile, entityId, hitPosition, splashDamage)
				if didDamage then
					didAnyDamage = true
					didAnyKill = didAnyKill or didKill
					if firstTargetId == nil then
						firstTargetId = targetId
					end
				end
			end
		end
	end

	for model, distance in pairs(closestDistanceByModel) do
		local scale = math.clamp(1 - (distance / math.max(radius, 1e-4)), 0, 1)
		local splashDamage = math.max(0, math.floor(projectile.damage * scale + 0.5))
		if splashDamage > 0 then
			local didDamage, didKill, targetId = applyDamageToHumanoidTarget(projectile, model, hitPosition, splashDamage)
			if didDamage then
				didAnyDamage = true
				didAnyKill = didAnyKill or didKill
				if firstTargetId == nil then
					firstTargetId = targetId
				end
			end
		end
	end

	return didAnyDamage, didAnyKill, firstTargetId
end

local function getProjectileRemote(): RemoteEvent
	if projectileFiredRemote == nil then
		error("ProjectileServer not initialized with remotes")
	end
	return projectileFiredRemote
end

local function getProjectileImpactRemote(): RemoteEvent
	if projectileImpactRemote == nil then
		error("ProjectileServer not initialized with impact remote")
	end
	return projectileImpactRemote
end

local function getHitConfirmRemote(): RemoteEvent
	if hitConfirmRemote == nil then
		error("ProjectileServer not initialized with hit confirm remote")
	end
	return hitConfirmRemote
end

local function rotateDirectionToward(currentDirection: Vector3, targetDirection: Vector3, maxTurnRadians: number): Vector3
	if currentDirection.Magnitude < 1e-4 then
		return targetDirection.Unit
	end
	if targetDirection.Magnitude < 1e-4 then
		return currentDirection.Unit
	end
	if maxTurnRadians <= 0 then
		return currentDirection.Unit
	end

	local currentUnit = currentDirection.Unit
	local targetUnit = targetDirection.Unit
	local dot = math.clamp(currentUnit:Dot(targetUnit), -1, 1)
	local angle = math.acos(dot)
	if angle <= maxTurnRadians then
		return targetUnit
	end

	local alpha = maxTurnRadians / math.max(angle, 1e-4)
	return (currentUnit:Lerp(targetUnit, alpha)).Unit
end

local function getTargetPositionForHoming(targetEntityId: string): Vector3?
	if not HealthManager.isAlive(targetEntityId) then
		return nil
	end

	local targetState = HealthManager.getHealth(targetEntityId)
	if targetState == nil or targetState.instance.Parent == nil then
		return nil
	end

	return targetState.instance:GetPivot().Position
end

local function stepProjectiles(dt: number)
	table.clear(projectileIdsToRemove)
	local now = tick()

	for projectileId, projectile in pairs(activeProjectiles) do
		local previousPosition: Vector3
		local currentPosition: Vector3
		local homingActive = type(projectile.targetEntityId) == "string"
			and type(projectile.homingTurnRate) == "number"
			and (projectile.homingTurnRate :: number) > 0

		if homingActive then
			previousPosition = projectile.currentPosition or projectile.origin
			local targetPosition = getTargetPositionForHoming(projectile.targetEntityId :: string)
			if targetPosition ~= nil then
				local toTarget = targetPosition - previousPosition
				if toTarget.Magnitude > 1e-4 then
					local currentDirection = projectile.direction.Unit
					local maxTurnRadians = math.rad(projectile.homingTurnRate :: number) * dt
					local rotatedDirection = rotateDirectionToward(currentDirection, toTarget.Unit, maxTurnRadians)
					projectile.direction = rotatedDirection

					local logGate = homingLogTimeByProjectileId[projectileId]
					if logGate == nil or now - logGate >= 0.2 then
						local turnDot = math.clamp(currentDirection:Dot(rotatedDirection), -1, 1)
						local turnAngleDegrees = math.deg(math.acos(turnDot))
						print(string.format(
							"[P4_HOMING] projectile=%s target=%s turn=%.2f",
							projectileId,
							projectile.targetEntityId :: string,
							turnAngleDegrees
						))
						homingLogTimeByProjectileId[projectileId] = now
					end
				end
			elseif not homingLostLoggedByProjectileId[projectileId] then
				print(string.format(
					"[P4_HOMING_LOST] projectile=%s target=%s",
					projectileId,
					tostring(projectile.targetEntityId)
				))
				homingLostLoggedByProjectileId[projectileId] = true
			end

			currentPosition = previousPosition + projectile.direction.Unit * projectile.speed * dt
			projectile.currentPosition = currentPosition
		else
			local elapsed = now - projectile.createdAt
			local previousElapsed = math.max(0, elapsed - dt)
			currentPosition = projectile.origin + projectile.direction * projectile.speed * elapsed
			previousPosition = projectile.origin + projectile.direction * projectile.speed * previousElapsed
		end

		local traveledDistance = (currentPosition - projectile.origin).Magnitude

		if traveledDistance >= projectile.maxRange then
			print(string.format("[P1_EXPIRED] projectile=%s distance=%.2f", projectileId, traveledDistance))
			table.insert(projectileIdsToRemove, projectileId)
			continue
		end

		local sweepDirection = currentPosition - previousPosition
		if sweepDirection.Magnitude <= 0 then
			continue
		end

		table.clear(raycastExcludeList)
		raycastExcludeList[1] = projectile.sourceInstance
		if projectile.sourceCharacter ~= nil then
			raycastExcludeList[2] = projectile.sourceCharacter
		end
		raycastParams.FilterDescendantsInstances = raycastExcludeList

		local hitResult: RaycastResult?
		if CombatConfig.ProjectileRayRadius > 0 then
			hitResult = Workspace:Spherecast(previousPosition, CombatConfig.ProjectileRayRadius, sweepDirection, raycastParams)
		else
			hitResult = Workspace:Raycast(previousPosition, sweepDirection, raycastParams)
		end

		if hitResult ~= nil then
			local hitInstance = hitResult.Instance
			if hitInstance:IsDescendantOf(projectile.sourceInstance)
				or (projectile.sourceCharacter ~= nil and hitInstance:IsDescendantOf(projectile.sourceCharacter))
			then
				continue
			end

			local didApplyDamage, didKill, hitTargetId, impactType, shieldBroken =
				applyDamageForHitInstance(projectile, hitInstance, hitResult.Position, projectile.damage)

			local directTargetModel = hitInstance:FindFirstAncestorOfClass("Model")
			local didSplashDamage, didSplashKill, splashTargetId =
				applySplashDamage(projectile, hitResult.Position, hitTargetId, directTargetModel)
			if didSplashDamage then
				didApplyDamage = true
				didKill = didKill or didSplashKill
				if hitTargetId == nil then
					hitTargetId = splashTargetId
				end
			end

			local impactPayload: ProjectileImpactPayload = {
				projectileId = projectileId,
				hitPosition = hitResult.Position,
				hitNormal = hitResult.Normal,
				impactType = impactType or CombatEnums.ImpactType.Environment,
				shieldBroken = if shieldBroken then true else nil,
			}
			getProjectileImpactRemote():FireAllClients(impactPayload)

			if didApplyDamage and projectile.sourceCharacter ~= nil then
				local shooterPlayer = Players:GetPlayerFromCharacter(projectile.sourceCharacter)
				if shooterPlayer ~= nil then
					local hitConfirmPayload: HitConfirmPayload = {
						targetEntityId = hitTargetId or "unknown",
						hitPosition = hitResult.Position,
						isKill = didKill,
					}
					getHitConfirmRemote():FireClient(shooterPlayer, hitConfirmPayload)
				end
			end

			table.insert(projectileIdsToRemove, projectileId)
		end
	end

	for _, projectileId in ipairs(projectileIdsToRemove) do
		activeProjectiles[projectileId] = nil
		homingLogTimeByProjectileId[projectileId] = nil
		homingLostLoggedByProjectileId[projectileId] = nil
	end
end

function ProjectileServer.init(remotes: Folder)
	remotesFolder = remotes
	projectileFiredRemote = remotesFolder:WaitForChild("ProjectileFired") :: RemoteEvent
	projectileImpactRemote = remotesFolder:WaitForChild("ProjectileImpact") :: RemoteEvent
	hitConfirmRemote = remotesFolder:WaitForChild("HitConfirm") :: RemoteEvent

	raycastParams.FilterType = Enum.RaycastFilterType.Exclude
	raycastParams.IgnoreWater = true
	overlapParams.FilterType = Enum.RaycastFilterType.Exclude
	overlapParams.MaxParts = 128

	if heartbeatConnection == nil then
		heartbeatConnection = RunService.Heartbeat:Connect(stepProjectiles)
	end
end

function ProjectileServer.fireProjectile(data: ProjectileData)
	activeProjectiles[data.projectileId] = data

	local projectileRemote = getProjectileRemote()
	projectileRemote:FireAllClients({
		projectileId = data.projectileId,
		origin = data.origin,
		direction = data.direction,
		speed = data.speed,
		maxRange = data.maxRange,
		damageType = data.damageType,
		targetEntityId = data.targetEntityId,
		homingTurnRate = data.homingTurnRate,
		boltColor = data.boltColor,
	})

	print(string.format(
		"[P1_FIRE] projectile=%s source=%s dir=%s speed=%d",
		data.projectileId,
		data.sourceEntityId,
		tostring(data.direction),
		data.speed
	))
end

function ProjectileServer.getActiveCount(): number
	local count = 0
	for _ in pairs(activeProjectiles) do
		count += 1
	end
	return count
end

return ProjectileServer
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="16">
        <Properties>
          <string name="Name">Targeting</string>
        </Properties>
        <Item class="ModuleScript" referent="17">
          <Properties>
            <string name="Name">TargetingServer</string>
            <string name="Source"><![CDATA[--!strict

local CollectionService = game:GetService("CollectionService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local sharedRoot = ReplicatedStorage:WaitForChild("CombatFramework")
local CombatConfig = require(sharedRoot:WaitForChild("CombatConfig"))
local CombatTypes = require(sharedRoot:WaitForChild("CombatTypes"))
local LeadSolver = require(sharedRoot:WaitForChild("LeadSolver"))
local WeaponRig = require(sharedRoot:WaitForChild("WeaponRig"))

local ServerScriptService = game:GetService("ServerScriptService")
local serverRoot = ServerScriptService:WaitForChild("CombatFramework")
local HealthManager = require(serverRoot:WaitForChild("Health"):WaitForChild("HealthManager"))

type HealthState = CombatTypes.HealthState
type LockState = CombatTypes.LockState

type RuntimeLockState = LockState & {
	player: Player?,
}

type TargetVelocitySample = {
	lastPosition: Vector3,
	lastTime: number,
	velocity: Vector3,
}

local TargetingServer = {}

local requestLockRemote: RemoteEvent? = nil
local clearLockRemote: RemoteEvent? = nil
local lockOnStateRemote: RemoteEvent? = nil
local requestLockConnection: RBXScriptConnection? = nil
local clearLockConnection: RBXScriptConnection? = nil
local heartbeatConnection: RBXScriptConnection? = nil
local playerRemovingConnection: RBXScriptConnection? = nil

local locksByEntityId: { [string]: RuntimeLockState } = {}
local lockedEntityByPlayer: { [Player]: string } = {}
local velocitySamplesByEntityId: { [string]: TargetVelocitySample } = {}
local validationAccumulator = 0
local MIN_SAMPLE_DT = 1 / 240
local VELOCITY_SMOOTH_ALPHA = 0.35

local function getLockOnStateRemote(): RemoteEvent
	if lockOnStateRemote == nil then
		error("TargetingServer not initialized")
	end
	return lockOnStateRemote
end

local function findTaggedDescendant(model: Model, tagName: string, className: string?): Instance?
	for _, descendant in ipairs(model:GetDescendants()) do
		if CollectionService:HasTag(descendant, tagName) then
			if className == nil or descendant:IsA(className) then
				return descendant
			end
		end
	end
	return nil
end

local function getPlayerTurretContext(player: Player): (string?, HealthState?, BasePart?)
	local character = player.Character
	if character == nil then
		return nil, nil, nil
	end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if humanoid == nil then
		return nil, nil, nil
	end

	local seatPart = humanoid.SeatPart
	if seatPart == nil or not CollectionService:HasTag(seatPart, "TurretSeat") then
		return nil, nil, nil
	end

	local turretModel = seatPart:FindFirstAncestorWhichIsA("Model")
	if turretModel == nil then
		return nil, nil, nil
	end

	local entityIdAttr = turretModel:GetAttribute("EntityId")
	if type(entityIdAttr) ~= "string" then
		return nil, nil, nil
	end

	local attackerEntityId = entityIdAttr
	local attackerHealthState = HealthManager.getHealth(attackerEntityId)
	if attackerHealthState == nil or not HealthManager.isAlive(attackerEntityId) then
		return nil, nil, nil
	end

	local weaponMount = findTaggedDescendant(attackerHealthState.instance, "WeaponMount", "BasePart")
	if weaponMount == nil then
		return nil, nil, nil
	end

	return attackerEntityId, attackerHealthState, weaponMount :: BasePart
end

local function getEffectiveLockRange(attackerHealthState: HealthState): number?
	local attackerModel = attackerHealthState.instance
	local effectiveAttr = attackerModel:GetAttribute("EffectiveWeaponLockRange")
	if type(effectiveAttr) == "number" and effectiveAttr > 0 then
		return effectiveAttr
	end

	if type(attackerHealthState.config.weaponId) ~= "string" then
		return nil
	end
	local weaponConfig = CombatConfig.Weapons[attackerHealthState.config.weaponId]
	if weaponConfig == nil or type(weaponConfig.lockRange) ~= "number" or weaponConfig.lockRange <= 0 then
		return nil
	end
	return weaponConfig.lockRange
end

local function estimateAssemblyVelocity(targetModel: Model): Vector3
	local rootPart = targetModel.PrimaryPart
	if rootPart == nil then
		rootPart = targetModel:FindFirstChildWhichIsA("BasePart", true)
	end
	if rootPart == nil then
		return Vector3.zero
	end
	return rootPart.AssemblyLinearVelocity
end

local function getTargetPositionAndVelocity(targetEntityId: string, targetState: HealthState): (Vector3?, Vector3)
	local targetModel = targetState.instance
	if targetModel.Parent == nil then
		velocitySamplesByEntityId[targetEntityId] = nil
		return nil, Vector3.zero
	end

	local now = tick()
	local targetPosition = targetModel:GetPivot().Position
	local velocity = estimateAssemblyVelocity(targetModel)

	local sample = velocitySamplesByEntityId[targetEntityId]
	if sample == nil then
		velocitySamplesByEntityId[targetEntityId] = {
			lastPosition = targetPosition,
			lastTime = now,
			velocity = velocity,
		}
		return targetPosition, velocity
	end

	local dt = now - sample.lastTime
	if dt >= MIN_SAMPLE_DT then
		local observedVelocity = (targetPosition - sample.lastPosition) / dt
		sample.velocity = sample.velocity:Lerp(observedVelocity, VELOCITY_SMOOTH_ALPHA)
		sample.lastPosition = targetPosition
		sample.lastTime = now
	end

	return targetPosition, sample.velocity
end

local function isDirectionWithinMountArc(weaponMount: BasePart, desiredDirection: Vector3): boolean
	if desiredDirection.Magnitude < 1e-4 then
		return false
	end

	local neutralAimFrame = WeaponRig.getNeutralAimFrame(weaponMount)
	local clampedDirection = WeaponRig.clampDirectionToMountLimits(weaponMount, neutralAimFrame, desiredDirection.Unit)
	if clampedDirection.Magnitude < 1e-4 then
		return false
	end

	local dot = math.clamp(clampedDirection:Dot(desiredDirection.Unit), -1, 1)
	return dot >= math.cos(math.rad(1.5))
end

local function sendLockState(
	player: Player,
	attackerEntityId: string,
	targetEntityId: string?,
	locked: boolean,
	reason: string?
)
	getLockOnStateRemote():FireClient(player, {
		attackerEntityId = attackerEntityId,
		targetEntityId = targetEntityId,
		locked = locked,
		reason = reason,
	})
end

local function getRequestTargetEntityId(rawPayload: any): string?
	if type(rawPayload) == "string" then
		return rawPayload
	end
	if type(rawPayload) == "table" then
		local tableTarget = rawPayload.targetEntityId
		if type(tableTarget) == "string" then
			return tableTarget
		end
	end
	return nil
end

local function validateLockCandidate(
	attackerEntityId: string,
	attackerHealthState: HealthState,
	weaponMount: BasePart,
	targetEntityId: string,
	rangeMultiplier: number
): (boolean, string?)
	if targetEntityId == attackerEntityId then
		return false, "self"
	end

	if not HealthManager.isAlive(targetEntityId) then
		return false, "dead"
	end

	local targetState = HealthManager.getHealth(targetEntityId)
	if targetState == nil then
		return false, "missing"
	end

	local attackerFaction = HealthManager.getFaction(attackerEntityId)
	local targetFaction = HealthManager.getFaction(targetEntityId)
	if attackerFaction ~= nil and targetFaction ~= nil and attackerFaction == targetFaction then
		return false, "friendly"
	end

	local lockRange = getEffectiveLockRange(attackerHealthState)
	if lockRange == nil then
		return false, "no_lock_range"
	end

	local targetPosition, _targetVelocity = getTargetPositionAndVelocity(targetEntityId, targetState)
	if targetPosition == nil then
		return false, "missing_target"
	end
	local sourcePosition = weaponMount.Position
	local toTarget = targetPosition - sourcePosition
	local distance = toTarget.Magnitude
	if distance <= 1e-4 then
		return false, "distance"
	end

	if distance > lockRange * rangeMultiplier then
		return false, "range"
	end

	if not isDirectionWithinMountArc(weaponMount, toTarget.Unit) then
		return false, "arc"
	end

	return true, nil
end

local function clearLockInternal(attackerEntityId: string, reason: string, eventTag: string)
	local existing = locksByEntityId[attackerEntityId]
	if existing == nil then
		return
	end

	locksByEntityId[attackerEntityId] = nil
	if existing.player ~= nil and lockedEntityByPlayer[existing.player] == attackerEntityId then
		lockedEntityByPlayer[existing.player] = nil
	end

	if existing.player ~= nil then
		sendLockState(existing.player, attackerEntityId, nil, false, reason)
	end

	if eventTag == "broken" then
		print(string.format("[P4_LOCK_BROKEN] attacker=%s target=%s reason=%s", attackerEntityId, existing.targetEntityId, reason))
	else
		print(string.format("[P4_LOCK_CLEARED] attacker=%s reason=%s", attackerEntityId, reason))
	end
end

local function onRequestLock(player: Player, rawPayload: any)
	local targetEntityId = getRequestTargetEntityId(rawPayload)
	if targetEntityId == nil then
		return
	end

	local attackerEntityId, attackerHealthState, weaponMount = getPlayerTurretContext(player)
	if attackerEntityId == nil or attackerHealthState == nil or weaponMount == nil then
		return
	end

	local ok, reason = validateLockCandidate(attackerEntityId, attackerHealthState, weaponMount, targetEntityId, 1)
	if not ok then
		if reason == "friendly" then
			return
		end
		return
	end

	local previousForPlayer = lockedEntityByPlayer[player]
	if previousForPlayer ~= nil and previousForPlayer ~= attackerEntityId then
		clearLockInternal(previousForPlayer, "switch", "cleared")
	end

	locksByEntityId[attackerEntityId] = {
		attackerEntityId = attackerEntityId,
		targetEntityId = targetEntityId,
		lockedAt = tick(),
		player = player,
	}
	lockedEntityByPlayer[player] = attackerEntityId

	sendLockState(player, attackerEntityId, targetEntityId, true, nil)
	print(string.format("[P4_LOCK_ACQUIRED] attacker=%s target=%s", attackerEntityId, targetEntityId))
end

local function onClearLock(player: Player, _payload: any)
	local attackerEntityId = lockedEntityByPlayer[player]
	if attackerEntityId == nil then
		local contextEntityId = getPlayerTurretContext(player)
		if contextEntityId ~= nil then
			attackerEntityId = contextEntityId
		end
	end
	if attackerEntityId == nil then
		return
	end

	clearLockInternal(attackerEntityId, "manual", "cleared")
end

local function runValidationTick()
	for attackerEntityId, lockState in pairs(locksByEntityId) do
		local attackerHealthState: HealthState?
		local weaponMount: BasePart?
		if lockState.player ~= nil then
			local currentEntityId, playerHealthState, playerWeaponMount = getPlayerTurretContext(lockState.player)
			if currentEntityId == nil or playerHealthState == nil or playerWeaponMount == nil then
				clearLockInternal(attackerEntityId, "seat", "broken")
				continue
			end
			if currentEntityId ~= attackerEntityId then
				clearLockInternal(attackerEntityId, "seat", "broken")
				continue
			end
			attackerHealthState = playerHealthState
			weaponMount = playerWeaponMount
		else
			attackerHealthState = HealthManager.getHealth(attackerEntityId)
			if attackerHealthState ~= nil then
				local mountInstance = findTaggedDescendant(attackerHealthState.instance, "WeaponMount", "BasePart")
				if mountInstance ~= nil then
					weaponMount = mountInstance :: BasePart
				end
			end
			if attackerHealthState == nil or weaponMount == nil then
				clearLockInternal(attackerEntityId, "missing_attacker", "broken")
				continue
			end
		end

		local ok, reason = validateLockCandidate(
			attackerEntityId,
			attackerHealthState,
			weaponMount,
			lockState.targetEntityId,
			1
		)
		if not ok then
			clearLockInternal(attackerEntityId, reason or "invalid", "broken")
		end
	end
end

local function applySpread(direction: Vector3, spreadDegrees: number): Vector3
	if spreadDegrees <= 0 then
		return direction.Unit
	end

	local spreadRadians = math.rad(spreadDegrees)
	local yaw = (math.random() * 2 - 1) * spreadRadians
	local pitch = (math.random() * 2 - 1) * spreadRadians
	local lookFrame = CFrame.lookAt(Vector3.zero, direction.Unit)
	return (lookFrame * CFrame.Angles(pitch, yaw, 0)).LookVector.Unit
end

function TargetingServer.init(remotes: Folder)
	requestLockRemote = remotes:WaitForChild("RequestLockOn") :: RemoteEvent
	clearLockRemote = remotes:WaitForChild("ClearLockOn") :: RemoteEvent
	lockOnStateRemote = remotes:WaitForChild("LockOnState") :: RemoteEvent

	if requestLockConnection == nil then
		requestLockConnection = requestLockRemote.OnServerEvent:Connect(onRequestLock)
	end
	if clearLockConnection == nil then
		clearLockConnection = clearLockRemote.OnServerEvent:Connect(onClearLock)
	end
	if heartbeatConnection == nil then
		heartbeatConnection = RunService.Heartbeat:Connect(function(dt)
			validationAccumulator += dt
			if validationAccumulator < CombatConfig.LockValidationInterval then
				return
			end
			validationAccumulator = 0
			runValidationTick()
		end)
	end
	if playerRemovingConnection == nil then
		playerRemovingConnection = Players.PlayerRemoving:Connect(function(player)
			local attackerEntityId = lockedEntityByPlayer[player]
			if attackerEntityId ~= nil then
				clearLockInternal(attackerEntityId, "player_left", "cleared")
			end
			lockedEntityByPlayer[player] = nil
		end)
	end
end

function TargetingServer.getLockState(entityId: string): LockState?
	local runtimeState = locksByEntityId[entityId]
	if runtimeState == nil then
		return nil
	end

	return {
		attackerEntityId = runtimeState.attackerEntityId,
		targetEntityId = runtimeState.targetEntityId,
		lockedAt = runtimeState.lockedAt,
	}
end

function TargetingServer.clearLock(entityId: string)
	clearLockInternal(entityId, "clear", "cleared")
end

function TargetingServer.computeLeadDirection(
	sourcePosition: Vector3,
	targetEntityId: string,
	projectileSpeed: number,
	autoAimSpread: number
): Vector3?
	if projectileSpeed <= 0 then
		return nil
	end
	if not HealthManager.isAlive(targetEntityId) then
		return nil
	end

	local targetState = HealthManager.getHealth(targetEntityId)
	if targetState == nil then
		return nil
	end

	local targetPosition, targetVelocity = getTargetPositionAndVelocity(targetEntityId, targetState)
	if targetPosition == nil then
		return nil
	end

	local predicted, _travelTime =
		LeadSolver.solveInterceptPoint(sourcePosition, targetPosition, targetVelocity, projectileSpeed)
	if predicted == nil then
		return nil
	end

	local direction = predicted - sourcePosition
	if direction.Magnitude < 1e-4 then
		return nil
	end

	return applySpread(direction.Unit, math.max(0, autoAimSpread))
end

-- Studio-only helper for harness automation.
function TargetingServer.requestLockForTest(attackerEntityId: string, targetEntityId: string): boolean
	if not RunService:IsStudio() then
		return false
	end

	local runtimeState = locksByEntityId[attackerEntityId]
	local player = if runtimeState ~= nil then runtimeState.player else nil
	if player == nil then
		for candidatePlayer, lockedEntityId in pairs(lockedEntityByPlayer) do
			if lockedEntityId == attackerEntityId then
				player = candidatePlayer
				break
			end
		end
	end

	local attackerState = HealthManager.getHealth(attackerEntityId)
	if attackerState == nil or not HealthManager.isAlive(attackerEntityId) then
		return false
	end
	local weaponMount = findTaggedDescendant(attackerState.instance, "WeaponMount", "BasePart")
	if weaponMount == nil then
		return false
	end

	local ok = validateLockCandidate(attackerEntityId, attackerState, weaponMount :: BasePart, targetEntityId, 1)
	if not ok then
		return false
	end

	if runtimeState == nil then
		runtimeState = {
			attackerEntityId = attackerEntityId,
			targetEntityId = targetEntityId,
			lockedAt = tick(),
			player = player,
		}
	end
	runtimeState.targetEntityId = targetEntityId
	runtimeState.lockedAt = tick()
	locksByEntityId[attackerEntityId] = runtimeState
	if runtimeState.player ~= nil then
		lockedEntityByPlayer[runtimeState.player] = attackerEntityId
		sendLockState(runtimeState.player, attackerEntityId, targetEntityId, true, nil)
	end

	print(string.format("[P4_LOCK_ACQUIRED] attacker=%s target=%s", attackerEntityId, targetEntityId))
	return true
end

return TargetingServer
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="18">
        <Properties>
          <string name="Name">TestHarness</string>
        </Properties>
      </Item>
      <Item class="Folder" referent="19">
        <Properties>
          <string name="Name">Testing</string>
        </Properties>
        <Item class="Script" referent="20">
          <Properties>
            <string name="Name">MovingTargetController</string>
            <token name="RunContext">0</token>
            <string name="Source"><![CDATA[--!strict

local CollectionService = game:GetService("CollectionService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

if not RunService:IsStudio() then
	return
end

-- Enabled by default in Studio.
-- Optional global kill switch:
--   workspace:SetAttribute("MovingTargetControllerEnabled", false)
local didWarnControllerDisabled = false
local function isControllerEnabled(): boolean
	local enabled = Workspace:GetAttribute("MovingTargetControllerEnabled")
	if enabled == nil then
		Workspace:SetAttribute("MovingTargetControllerEnabled", true)
		enabled = true
	end

	if enabled == false then
		if not didWarnControllerDisabled then
			warn("[P4_MOVE] MovingTargetController disabled via workspace.MovingTargetControllerEnabled=false")
			didWarnControllerDisabled = true
		end
		return false
	end

	didWarnControllerDisabled = false
	return true
end

type TargetState = {
	baseCFrame: CFrame,
	lastRandomSwap: number,
	lastUpdateTime: number,
	currentOffset: Vector3,
	randomDirection: Vector3,
	travelSign: number,
	orbitAngle: number,
	activeMode: string,
}

local MODE_ATTR = "MovingTargetMode"
local ENABLED_ATTR = "MovingTargetEnabled"
local RESET_ATTR = "MovingTargetReset"
local SPEED_ATTR = "MovingTargetSpeed"
local AMPLITUDE_ATTR = "MovingTargetAmplitude"
local RADIUS_ATTR = "MovingTargetRadius"
local HEIGHT_ATTR = "MovingTargetHeight"
local INTERVAL_ATTR = "MovingTargetInterval"
local AXIS_ATTR = "MovingTargetAxis"

local MODE_SIDE = "side"
local MODE_CIRCLE = "circle"
local MODE_RANDOM = "random"

local DEFAULT_SPEED = 1.6
local DEFAULT_AMPLITUDE = 16
local DEFAULT_RADIUS = 18
local DEFAULT_HEIGHT = 10
local DEFAULT_INTERVAL = 2.2

local statesByModel: { [Model]: TargetState } = {}
local warnedInvalidModeByModel: { [Model]: boolean } = {}
local rng = Random.new()

local function readNumberAttribute(instance: Instance, name: string, defaultValue: number): number
	local raw = instance:GetAttribute(name)
	if type(raw) == "number" then
		return raw
	end
	if type(raw) == "string" then
		local parsed = tonumber(raw)
		if parsed ~= nil then
			return parsed
		end
	end
	return defaultValue
end

local function normalizeMode(raw: any): string
	if type(raw) ~= "string" then
		return MODE_SIDE
	end
	local normalized = string.lower(string.match(raw, "^%s*(.-)%s*$") or "")
	if normalized == MODE_SIDE or normalized == MODE_CIRCLE or normalized == MODE_RANDOM then
		return normalized
	end
	return ""
end

local function parseAxis(raw: any): Vector3
	if type(raw) ~= "string" then
		return Vector3.new(1, 0, 0)
	end

	local normalized = string.upper(string.match(raw, "^%s*(.-)%s*$") or "")
	if normalized == "X" then
		return Vector3.new(1, 0, 0)
	end
	if normalized == "Y" then
		return Vector3.new(0, 1, 0)
	end
	if normalized == "Z" then
		return Vector3.new(0, 0, 1)
	end
	if normalized == "-X" then
		return Vector3.new(-1, 0, 0)
	end
	if normalized == "-Y" then
		return Vector3.new(0, -1, 0)
	end
	if normalized == "-Z" then
		return Vector3.new(0, 0, -1)
	end

	local xRaw, yRaw, zRaw =
		string.match(normalized, "^([%+%-]?[%d%.]+)%s*,%s*([%+%-]?[%d%.]+)%s*,%s*([%+%-]?[%d%.]+)$")
	if xRaw ~= nil and yRaw ~= nil and zRaw ~= nil then
		local x = tonumber(xRaw)
		local y = tonumber(yRaw)
		local z = tonumber(zRaw)
		if x ~= nil and y ~= nil and z ~= nil then
			local vec = Vector3.new(x, y, z)
			if vec.Magnitude > 1e-4 then
				return vec.Unit
			end
		end
	end

	return Vector3.new(1, 0, 0)
end

local function randomUnitDirection(): Vector3
	for _ = 1, 8 do
		local x = rng:NextNumber(-1, 1)
		local y = rng:NextNumber(-1, 1)
		local z = rng:NextNumber(-1, 1)
		local vec = Vector3.new(x, y, z)
		if vec.Magnitude > 1e-4 then
			return vec.Unit
		end
	end
	return Vector3.new(1, 0, 0)
end

local function getOrCreateState(model: Model, now: number): TargetState
	local state = statesByModel[model]
	if state ~= nil then
		return state
	end

	state = {
		baseCFrame = model:GetPivot(),
		lastRandomSwap = now,
		lastUpdateTime = now,
		currentOffset = Vector3.zero,
		randomDirection = randomUnitDirection(),
		travelSign = if rng:NextNumber() >= 0.5 then 1 else -1,
		orbitAngle = rng:NextNumber(0, math.pi * 2),
		activeMode = "",
	}
	statesByModel[model] = state
	return state
end

local function resetState(model: Model, now: number)
	statesByModel[model] = {
		baseCFrame = model:GetPivot(),
		lastRandomSwap = now,
		lastUpdateTime = now,
		currentOffset = Vector3.zero,
		randomDirection = randomUnitDirection(),
		travelSign = if rng:NextNumber() >= 0.5 then 1 else -1,
		orbitAngle = rng:NextNumber(0, math.pi * 2),
		activeMode = "",
	}
	model:SetAttribute(RESET_ATTR, nil)
end

local function nextRandomTravelDirection(currentOffset: Vector3): Vector3
	local direction = randomUnitDirection()
	local toCenter = -currentOffset
	if toCenter.Magnitude > 1e-3 then
		direction = (direction * 0.45 + toCenter.Unit * 0.55).Unit
	end
	return direction
end

local function stepIntervalSwaps(state: TargetState, now: number, interval: number, onSwap: () -> ())
	local elapsed = now - state.lastRandomSwap
	if elapsed < interval then
		return
	end

	local swaps = math.floor(elapsed / interval)
	if swaps <= 0 then
		return
	end

	state.lastRandomSwap += swaps * interval
	for _ = 1, swaps do
		onSwap()
	end
end

local function getMotionOffset(model: Model, state: TargetState, now: number): Vector3?
	local mode = normalizeMode(model:GetAttribute(MODE_ATTR))
	if mode == "" then
		if not warnedInvalidModeByModel[model] then
			warn(string.format("[P4_MOVE] Invalid %s on %s", MODE_ATTR, model:GetFullName()))
			warnedInvalidModeByModel[model] = true
		end
		return nil
	end

	-- Interval is the time in seconds between direction changes for all modes.
	local interval = math.max(0.2, readNumberAttribute(model, INTERVAL_ATTR, DEFAULT_INTERVAL))
	if state.activeMode ~= mode then
		state.activeMode = mode
		state.lastRandomSwap = now
		state.lastUpdateTime = now
		state.currentOffset = Vector3.zero
		if mode == MODE_RANDOM then
			state.randomDirection = nextRandomTravelDirection(state.currentOffset)
		elseif mode == MODE_CIRCLE then
			state.orbitAngle = rng:NextNumber(0, math.pi * 2)
		end
	end

	local speed = math.max(0, readNumberAttribute(model, SPEED_ATTR, DEFAULT_SPEED))
	local dt = math.max(0, now - state.lastUpdateTime)
	state.lastUpdateTime = now

	if mode == MODE_SIDE then
		local axis = parseAxis(model:GetAttribute(AXIS_ATTR))
		stepIntervalSwaps(state, now, interval, function()
			state.travelSign *= -1
		end)

		if speed <= 0 or dt <= 0 then
			return state.currentOffset
		end

		state.currentOffset += axis * (state.travelSign * speed * dt)
		return state.currentOffset
	end

	if mode == MODE_CIRCLE then
		local radius = math.max(0, readNumberAttribute(model, RADIUS_ATTR, DEFAULT_RADIUS))
		local height = math.max(0, readNumberAttribute(model, HEIGHT_ATTR, DEFAULT_HEIGHT * 0.35))
		stepIntervalSwaps(state, now, interval, function()
			state.travelSign *= -1
		end)

		if speed <= 0 or dt <= 0 then
			return state.currentOffset
		end

		local flat = Vector2.new(state.currentOffset.X, state.currentOffset.Z)
		if flat.Magnitude < 1e-4 then
			flat = Vector2.new(if radius > 0 then radius else 1, 0)
		end

		local radial = flat.Unit
		local tangent = Vector2.new(-radial.Y, radial.X) * state.travelSign
		local nextFlat = flat + tangent * (speed * dt)
		if radius > 0 and nextFlat.Magnitude > 1e-4 then
			nextFlat = nextFlat.Unit * radius
		end

		local y = 0
		if height > 0 then
			state.orbitAngle += state.travelSign * speed * dt / math.max(radius, 1)
			y = math.sin(state.orbitAngle * 0.8) * height
		end

		state.currentOffset = Vector3.new(nextFlat.X, y, nextFlat.Y)
		return state.currentOffset
	end

	local radius = math.max(0, readNumberAttribute(model, RADIUS_ATTR, DEFAULT_RADIUS))
	local height = math.max(0, readNumberAttribute(model, HEIGHT_ATTR, DEFAULT_HEIGHT))
	stepIntervalSwaps(state, now, interval, function()
		state.randomDirection = nextRandomTravelDirection(state.currentOffset)
	end)

	if speed <= 0 or dt <= 0 then
		return state.currentOffset
	end

	local nextOffset = state.currentOffset + state.randomDirection * (speed * dt)

	if radius <= 0 then
		nextOffset = Vector3.new(0, nextOffset.Y, 0)
	else
		local horizontal = Vector2.new(nextOffset.X, nextOffset.Z)
		if horizontal.Magnitude > radius then
			local boundaryNormal2d = horizontal.Unit
			nextOffset = Vector3.new(boundaryNormal2d.X * radius, nextOffset.Y, boundaryNormal2d.Y * radius)
		end
	end

	if height <= 0 then
		nextOffset = Vector3.new(nextOffset.X, 0, nextOffset.Z)
	else
		if math.abs(nextOffset.Y) > height then
			nextOffset = Vector3.new(nextOffset.X, math.clamp(nextOffset.Y, -height, height), nextOffset.Z)
		end
	end

	state.currentOffset = nextOffset
	return state.currentOffset
end

local function applyMotion(model: Model, state: TargetState, offset: Vector3)
	local base = state.baseCFrame
	local baseRotation = base.Rotation
	local targetPosition = base.Position + offset
	model:PivotTo(CFrame.new(targetPosition) * baseRotation)
end

RunService.Heartbeat:Connect(function()
	if not isControllerEnabled() then
		table.clear(statesByModel)
		table.clear(warnedInvalidModeByModel)
		return
	end

	local now = tick()

	for _, tagged in ipairs(CollectionService:GetTagged("CombatEntity")) do
		if tagged:IsA("Model") then
			local model = tagged :: Model
			if model.Parent == nil then
				continue
			end
			if model:GetAttribute(ENABLED_ATTR) ~= true then
				continue
			end
			if model:GetAttribute("HullHP") ~= nil and model:GetAttribute("HullHP") == 0 then
				continue
			end

			if model:GetAttribute(RESET_ATTR) == true then
				resetState(model, now)
			end

			local state = getOrCreateState(model, now)
			local offset = getMotionOffset(model, state, now)
			if offset ~= nil then
				applyMotion(model, state, offset)
			end
		end
	end

	for model, _state in pairs(statesByModel) do
		if model.Parent == nil or model:GetAttribute(ENABLED_ATTR) ~= true then
			statesByModel[model] = nil
			warnedInvalidModeByModel[model] = nil
		end
	end
end)

print("[P4_MOVE] MovingTargetController enabled")
]]></string>
          </Properties>
        </Item>
      </Item>
      <Item class="Folder" referent="21">
        <Properties>
          <string name="Name">Weapons</string>
        </Properties>
        <Item class="ModuleScript" referent="22">
          <Properties>
            <string name="Name">WeaponServer</string>
            <string name="Source"><![CDATA[--!strict

local Players = game:GetService("Players")
local CollectionService = game:GetService("CollectionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local ServerScriptService = game:GetService("ServerScriptService")
local Workspace = game:GetService("Workspace")

local sharedRoot = ReplicatedStorage:WaitForChild("CombatFramework")
local CombatConfig = require(sharedRoot:WaitForChild("CombatConfig"))
local CombatTypes = require(sharedRoot:WaitForChild("CombatTypes"))
local WeaponRig = require(sharedRoot:WaitForChild("WeaponRig"))

local serverRoot = ServerScriptService:WaitForChild("CombatFramework")
local HealthManager = require(serverRoot:WaitForChild("Health"):WaitForChild("HealthManager"))
local ProjectileServer = require(serverRoot:WaitForChild("Projectiles"):WaitForChild("ProjectileServer"))
local TargetingServer = require(serverRoot:WaitForChild("Targeting"):WaitForChild("TargetingServer"))

type HealthState = CombatTypes.HealthState
type LockState = CombatTypes.LockState
type ProjectileData = CombatTypes.ProjectileData
type WeaponConfig = CombatTypes.WeaponConfig

type WeaponHeatState = {
	heat: number,
	lastUpdatedAt: number,
	lastShotAt: number,
	overheated: boolean,
	recoverCueId: number,
	recoverToken: number,
}

type AmmoState = {
	current: number,
	max: number,
}

type FireNode = {
	mount: BasePart,
	muzzleLocalOffset: Vector3,
}

type FireNodeState = {
	nodes: { FireNode },
	nextIndex: number,
}

type RigOverride = {
	mode: string?,
	minYawDeg: number?,
	maxYawDeg: number?,
	minPitchDeg: number?,
	maxPitchDeg: number?,
	pivotName: string?,
	pivotAttachment: Attachment?,
}

type DrivenPartState = {
	part: BasePart,
	neutralAimFrame: CFrame,
	clampOverride: RigOverride?,
}

type DrivenRigState = {
	mount: BasePart,
	mountNeutralAimFrame: CFrame,
	drivenParts: { DrivenPartState },
}

local WeaponServer = {}

local remotesFolder: Folder? = nil
local fireWeaponRemote: RemoteEvent? = nil
local updateTurretAimRemote: RemoteEvent? = nil
local fireConnection: RBXScriptConnection? = nil
local aimUpdateConnection: RBXScriptConnection? = nil
local playerRemovingConnection: RBXScriptConnection? = nil

local lastFireTimeByPlayer: { [Player]: number } = {}
local lastAimUpdateByPlayer: { [Player]: number } = {}
local heatStateByEntityId: { [string]: WeaponHeatState } = {}
local ammoStateByEntityId: { [string]: AmmoState } = {}
local fireNodeStateByEntityId: { [string]: FireNodeState } = {}
local drivenRigStateByEntityId: { [string]: DrivenRigState } = {}
local warnedUnknownWeaponClass: { [string]: boolean } = {}
local projectileCounter = 0

local DEFAULT_HEAT_MAX = 100
local DEFAULT_HEAT_PER_SHOT = 15
local DEFAULT_HEAT_DECAY_PER_SECOND = 8
local DEFAULT_HEAT_RECOVER_FRACTION = 0.5
local CADENCE_RAPID_BONUS_MAX = 0.45
local CADENCE_SLOW_DISCOUNT_MAX = 0.25
local CADENCE_SLOW_DISCOUNT_WINDOW = 2
local DEFAULT_WEAPON_CLASS = "projectile"
local DEFAULT_BURST_COUNT = 3
local DEFAULT_BURST_INTERVAL = 0.08
local AIM_UPDATE_INTERVAL = 1 / 30

local ATTR_WEAPON_CLASS = "WeaponClass"
local ATTR_DAMAGE_TYPE = "WeaponDamageType"
local ATTR_BOLT_COLOR = "WeaponBoltColor"
local ATTR_SPLASH_ENABLED = "WeaponSplashEnabled"
local ATTR_SPLASH_RADIUS = "WeaponSplashRadius"
local ATTR_DAMAGE_MODIFIER = "WeaponDamageModifier"
local ATTR_DAMAGE_PERCENT = "WeaponDamagePercent"
local ATTR_FIRE_RATE_MODIFIER = "WeaponFireRateModifier"
local ATTR_PROJECTILE_SPEED_MODIFIER = "WeaponProjectileSpeedModifier"
local ATTR_MAX_RANGE_MODIFIER = "WeaponMaxRangeModifier"
local ATTR_BURST_COUNT_MODIFIER = "WeaponBurstCountModifier"
local ATTR_BURST_INTERVAL_MODIFIER = "WeaponBurstIntervalModifier"
local ATTR_HEAT_MAX_MODIFIER = "WeaponHeatMaxModifier"
local ATTR_HEAT_PER_SHOT_MODIFIER = "WeaponHeatPerShotModifier"
local ATTR_HEAT_DECAY_MODIFIER = "WeaponHeatDecayPerSecondModifier"
local ATTR_HEAT_RECOVER_THRESHOLD_MODIFIER = "WeaponHeatRecoverThresholdModifier"

local EFFECTIVE_WEAPON_CLASS = "EffectiveWeaponClass"
local EFFECTIVE_DAMAGE_TYPE = "EffectiveWeaponDamageType"
local EFFECTIVE_DAMAGE = "EffectiveWeaponDamage"
local EFFECTIVE_FIRE_RATE = "EffectiveWeaponFireRate"
local EFFECTIVE_PROJECTILE_SPEED = "EffectiveWeaponProjectileSpeed"
local EFFECTIVE_MAX_RANGE = "EffectiveWeaponMaxRange"
local EFFECTIVE_LOCK_RANGE = "EffectiveWeaponLockRange"
local EFFECTIVE_UNLOCKED_SPREAD = "EffectiveWeaponUnlockedSpread"
local EFFECTIVE_AUTO_AIM_SPREAD = "EffectiveWeaponAutoAimSpread"
local EFFECTIVE_REQUIRES_LOCK = "WeaponRequiresLock"
local EFFECTIVE_HOMING_TURN_RATE = "EffectiveWeaponHomingTurnRate"
local EFFECTIVE_BOLT_COLOR = "EffectiveWeaponBoltColor"
local EFFECTIVE_SPLASH_ENABLED = "EffectiveWeaponSplashEnabled"
local EFFECTIVE_SPLASH_RADIUS = "EffectiveWeaponSplashRadius"
local EFFECTIVE_BURST_COUNT = "EffectiveWeaponBurstCount"
local EFFECTIVE_BURST_INTERVAL = "EffectiveWeaponBurstInterval"
local EFFECTIVE_HEAT_MAX = "EffectiveWeaponHeatMax"
local EFFECTIVE_HEAT_PER_SHOT = "EffectiveWeaponHeatPerShot"
local EFFECTIVE_HEAT_DECAY = "EffectiveWeaponHeatDecayPerSecond"
local EFFECTIVE_HEAT_RECOVER_THRESHOLD = "EffectiveWeaponHeatRecoverThreshold"

local function findTaggedDescendants(model: Model, tagName: string, className: string?): { Instance }
	local tagged: { Instance } = {}
	for _, descendant in ipairs(model:GetDescendants()) do
		if CollectionService:HasTag(descendant, tagName) then
			if className == nil or descendant:IsA(className) then
				table.insert(tagged, descendant)
			end
		end
	end

	table.sort(tagged, function(a: Instance, b: Instance)
		return a:GetFullName() < b:GetFullName()
	end)

	return tagged
end

local function getFireRemote(): RemoteEvent
	if fireWeaponRemote == nil then
		error("WeaponServer not initialized with remotes")
	end
	return fireWeaponRemote
end

local function getAimUpdateRemote(): RemoteEvent
	if updateTurretAimRemote == nil then
		error("WeaponServer not initialized with aim update remote")
	end
	return updateTurretAimRemote
end

local function isMuzzleAttachment(candidate: Instance): boolean
	if not candidate:IsA("Attachment") then
		return false
	end

	if CollectionService:HasTag(candidate, "MuzzlePoint") then
		return true
	end

	return candidate.Name == "MuzzlePoint" or string.sub(candidate.Name, 1, 11) == "MuzzlePoint"
end

local function getMuzzleLocalOffsets(weaponMount: BasePart): { Vector3 }
	local offsets: { Vector3 } = {}
	local muzzleAttachments: { Attachment } = {}
	for _, descendant in ipairs(weaponMount:GetDescendants()) do
		if isMuzzleAttachment(descendant) then
			table.insert(muzzleAttachments, descendant :: Attachment)
		end
	end

	table.sort(muzzleAttachments, function(a: Attachment, b: Attachment)
		return a:GetFullName() < b:GetFullName()
	end)

	for _, attachment in ipairs(muzzleAttachments) do
		table.insert(offsets, weaponMount.CFrame:PointToObjectSpace(attachment.WorldPosition))
	end

	if #offsets == 0 then
		-- Fallback: front face of the weapon mount.
		table.insert(offsets, Vector3.new(0, 0, -weaponMount.Size.Z * 0.5))
	end

	return offsets
end

local function collectFireNodes(entityModel: Model): { FireNode }
	local nodes: { FireNode } = {}
	local mounts = findTaggedDescendants(entityModel, "WeaponMount", "BasePart")
	for _, mountInstance in ipairs(mounts) do
		local mount = mountInstance :: BasePart
		for _, offset in ipairs(getMuzzleLocalOffsets(mount)) do
			table.insert(nodes, {
				mount = mount,
				muzzleLocalOffset = offset,
			})
		end
	end
	return nodes
end

local function getOrRefreshFireNodeState(entityId: string, entityModel: Model): FireNodeState?
	local state = fireNodeStateByEntityId[entityId]
	local needsRebuild = state == nil or #state.nodes == 0

	if not needsRebuild then
		for _, node in ipairs(state.nodes) do
			if node.mount.Parent == nil or not node.mount:IsDescendantOf(entityModel) then
				needsRebuild = true
				break
			end
		end
	end

	if needsRebuild then
		local nodes = collectFireNodes(entityModel)
		if #nodes == 0 then
			fireNodeStateByEntityId[entityId] = nil
			return nil
		end
		state = {
			nodes = nodes,
			nextIndex = 1,
		}
		fireNodeStateByEntityId[entityId] = state
	end

	return state
end

local function getNextFireNode(entityId: string, entityModel: Model): FireNode?
	local state = getOrRefreshFireNodeState(entityId, entityModel)
	if state == nil then
		return nil
	end

	local count = #state.nodes
	if count == 0 then
		return nil
	end

	local index = math.clamp(state.nextIndex, 1, count)
	local node = state.nodes[index]
	state.nextIndex = if index >= count then 1 else index + 1
	return node
end

local function setFireNodeAttributes(entityModel: Model, entityId: string)
	local state = fireNodeStateByEntityId[entityId]
	if state == nil then
		entityModel:SetAttribute("WeaponMountCount", 0)
		entityModel:SetAttribute("WeaponMuzzleCount", 0)
		return
	end

	local uniqueMounts: { [BasePart]: boolean } = {}
	for _, node in ipairs(state.nodes) do
		uniqueMounts[node.mount] = true
	end

	local mountCount = 0
	for _ in pairs(uniqueMounts) do
		mountCount += 1
	end

	entityModel:SetAttribute("WeaponMountCount", mountCount)
	entityModel:SetAttribute("WeaponMuzzleCount", #state.nodes)
end

local function getHeatParams(weaponConfig: WeaponConfig): (number, number, number, number)
	if type(weaponConfig.heatMax) ~= "number" or weaponConfig.heatMax <= 0 then
		return 0, 0, 0, 0
	end

	local heatMax = weaponConfig.heatMax

	local heatPerShot = DEFAULT_HEAT_PER_SHOT
	if type(weaponConfig.heatPerShot) == "number" and weaponConfig.heatPerShot >= 0 then
		heatPerShot = weaponConfig.heatPerShot
	end

	local heatDecayPerSecond = DEFAULT_HEAT_DECAY_PER_SECOND
	if type(weaponConfig.heatDecayPerSecond) == "number" and weaponConfig.heatDecayPerSecond >= 0 then
		heatDecayPerSecond = weaponConfig.heatDecayPerSecond
	end

	local heatRecoverThreshold = heatMax * DEFAULT_HEAT_RECOVER_FRACTION
	if type(weaponConfig.heatRecoverThreshold) == "number" then
		heatRecoverThreshold = weaponConfig.heatRecoverThreshold
	end
	heatRecoverThreshold = math.clamp(heatRecoverThreshold, 0, heatMax)

	return heatMax, heatPerShot, heatDecayPerSecond, heatRecoverThreshold
end

local function getAmmoCapacity(weaponConfig: WeaponConfig): number
	if type(weaponConfig.ammoCapacity) ~= "number" then
		return 0
	end
	return math.max(0, math.floor(weaponConfig.ammoCapacity + 0.5))
end

local function getOrCreateHeatState(entityId: string, nowServer: number): WeaponHeatState
	local existing = heatStateByEntityId[entityId]
	if existing ~= nil then
		return existing
	end

	local state: WeaponHeatState = {
		heat = 0,
		lastUpdatedAt = nowServer,
		lastShotAt = 0,
		overheated = false,
		recoverCueId = 0,
		recoverToken = 0,
	}
	heatStateByEntityId[entityId] = state
	return state
end

local function setAmmoAttributes(entityModel: Model, ammoState: AmmoState?)
	if ammoState == nil then
		entityModel:SetAttribute("WeaponAmmo", nil)
		entityModel:SetAttribute("WeaponAmmoMax", nil)
		return
	end

	entityModel:SetAttribute("WeaponAmmo", ammoState.current)
	entityModel:SetAttribute("WeaponAmmoMax", ammoState.max)
end

local function coolHeatState(state: WeaponHeatState, nowServer: number, heatDecayPerSecond: number, heatMax: number)
	local elapsed = math.max(0, nowServer - state.lastUpdatedAt)
	if elapsed > 0 and heatDecayPerSecond > 0 and heatMax > 0 then
		-- Exponential cooling feels more physical than fixed linear drain.
		local coolingRate = heatDecayPerSecond / heatMax
		state.heat = math.clamp(state.heat * math.exp(-coolingRate * elapsed), 0, heatMax)
	end
	state.lastUpdatedAt = nowServer
end

local function computeShotHeat(
	baseHeatPerShot: number,
	cooldown: number,
	nowServer: number,
	lastShotAt: number
): number
	if cooldown <= 0 or lastShotAt <= 0 then
		return baseHeatPerShot
	end

	local timeSinceShot = math.max(0, nowServer - lastShotAt)
	local cadenceRatio = timeSinceShot / cooldown
	local multiplier = 1

	if cadenceRatio < 1 then
		multiplier = 1 + (1 - cadenceRatio) * CADENCE_RAPID_BONUS_MAX
	elseif cadenceRatio > 1 then
		local slowNormalized = math.clamp((cadenceRatio - 1) / (CADENCE_SLOW_DISCOUNT_WINDOW - 1), 0, 1)
		multiplier = 1 - slowNormalized * CADENCE_SLOW_DISCOUNT_MAX
	end

	return baseHeatPerShot * multiplier
end

local function getWeaponClass(weaponConfig: WeaponConfig): string
	if type(weaponConfig.weaponClass) == "string" and weaponConfig.weaponClass ~= "" then
		return string.lower(weaponConfig.weaponClass)
	end
	return DEFAULT_WEAPON_CLASS
end

local function getBurstParams(weaponConfig: WeaponConfig): (number, number)
	local burstCount = DEFAULT_BURST_COUNT
	if type(weaponConfig.burstCount) == "number" then
		burstCount = math.max(1, math.floor(weaponConfig.burstCount + 0.5))
	end

	local burstInterval = DEFAULT_BURST_INTERVAL
	if type(weaponConfig.burstInterval) == "number" then
		burstInterval = math.max(0, weaponConfig.burstInterval)
	end

	return burstCount, burstInterval
end

local function parseColor3String(raw: string): Color3?
	local rRaw, gRaw, bRaw = string.match(raw, "^%s*([%+%-]?[%d%.]+)%s*,%s*([%+%-]?[%d%.]+)%s*,%s*([%+%-]?[%d%.]+)%s*$")
	if rRaw == nil or gRaw == nil or bRaw == nil then
		return nil
	end

	local r = tonumber(rRaw)
	local g = tonumber(gRaw)
	local b = tonumber(bRaw)
	if r == nil or g == nil or b == nil then
		return nil
	end

	if r <= 1 and g <= 1 and b <= 1 and r >= 0 and g >= 0 and b >= 0 then
		return Color3.new(r, g, b)
	end

	return Color3.fromRGB(math.clamp(math.floor(r + 0.5), 0, 255), math.clamp(math.floor(g + 0.5), 0, 255), math.clamp(math.floor(b + 0.5), 0, 255))
end

local function readNumberAttribute(instance: Instance, name: string): number?
	local raw = instance:GetAttribute(name)
	if type(raw) == "number" then
		return raw
	end
	if type(raw) == "string" then
		return tonumber(raw)
	end
	return nil
end

local function readBoolAttribute(instance: Instance, name: string): boolean?
	local raw = instance:GetAttribute(name)
	if type(raw) == "boolean" then
		return raw
	end
	if type(raw) == "number" then
		return raw ~= 0
	end
	if type(raw) == "string" then
		local normalized = string.lower(string.match(raw, "^%s*(.-)%s*$") or "")
		if normalized == "true" or normalized == "1" or normalized == "yes" or normalized == "on" then
			return true
		end
		if normalized == "false" or normalized == "0" or normalized == "no" or normalized == "off" then
			return false
		end
	end
	return nil
end

local function modeFromFolderName(folderName: string): string?
	local normalized = string.lower(string.gsub(folderName, "[%s_%-]", ""))
	if normalized == "yawonly" or normalized == "yawonlyparts" or normalized == "drivenyawonly" then
		return "yawonly"
	end
	if normalized == "pitchonly" or normalized == "pitchonlyparts" or normalized == "drivenpitchonly" then
		return "pitchonly"
	end
	if normalized == "yawpitch" or normalized == "yawpitchparts" or normalized == "drivenyawpitch" then
		return "yawpitch"
	end
	return nil
end

local function getClampOverride(folder: Instance, modeFromName: string?): RigOverride?
	local modeFromAttr = folder:GetAttribute("AimMode")
	local mode: string? = modeFromName
	if type(modeFromAttr) == "string" and modeFromAttr ~= "" then
		mode = modeFromAttr
	end

	local minYawDeg = readNumberAttribute(folder, "MinYawDeg")
	local maxYawDeg = readNumberAttribute(folder, "MaxYawDeg")
	local minPitchDeg = readNumberAttribute(folder, "MinPitchDeg")
	local maxPitchDeg = readNumberAttribute(folder, "MaxPitchDeg")

	local pivotName: string? = nil
	local pivotNameRaw = folder:GetAttribute("AimPivotName")
	if type(pivotNameRaw) == "string" and string.match(pivotNameRaw, "%S") ~= nil then
		pivotName = pivotNameRaw
	end

	local pivotAttachment: Attachment? = nil
	for _, child in ipairs(folder:GetChildren()) do
		if child:IsA("ObjectValue") and child.Value ~= nil and child.Value:IsA("Attachment") then
			local attachedValue = child.Value :: Attachment
			if child.Name == "AimPivotAttachment" or child.Name == "PivotAttachment" then
				pivotAttachment = attachedValue
				break
			end
			if pivotAttachment == nil then
				pivotAttachment = attachedValue
			end
		end
	end

	if
		mode == nil
		and minYawDeg == nil
		and maxYawDeg == nil
		and minPitchDeg == nil
		and maxPitchDeg == nil
		and pivotName == nil
		and pivotAttachment == nil
	then
		return nil
	end

	return {
		mode = mode,
		minYawDeg = minYawDeg,
		maxYawDeg = maxYawDeg,
		minPitchDeg = minPitchDeg,
		maxPitchDeg = maxPitchDeg,
		pivotName = pivotName,
		pivotAttachment = pivotAttachment,
	}
end

local function addDrivenPart(
	part: BasePart,
	seen: { [BasePart]: boolean },
	mount: BasePart,
	drivenParts: { DrivenPartState },
	clampOverride: RigOverride?
)
	if part == mount or seen[part] then
		return
	end

	seen[part] = true
	table.insert(drivenParts, {
		part = part,
		neutralAimFrame = WeaponRig.getNeutralAimFrame(part),
		clampOverride = clampOverride,
	})
end

local function collectDrivenPartsFromContainer(
	container: Instance,
	seen: { [BasePart]: boolean },
	mount: BasePart,
	drivenParts: { DrivenPartState },
	clampOverride: RigOverride?
)
	for _, descendant in ipairs(container:GetDescendants()) do
		if descendant:IsA("BasePart") then
			addDrivenPart(descendant, seen, mount, drivenParts, clampOverride)
		elseif descendant:IsA("ObjectValue") and descendant.Value ~= nil and descendant.Value:IsA("BasePart") then
			addDrivenPart(descendant.Value, seen, mount, drivenParts, clampOverride)
		end
	end
end

local function collectDrivenRigState(entityModel: Model): DrivenRigState?
	local mountCandidates = findTaggedDescendants(entityModel, "WeaponMount", "BasePart")
	local mountInstance = mountCandidates[1]
	if mountInstance == nil then
		return nil
	end

	local mount = mountInstance :: BasePart
	local drivenParts: { DrivenPartState } = {}
	local seen: { [BasePart]: boolean } = { [mount] = true }

	local rigFolder = entityModel:FindFirstChild("TurretRig")
	if rigFolder ~= nil then
		local drivenPartsFolder = rigFolder:FindFirstChild("DrivenParts")
		if drivenPartsFolder ~= nil then
			local clampOverride = getClampOverride(drivenPartsFolder, nil)
			collectDrivenPartsFromContainer(drivenPartsFolder, seen, mount, drivenParts, clampOverride)
		end

		for _, child in ipairs(rigFolder:GetChildren()) do
			if child:IsA("Folder") and child.Name ~= "DrivenParts" then
				local modeOverride = modeFromFolderName(child.Name)
				local clampOverride = getClampOverride(child, modeOverride)
				if modeOverride ~= nil or clampOverride ~= nil then
					collectDrivenPartsFromContainer(child, seen, mount, drivenParts, clampOverride)
				end
			end
		end
	end

	return {
		mount = mount,
		mountNeutralAimFrame = WeaponRig.getNeutralAimFrame(mount),
		drivenParts = drivenParts,
	}
end

local function getOrRefreshDrivenRigState(entityId: string, entityModel: Model): DrivenRigState?
	local state = drivenRigStateByEntityId[entityId]
	local needsRebuild = state == nil

	if not needsRebuild then
		if state.mount.Parent == nil or not state.mount:IsDescendantOf(entityModel) then
			needsRebuild = true
		else
			for _, driven in ipairs(state.drivenParts) do
				if driven.part.Parent == nil then
					needsRebuild = true
					break
				end
			end
		end
	end

	if needsRebuild then
		state = collectDrivenRigState(entityModel)
		drivenRigStateByEntityId[entityId] = state
	end

	return state
end

local function applyAimToRig(entityId: string, entityModel: Model, desiredDirection: Vector3): Vector3?
	if desiredDirection.Magnitude < 1e-4 then
		return nil
	end

	local drivenState = getOrRefreshDrivenRigState(entityId, entityModel)
	if drivenState == nil then
		return nil
	end

	local mount = drivenState.mount
	local clampedDirection =
		WeaponRig.clampDirectionToMountLimits(mount, drivenState.mountNeutralAimFrame, desiredDirection.Unit)
	if clampedDirection.Magnitude <= 1e-4 then
		return nil
	end

	mount.CFrame = WeaponRig.getAimFrame(mount, clampedDirection)

	for index = #drivenState.drivenParts, 1, -1 do
		local driven = drivenState.drivenParts[index]
		if driven.part.Parent == nil then
			table.remove(drivenState.drivenParts, index)
		else
			local drivenDirection = WeaponRig.clampDirectionToMountLimits(
				driven.part,
				driven.neutralAimFrame,
				clampedDirection,
				driven.clampOverride
			)
			if drivenDirection.Magnitude > 1e-4 then
				driven.part.CFrame = WeaponRig.getAimFrame(driven.part, drivenDirection, driven.clampOverride)
			end
		end
	end

	return clampedDirection
end

local function readColorAttribute(instance: Instance, name: string): Color3?
	local raw = instance:GetAttribute(name)
	if typeof(raw) == "Color3" then
		return raw :: Color3
	end
	if typeof(raw) == "BrickColor" then
		return (raw :: BrickColor).Color
	end
	if type(raw) == "string" then
		return parseColor3String(raw)
	end
	return nil
end

local function applyPercentModifier(baseValue: number, modifier: number?, minValue: number?): number
	local adjusted = baseValue
	if modifier ~= nil then
		adjusted = baseValue * (1 + modifier)
	end
	if minValue ~= nil then
		adjusted = math.max(minValue, adjusted)
	end
	return adjusted
end

local function applyDirectionalSpread(direction: Vector3, spreadDegrees: number): Vector3
	if direction.Magnitude < 1e-4 then
		return Vector3.new(0, 0, -1)
	end
	if spreadDegrees <= 0 then
		return direction.Unit
	end

	local spreadRadians = math.rad(spreadDegrees)
	local yaw = (math.random() * 2 - 1) * spreadRadians
	local pitch = (math.random() * 2 - 1) * spreadRadians
	local lookFrame = CFrame.lookAt(Vector3.zero, direction.Unit)
	return (lookFrame * CFrame.Angles(pitch, yaw, 0)).LookVector.Unit
end

local function resolveWeaponConfig(entityModel: Model, baseWeaponConfig: WeaponConfig): WeaponConfig
	local resolved: WeaponConfig = {
		weaponClass = baseWeaponConfig.weaponClass,
		damageType = baseWeaponConfig.damageType,
		damage = baseWeaponConfig.damage,
		fireRate = baseWeaponConfig.fireRate,
		projectileSpeed = baseWeaponConfig.projectileSpeed,
		maxRange = baseWeaponConfig.maxRange,
		lockRange = baseWeaponConfig.lockRange,
		unlockedSpread = baseWeaponConfig.unlockedSpread,
		autoAimSpread = baseWeaponConfig.autoAimSpread,
		requiresLock = baseWeaponConfig.requiresLock,
		homingTurnRate = baseWeaponConfig.homingTurnRate,
		boltColor = baseWeaponConfig.boltColor,
		splashRadius = baseWeaponConfig.splashRadius,
		burstCount = baseWeaponConfig.burstCount,
		burstInterval = baseWeaponConfig.burstInterval,
		heatMax = baseWeaponConfig.heatMax,
		heatPerShot = baseWeaponConfig.heatPerShot,
		heatDecayPerSecond = baseWeaponConfig.heatDecayPerSecond,
		heatRecoverThreshold = baseWeaponConfig.heatRecoverThreshold,
		ammoCapacity = baseWeaponConfig.ammoCapacity,
	}

	local weaponClassOverride = entityModel:GetAttribute(ATTR_WEAPON_CLASS)
	if type(weaponClassOverride) == "string" and weaponClassOverride ~= "" then
		resolved.weaponClass = string.lower(weaponClassOverride)
	end

	local damageTypeOverride = entityModel:GetAttribute(ATTR_DAMAGE_TYPE)
	if type(damageTypeOverride) == "string" and damageTypeOverride ~= "" then
		resolved.damageType = damageTypeOverride
	end

	local damageModifier = readNumberAttribute(entityModel, ATTR_DAMAGE_MODIFIER)
	if damageModifier == nil then
		damageModifier = readNumberAttribute(entityModel, ATTR_DAMAGE_PERCENT)
	end
	resolved.damage = applyPercentModifier(resolved.damage, damageModifier, 0)

	local fireRateModifier = readNumberAttribute(entityModel, ATTR_FIRE_RATE_MODIFIER)
	resolved.fireRate = applyPercentModifier(resolved.fireRate, fireRateModifier, 0.01)

	local projectileSpeedModifier = readNumberAttribute(entityModel, ATTR_PROJECTILE_SPEED_MODIFIER)
	resolved.projectileSpeed = applyPercentModifier(resolved.projectileSpeed, projectileSpeedModifier, 0.01)

	local maxRangeModifier = readNumberAttribute(entityModel, ATTR_MAX_RANGE_MODIFIER)
	resolved.maxRange = applyPercentModifier(resolved.maxRange, maxRangeModifier, 1)
	if type(resolved.lockRange) == "number" then
		resolved.lockRange = applyPercentModifier(resolved.lockRange, maxRangeModifier, 1)
		if resolved.lockRange >= resolved.maxRange then
			resolved.lockRange = math.max(0, resolved.maxRange - 1)
		end
	end

	local splashRadiusOverride = readNumberAttribute(entityModel, ATTR_SPLASH_RADIUS)
	if splashRadiusOverride ~= nil then
		resolved.splashRadius = math.max(0, splashRadiusOverride)
	elseif resolved.splashRadius == nil then
		resolved.splashRadius = 0
	end
	local splashEnabledOverride = readBoolAttribute(entityModel, ATTR_SPLASH_ENABLED)
	local splashEnabled = (baseWeaponConfig.splashRadius or 0) > 0
	if splashEnabledOverride ~= nil then
		splashEnabled = splashEnabledOverride
	end
	if not splashEnabled then
		resolved.splashRadius = 0
	end

	local baseBurstCount = if type(resolved.burstCount) == "number" then resolved.burstCount else DEFAULT_BURST_COUNT
	local burstCountModifier = readNumberAttribute(entityModel, ATTR_BURST_COUNT_MODIFIER)
	local scaledBurstCount = applyPercentModifier(baseBurstCount, burstCountModifier, 1)
	resolved.burstCount = math.max(1, math.floor(scaledBurstCount + 0.5))

	local baseBurstInterval = if type(resolved.burstInterval) == "number" then resolved.burstInterval else DEFAULT_BURST_INTERVAL
	local burstIntervalModifier = readNumberAttribute(entityModel, ATTR_BURST_INTERVAL_MODIFIER)
	resolved.burstInterval = applyPercentModifier(baseBurstInterval, burstIntervalModifier, 0)

	local baseHeatMax = if type(resolved.heatMax) == "number" and resolved.heatMax > 0 then resolved.heatMax else DEFAULT_HEAT_MAX
	local heatMaxModifier = readNumberAttribute(entityModel, ATTR_HEAT_MAX_MODIFIER)
	resolved.heatMax = applyPercentModifier(baseHeatMax, heatMaxModifier, 0.01)

	local baseHeatPerShot = if type(resolved.heatPerShot) == "number" and resolved.heatPerShot >= 0 then resolved.heatPerShot else DEFAULT_HEAT_PER_SHOT
	local heatPerShotModifier = readNumberAttribute(entityModel, ATTR_HEAT_PER_SHOT_MODIFIER)
	resolved.heatPerShot = applyPercentModifier(baseHeatPerShot, heatPerShotModifier, 0)

	local baseHeatDecay = if type(resolved.heatDecayPerSecond) == "number" and resolved.heatDecayPerSecond >= 0
		then resolved.heatDecayPerSecond
		else DEFAULT_HEAT_DECAY_PER_SECOND
	local heatDecayModifier = readNumberAttribute(entityModel, ATTR_HEAT_DECAY_MODIFIER)
	resolved.heatDecayPerSecond = applyPercentModifier(baseHeatDecay, heatDecayModifier, 0)

	local baseHeatRecoverThreshold = if type(resolved.heatRecoverThreshold) == "number"
		then resolved.heatRecoverThreshold
		else (resolved.heatMax :: number) * DEFAULT_HEAT_RECOVER_FRACTION
	local heatRecoverThresholdModifier = readNumberAttribute(entityModel, ATTR_HEAT_RECOVER_THRESHOLD_MODIFIER)
	resolved.heatRecoverThreshold = applyPercentModifier(baseHeatRecoverThreshold, heatRecoverThresholdModifier, 0)

	local boltColorOverride = readColorAttribute(entityModel, ATTR_BOLT_COLOR)
	if boltColorOverride ~= nil then
		resolved.boltColor = boltColorOverride
	end

	return resolved
end

local function publishResolvedWeaponAttributes(entityModel: Model, weaponConfig: WeaponConfig)
	entityModel:SetAttribute(EFFECTIVE_WEAPON_CLASS, weaponConfig.weaponClass or DEFAULT_WEAPON_CLASS)
	entityModel:SetAttribute(EFFECTIVE_DAMAGE_TYPE, weaponConfig.damageType)
	entityModel:SetAttribute(EFFECTIVE_DAMAGE, weaponConfig.damage)
	entityModel:SetAttribute(EFFECTIVE_FIRE_RATE, weaponConfig.fireRate)
	entityModel:SetAttribute(EFFECTIVE_PROJECTILE_SPEED, weaponConfig.projectileSpeed)
	entityModel:SetAttribute(EFFECTIVE_MAX_RANGE, weaponConfig.maxRange)
	entityModel:SetAttribute(EFFECTIVE_LOCK_RANGE, weaponConfig.lockRange)
	entityModel:SetAttribute(EFFECTIVE_UNLOCKED_SPREAD, weaponConfig.unlockedSpread)
	entityModel:SetAttribute(EFFECTIVE_AUTO_AIM_SPREAD, weaponConfig.autoAimSpread)
	entityModel:SetAttribute(EFFECTIVE_REQUIRES_LOCK, weaponConfig.requiresLock == true)
	entityModel:SetAttribute(EFFECTIVE_HOMING_TURN_RATE, weaponConfig.homingTurnRate)
	entityModel:SetAttribute(EFFECTIVE_SPLASH_ENABLED, (weaponConfig.splashRadius or 0) > 0)
	entityModel:SetAttribute(EFFECTIVE_SPLASH_RADIUS, weaponConfig.splashRadius)
	entityModel:SetAttribute(EFFECTIVE_BURST_COUNT, weaponConfig.burstCount)
	entityModel:SetAttribute(EFFECTIVE_BURST_INTERVAL, weaponConfig.burstInterval)
	entityModel:SetAttribute(EFFECTIVE_HEAT_MAX, weaponConfig.heatMax)
	entityModel:SetAttribute(EFFECTIVE_HEAT_PER_SHOT, weaponConfig.heatPerShot)
	entityModel:SetAttribute(EFFECTIVE_HEAT_DECAY, weaponConfig.heatDecayPerSecond)
	entityModel:SetAttribute(EFFECTIVE_HEAT_RECOVER_THRESHOLD, weaponConfig.heatRecoverThreshold)
	if weaponConfig.boltColor ~= nil then
		entityModel:SetAttribute(EFFECTIVE_BOLT_COLOR, weaponConfig.boltColor)
	else
		entityModel:SetAttribute(EFFECTIVE_BOLT_COLOR, nil)
	end
end

local function setHeatAttributes(
	entityModel: Model,
	state: WeaponHeatState,
	heatMax: number,
	heatDecayPerSecond: number,
	heatRecoverThreshold: number
)
	if heatMax <= 0 then
		entityModel:SetAttribute("WeaponHeat", nil)
		entityModel:SetAttribute("WeaponHeatMax", nil)
		entityModel:SetAttribute("WeaponHeatDecayPerSecond", nil)
		entityModel:SetAttribute("WeaponHeatRecoverThreshold", nil)
		entityModel:SetAttribute("WeaponOverheated", false)
		entityModel:SetAttribute("WeaponHeatUpdatedAt", nil)
		entityModel:SetAttribute("WeaponHeatRecoverCueId", nil)
		return
	end

	entityModel:SetAttribute("WeaponHeat", state.heat)
	entityModel:SetAttribute("WeaponHeatMax", heatMax)
	entityModel:SetAttribute("WeaponHeatDecayPerSecond", heatDecayPerSecond)
	entityModel:SetAttribute("WeaponHeatRecoverThreshold", heatRecoverThreshold)
	entityModel:SetAttribute("WeaponOverheated", state.overheated)
	entityModel:SetAttribute("WeaponHeatUpdatedAt", state.lastUpdatedAt)
	entityModel:SetAttribute("WeaponHeatRecoverCueId", state.recoverCueId)
end

local function scheduleRecoveryCue(entityId: string, weaponConfig: WeaponConfig)
	local state = heatStateByEntityId[entityId]
	if state == nil or not state.overheated then
		return
	end

	local heatMax, _, heatDecayPerSecond, heatRecoverThreshold = getHeatParams(weaponConfig)
	if heatDecayPerSecond <= 0 then
		return
	end

	state.recoverToken += 1
	local token = state.recoverToken
	local recoverDelay = 0
	local recoverThreshold = math.max(0.001, heatRecoverThreshold)
	if state.heat > recoverThreshold and heatMax > 0 then
		local coolingRate = heatDecayPerSecond / heatMax
		if coolingRate > 0 then
			recoverDelay = math.log(state.heat / recoverThreshold) / coolingRate
		end
	end

	task.delay(recoverDelay + 0.02, function()
		local liveState = heatStateByEntityId[entityId]
		if liveState == nil or liveState.recoverToken ~= token then
			return
		end

		local healthState = HealthManager.getHealth(entityId)
		if healthState == nil or healthState.config.weaponId == nil then
			return
		end

		local liveBaseWeaponConfig = CombatConfig.Weapons[healthState.config.weaponId]
		if liveBaseWeaponConfig == nil then
			return
		end

		local liveWeaponConfig = resolveWeaponConfig(healthState.instance, liveBaseWeaponConfig)
		publishResolvedWeaponAttributes(healthState.instance, liveWeaponConfig)
		local liveHeatMax, _, liveHeatDecay, liveRecoverThreshold = getHeatParams(liveWeaponConfig)
		local nowServer = Workspace:GetServerTimeNow()
		coolHeatState(liveState, nowServer, liveHeatDecay, liveHeatMax)

		if liveState.overheated and liveState.heat <= liveRecoverThreshold then
			liveState.overheated = false
			liveState.recoverCueId += 1
			liveState.recoverToken += 1
		end

		setHeatAttributes(healthState.instance, liveState, liveHeatMax, liveHeatDecay, liveRecoverThreshold)
	end)
end

local function fireSingleProjectile(
	entityModel: Model,
	entityId: string,
	healthState: HealthState,
	weaponConfig: WeaponConfig,
	character: Model,
	normalizedDirection: Vector3,
	cooldown: number,
	lockState: LockState?,
	applyAimSpread: boolean
): boolean
	if normalizedDirection.Magnitude < 1e-4 then
		return false
	end

	local nowServer = Workspace:GetServerTimeNow()
	local ammoState = ammoStateByEntityId[entityId]
	if ammoState ~= nil and ammoState.current <= 0 then
		print(string.format("[P3_AMMO_EMPTY] entity=%s", entityId))
		setAmmoAttributes(entityModel, ammoState)
		return false
	end

	local heatMax, heatPerShot, heatDecayPerSecond, heatRecoverThreshold = getHeatParams(weaponConfig)
	local heatEnabled = heatMax > 0
	local heatState = getOrCreateHeatState(entityId, nowServer)
	if heatEnabled then
		coolHeatState(heatState, nowServer, heatDecayPerSecond, heatMax)

		if heatState.overheated and heatState.heat <= heatRecoverThreshold then
			heatState.overheated = false
			heatState.recoverCueId += 1
			heatState.recoverToken += 1
		end

		if heatState.overheated then
			setHeatAttributes(entityModel, heatState, heatMax, heatDecayPerSecond, heatRecoverThreshold)
			return false
		end
	else
		heatState.heat = 0
		heatState.overheated = false
		heatState.lastUpdatedAt = nowServer
		heatState.lastShotAt = 0
	end

	local fireNode = getNextFireNode(entityId, entityModel)
	if fireNode == nil then
		return false
	end

	local neutralAimFrame = WeaponRig.getNeutralAimFrame(fireNode.mount)
	local clampedDirection = WeaponRig.clampDirectionToMountLimits(fireNode.mount, neutralAimFrame, normalizedDirection)
	if clampedDirection.Magnitude < 1e-4 then
		return false
	end

	local originFrame = WeaponRig.getAimFrame(fireNode.mount, clampedDirection)
	local fireOrigin = originFrame:PointToWorldSpace(fireNode.muzzleLocalOffset)
	local resolvedDirection = clampedDirection

	if applyAimSpread then
		if lockState ~= nil and type(weaponConfig.autoAimSpread) == "number" then
			local autoAimDirection = TargetingServer.computeLeadDirection(
				fireOrigin,
				lockState.targetEntityId,
				weaponConfig.projectileSpeed,
				weaponConfig.autoAimSpread
			)
			if autoAimDirection ~= nil then
				local autoClampedDirection =
					WeaponRig.clampDirectionToMountLimits(fireNode.mount, neutralAimFrame, autoAimDirection.Unit)
				if autoClampedDirection.Magnitude >= 1e-4 then
					resolvedDirection = autoClampedDirection
					local autoOriginFrame = WeaponRig.getAimFrame(fireNode.mount, resolvedDirection)
					fireOrigin = autoOriginFrame:PointToWorldSpace(fireNode.muzzleLocalOffset)
					print(string.format(
						"[P4_AUTO_AIM] entity=%s target=%s spread=%.2f",
						entityId,
						lockState.targetEntityId,
						weaponConfig.autoAimSpread
					))
				end
			end
		elseif lockState == nil and type(weaponConfig.unlockedSpread) == "number" and weaponConfig.unlockedSpread > 0 then
			local spreadDirection = applyDirectionalSpread(resolvedDirection, weaponConfig.unlockedSpread)
			local spreadClampedDirection =
				WeaponRig.clampDirectionToMountLimits(fireNode.mount, neutralAimFrame, spreadDirection)
			if spreadClampedDirection.Magnitude >= 1e-4 then
				resolvedDirection = spreadClampedDirection
				local spreadOriginFrame = WeaponRig.getAimFrame(fireNode.mount, resolvedDirection)
				fireOrigin = spreadOriginFrame:PointToWorldSpace(fireNode.muzzleLocalOffset)
			end
		end
	end

	local faction = HealthManager.getFaction(entityId)
	if faction == nil then
		return false
	end

	projectileCounter += 1
	local projectileId = "proj_" .. tostring(projectileCounter)
	local projectileData: ProjectileData = {
		projectileId = projectileId,
			sourceEntityId = entityId,
			sourceInstance = healthState.instance,
			sourceCharacter = character,
			origin = fireOrigin,
			direction = resolvedDirection,
			speed = weaponConfig.projectileSpeed,
			maxRange = weaponConfig.maxRange,
			damage = weaponConfig.damage,
			damageType = weaponConfig.damageType,
			faction = faction,
			boltColor = weaponConfig.boltColor,
			splashRadius = weaponConfig.splashRadius,
			targetEntityId = nil,
			homingTurnRate = nil,
			currentPosition = nil,
			createdAt = tick(),
		}
	if lockState ~= nil and type(weaponConfig.homingTurnRate) == "number" and weaponConfig.homingTurnRate > 0 then
		projectileData.targetEntityId = lockState.targetEntityId
		projectileData.homingTurnRate = weaponConfig.homingTurnRate
	end

	if ammoState ~= nil then
		ammoState.current = math.max(0, ammoState.current - 1)
		setAmmoAttributes(entityModel, ammoState)
		print(string.format("[P3_AMMO] entity=%s ammo=%d/%d", entityId, ammoState.current, ammoState.max))
	end

	local wasOverheated = heatState.overheated
	if heatEnabled then
		local shotHeat = computeShotHeat(heatPerShot, cooldown, nowServer, heatState.lastShotAt)
		heatState.heat = math.min(heatMax, heatState.heat + shotHeat)
		heatState.lastUpdatedAt = nowServer
		heatState.lastShotAt = nowServer
		if heatState.heat >= heatMax then
			heatState.overheated = true
		end
	else
		heatState.heat = 0
		heatState.overheated = false
		heatState.lastUpdatedAt = nowServer
	end
	setHeatAttributes(entityModel, heatState, heatMax, heatDecayPerSecond, heatRecoverThreshold)
	if heatEnabled and not wasOverheated and heatState.overheated then
		scheduleRecoveryCue(entityId, weaponConfig)
	end

	ProjectileServer.fireProjectile(projectileData)
	return true
end

local function resolvePlayerTurretContext(player: Player): (Model?, Model?, string?, HealthState?)
	local character = player.Character
	if character == nil then
		return nil, nil, nil, nil
	end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if humanoid == nil then
		return nil, nil, nil, nil
	end

	local seatPart = humanoid.SeatPart
	if seatPart == nil or not CollectionService:HasTag(seatPart, "TurretSeat") then
		return nil, nil, nil, nil
	end

	local entityModel = seatPart:FindFirstAncestorWhichIsA("Model")
	if entityModel == nil then
		return nil, nil, nil, nil
	end

	local entityIdAttr = entityModel:GetAttribute("EntityId")
	if type(entityIdAttr) ~= "string" then
		return nil, nil, nil, nil
	end

	local entityId = entityIdAttr
	if not HealthManager.isAlive(entityId) then
		return nil, nil, nil, nil
	end

	local healthState: HealthState? = HealthManager.getHealth(entityId)
	if healthState == nil or healthState.config.weaponId == nil then
		return nil, nil, nil, nil
	end

	return character, entityModel, entityId, healthState
end

local function onUpdateTurretAim(player: Player, aimDirection: Vector3)
	if typeof(aimDirection) ~= "Vector3" or aimDirection.Magnitude < 1e-4 then
		return
	end

	local now = tick()
	local lastUpdate = lastAimUpdateByPlayer[player]
	if lastUpdate ~= nil and now - lastUpdate < AIM_UPDATE_INTERVAL * 0.5 then
		return
	end

	local _character, entityModel, entityId, _healthState = resolvePlayerTurretContext(player)
	if entityModel == nil or entityId == nil then
		return
	end

	local applied = applyAimToRig(entityId, entityModel, aimDirection.Unit)
	if applied ~= nil then
		lastAimUpdateByPlayer[player] = now
	end
end

local function onFireWeapon(player: Player, aimDirection: Vector3)
	if typeof(aimDirection) ~= "Vector3" then
		return
	end

	local character, entityModel, entityId, healthState = resolvePlayerTurretContext(player)
	if character == nil or entityModel == nil or entityId == nil or healthState == nil then
		return
	end

	local baseWeaponConfig = CombatConfig.Weapons[healthState.config.weaponId]
	if baseWeaponConfig == nil then
		return
	end

	local weaponConfig = resolveWeaponConfig(entityModel, baseWeaponConfig)
	publishResolvedWeaponAttributes(entityModel, weaponConfig)
	if weaponConfig.fireRate <= 0 then
		return
	end

	local now = tick()
	local cooldown = 1 / weaponConfig.fireRate
	local lastFireTime = lastFireTimeByPlayer[player]
	if lastFireTime ~= nil and now - lastFireTime < cooldown then
		return
	end

	if aimDirection.Magnitude < 1e-4 then
		return
	end

	local normalizedDirection = aimDirection.Unit
	applyAimToRig(entityId, entityModel, normalizedDirection)
	local firedAny = false
	local weaponClass = getWeaponClass(weaponConfig)
	local lockState = TargetingServer.getLockState(entityId)
	if weaponConfig.requiresLock == true and lockState == nil then
		print(string.format("[P4_LOCK_REQUIRED] entity=%s", entityId))
		return
	end

	if weaponClass == "projectile" then
		firedAny = fireSingleProjectile(
			entityModel,
			entityId,
			healthState,
			weaponConfig,
			character,
			normalizedDirection,
			cooldown,
			lockState,
			true
		)
	elseif weaponClass == "burst_projectile" then
		local burstCount, burstInterval = getBurstParams(weaponConfig)
		firedAny = fireSingleProjectile(
			entityModel,
			entityId,
			healthState,
			weaponConfig,
			character,
			normalizedDirection,
			cooldown,
			lockState,
			true
		)
		if firedAny and burstCount > 1 then
			for shotIndex = 2, burstCount do
				local delayTime = (shotIndex - 1) * burstInterval
				task.delay(delayTime, function()
					if not HealthManager.isAlive(entityId) then
						return
					end

					local liveHealthState = HealthManager.getHealth(entityId)
					if liveHealthState == nil or liveHealthState.config.weaponId == nil then
						return
					end

					local liveBaseWeaponConfig = CombatConfig.Weapons[liveHealthState.config.weaponId]
					if liveBaseWeaponConfig == nil then
						return
					end

					local liveWeaponConfig = resolveWeaponConfig(entityModel, liveBaseWeaponConfig)
					local liveLockState = TargetingServer.getLockState(entityId)
					if liveWeaponConfig.requiresLock == true and liveLockState == nil then
						print(string.format("[P4_LOCK_REQUIRED] entity=%s", entityId))
						return
					end
					publishResolvedWeaponAttributes(entityModel, liveWeaponConfig)
					fireSingleProjectile(
						entityModel,
						entityId,
						liveHealthState,
						liveWeaponConfig,
						character,
						normalizedDirection,
						cooldown,
						liveLockState,
						true
					)
				end)
			end
		end
	else
		if not warnedUnknownWeaponClass[weaponClass] then
			warn(string.format("[P1_WEAPON] Unknown weaponClass '%s'; falling back to projectile", weaponClass))
			warnedUnknownWeaponClass[weaponClass] = true
		end
		firedAny = fireSingleProjectile(
			entityModel,
			entityId,
			healthState,
			weaponConfig,
			character,
			normalizedDirection,
			cooldown,
			lockState,
			true
		)
	end

	if firedAny then
		lastFireTimeByPlayer[player] = now
	end
end

local function resetEntityInternal(entityId: string)
	local healthState = HealthManager.getHealth(entityId)
	if healthState == nil or healthState.config.weaponId == nil then
		return
	end

	local baseWeaponConfig = CombatConfig.Weapons[healthState.config.weaponId]
	if baseWeaponConfig == nil then
		return
	end

	local weaponConfig = resolveWeaponConfig(healthState.instance, baseWeaponConfig)
	publishResolvedWeaponAttributes(healthState.instance, weaponConfig)

	local nowServer = Workspace:GetServerTimeNow()
	local heatMax, _, heatDecayPerSecond, heatRecoverThreshold = getHeatParams(weaponConfig)
	local heatState = getOrCreateHeatState(entityId, nowServer)
	heatState.heat = 0
	heatState.lastUpdatedAt = nowServer
	heatState.lastShotAt = 0
	heatState.overheated = false
	heatState.recoverCueId = 0
	heatState.recoverToken += 1
	setHeatAttributes(healthState.instance, heatState, heatMax, heatDecayPerSecond, heatRecoverThreshold)

	local ammoCapacity = getAmmoCapacity(weaponConfig)
	if ammoCapacity > 0 then
		local ammoState = ammoStateByEntityId[entityId]
		if ammoState == nil then
			ammoState = {
				current = ammoCapacity,
				max = ammoCapacity,
			}
			ammoStateByEntityId[entityId] = ammoState
		else
			ammoState.max = ammoCapacity
			ammoState.current = ammoCapacity
		end
		setAmmoAttributes(healthState.instance, ammoState)
		print(string.format("[P3_AMMO_RESET] entity=%s ammo=%d", entityId, ammoState.current))
	else
		ammoStateByEntityId[entityId] = nil
		setAmmoAttributes(healthState.instance, nil)
	end
end

function WeaponServer.registerEntity(entityId: string)
	local healthState = HealthManager.getHealth(entityId)
	if healthState == nil or healthState.config.weaponId == nil then
		return
	end

	local baseWeaponConfig = CombatConfig.Weapons[healthState.config.weaponId]
	if baseWeaponConfig == nil then
		return
	end
	local weaponConfig = resolveWeaponConfig(healthState.instance, baseWeaponConfig)
	publishResolvedWeaponAttributes(healthState.instance, weaponConfig)

	fireNodeStateByEntityId[entityId] = nil
	drivenRigStateByEntityId[entityId] = nil
	getOrRefreshFireNodeState(entityId, healthState.instance)
	setFireNodeAttributes(healthState.instance, entityId)
	getOrRefreshDrivenRigState(entityId, healthState.instance)
	resetEntityInternal(entityId)
end

function WeaponServer.resetEntity(entityId: string)
	resetEntityInternal(entityId)
end

function WeaponServer.fireTestShot(entityId: string, direction: Vector3, applyAimSpreadForTest: boolean?): boolean
	if not RunService:IsStudio() then
		return false
	end
	if typeof(direction) ~= "Vector3" or direction.Magnitude < 1e-4 then
		return false
	end

	local healthState = HealthManager.getHealth(entityId)
	if healthState == nil or healthState.config.weaponId == nil then
		return false
	end

	local baseWeaponConfig = CombatConfig.Weapons[healthState.config.weaponId]
	if baseWeaponConfig == nil then
		return false
	end

	local weaponConfig = resolveWeaponConfig(healthState.instance, baseWeaponConfig)
	publishResolvedWeaponAttributes(healthState.instance, weaponConfig)
	if weaponConfig.fireRate <= 0 then
		return false
	end
	local lockState = TargetingServer.getLockState(entityId)
	if weaponConfig.requiresLock == true and lockState == nil then
		print(string.format("[P4_LOCK_REQUIRED] entity=%s", entityId))
		return false
	end

	local cooldown = 1 / weaponConfig.fireRate
	local shouldApplyAimSpread = applyAimSpreadForTest == true
	return fireSingleProjectile(
		healthState.instance,
		entityId,
		healthState,
		weaponConfig,
		healthState.instance,
		direction.Unit,
		cooldown,
		lockState,
		shouldApplyAimSpread
	)
end

function WeaponServer.init(remotes: Folder)
	remotesFolder = remotes
	fireWeaponRemote = remotesFolder:WaitForChild("FireWeapon") :: RemoteEvent
	updateTurretAimRemote = remotesFolder:WaitForChild("UpdateTurretAim") :: RemoteEvent

	if fireConnection == nil then
		fireConnection = getFireRemote().OnServerEvent:Connect(onFireWeapon)
	end
	if aimUpdateConnection == nil then
		aimUpdateConnection = getAimUpdateRemote().OnServerEvent:Connect(onUpdateTurretAim)
	end

	if playerRemovingConnection == nil then
		playerRemovingConnection = Players.PlayerRemoving:Connect(function(player)
			lastFireTimeByPlayer[player] = nil
			lastAimUpdateByPlayer[player] = nil
		end)
	end
end

return WeaponServer
]]></string>
          </Properties>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="StarterPlayer" referent="23">
    <Properties>
      <string name="Name">StarterPlayer</string>
    </Properties>
    <Item class="StarterPlayerScripts" referent="24">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="Folder" referent="25">
        <Properties>
          <string name="Name">CombatFramework</string>
        </Properties>
        <Item class="LocalScript" referent="26">
          <Properties>
            <string name="Name">CombatClient</string>
            <string name="Source"><![CDATA[--!strict

local Debris = game:GetService("Debris")
local CollectionService = game:GetService("CollectionService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local localPlayer = Players.LocalPlayer
local playerScripts = localPlayer:WaitForChild("PlayerScripts")
local clientRoot = playerScripts:WaitForChild("CombatFramework")

local sharedRoot = ReplicatedStorage:WaitForChild("CombatFramework")
local CombatConfig = require(sharedRoot:WaitForChild("CombatConfig"))
local CombatTypes = require(sharedRoot:WaitForChild("CombatTypes"))
local TargetingClient = require(clientRoot:WaitForChild("Targeting"):WaitForChild("TargetingClient"))
local WeaponClient = require(clientRoot:WaitForChild("Weapons"):WaitForChild("WeaponClient"))
local ProjectileVisuals = require(clientRoot:WaitForChild("Projectiles"):WaitForChild("ProjectileVisuals"))
local CombatHUD = require(clientRoot:WaitForChild("HUD"):WaitForChild("CombatHUD"))

type EntityDestroyedPayload = CombatTypes.EntityDestroyedPayload
type ActiveShakeBurst = {
	age: number,
	duration: number,
	magnitude: number,
	frequency: number,
	seed: number,
}
type OverheatWorldEffect = {
	model: Model,
	mount: BasePart,
	muzzleLocalOffset: Vector3,
	attachment: Attachment,
	smoke: ParticleEmitter,
	soundPart: BasePart?,
}

local remotesFolder = ReplicatedStorage:WaitForChild("CombatRemotes") :: Folder
local fireWeaponRemote = remotesFolder:WaitForChild("FireWeapon") :: RemoteEvent
local projectileFiredRemote = remotesFolder:WaitForChild("ProjectileFired") :: RemoteEvent
local projectileImpactRemote = remotesFolder:WaitForChild("ProjectileImpact") :: RemoteEvent
local damageAppliedRemote = remotesFolder:WaitForChild("DamageApplied") :: RemoteEvent
local hitConfirmRemote = remotesFolder:WaitForChild("HitConfirm") :: RemoteEvent
local entityDestroyedRemote = remotesFolder:WaitForChild("EntityDestroyed") :: RemoteEvent
local entityRespawnedRemote = remotesFolder:WaitForChild("EntityRespawned") :: RemoteEvent

local warnedMissingTurretExplosionSound = false
local warnedMissingTurretExplosionParticles = false
local destructionEffectsFolder: Folder? = nil
local activeShakeBursts: { ActiveShakeBurst } = {}
local cameraShakeBound = false
local cameraShakeConnection: RBXScriptConnection? = nil
local overheatSyncConnection: RBXScriptConnection? = nil
local overheatEffectsByEntityId: { [string]: OverheatWorldEffect } = {}
local overheatSyncAccumulator = 0
local warnedMissingOverheatWorldSound = false

local EXPLOSION_BURST_COUNTS: { [string]: number } = {
	Smoke = 36,
	Flash = 4,
	Sparks = 90,
	Explosion = 42,
}
local OVERHEAT_SYNC_INTERVAL = 0.1

local function isMuzzleAttachment(candidate: Instance): boolean
	if not candidate:IsA("Attachment") then
		return false
	end

	if CollectionService:HasTag(candidate, "MuzzlePoint") then
		return true
	end

	return candidate.Name == "MuzzlePoint" or string.sub(candidate.Name, 1, 11) == "MuzzlePoint"
end

local function getPrimaryMuzzleLocalOffset(weaponMount: BasePart): Vector3
	local attachments: { Attachment } = {}
	for _, descendant in ipairs(weaponMount:GetDescendants()) do
		if isMuzzleAttachment(descendant) then
			table.insert(attachments, descendant :: Attachment)
		end
	end

	table.sort(attachments, function(a: Attachment, b: Attachment)
		return a:GetFullName() < b:GetFullName()
	end)

	local muzzlePoint = attachments[1]
	if muzzlePoint ~= nil then
		return weaponMount.CFrame:PointToObjectSpace(muzzlePoint.WorldPosition)
	end

	return Vector3.new(0, 0, -weaponMount.Size.Z * 0.5)
end

local function readConfigNumber(name: string, defaultValue: number): number
	local raw = CombatConfig[name]
	if type(raw) == "number" then
		return raw
	end
	return defaultValue
end

local function ensureDestructionEffectsFolder(): Folder
	if destructionEffectsFolder ~= nil and destructionEffectsFolder.Parent ~= nil then
		return destructionEffectsFolder
	end

	local existing = Workspace:FindFirstChild("CombatDestructionEffects")
	if existing ~= nil and existing:IsA("Folder") then
		destructionEffectsFolder = existing
		return existing
	end

	local folder = Instance.new("Folder")
	folder.Name = "CombatDestructionEffects"
	folder.Parent = Workspace
	destructionEffectsFolder = folder
	return folder
end

local function getOverheatWorldSoundTemplate(): Sound?
	local combatAssets = ReplicatedStorage:FindFirstChild("CombatAssets")
	if combatAssets == nil or not combatAssets:IsA("Folder") then
		return nil
	end

	local audioFolder = combatAssets:FindFirstChild("Audio")
	if audioFolder == nil or not audioFolder:IsA("Folder") then
		return nil
	end

	local overheatFolder = audioFolder:FindFirstChild("Overheat")
	if overheatFolder == nil or not overheatFolder:IsA("Folder") then
		return nil
	end

	for _, child in ipairs(overheatFolder:GetChildren()) do
		if child:IsA("Sound") then
			return child
		end
	end

	return nil
end

local function getExplosionSoundTemplates(): { Sound }
	local templates: { Sound } = {}
	local combatAssets = ReplicatedStorage:FindFirstChild("CombatAssets")
	if combatAssets == nil or not combatAssets:IsA("Folder") then
		return templates
	end

	local audioFolder = combatAssets:FindFirstChild("Audio")
	if audioFolder == nil or not audioFolder:IsA("Folder") then
		return templates
	end

	local explosionFolder = audioFolder:FindFirstChild("Explosion")
	if explosionFolder ~= nil and explosionFolder:IsA("Folder") then
		for _, child in ipairs(explosionFolder:GetChildren()) do
			if child:IsA("Sound") then
				table.insert(templates, child)
			end
		end
	end

	if #templates == 0 then
		local impactFolder = audioFolder:FindFirstChild("Impact")
		if impactFolder ~= nil and impactFolder:IsA("Folder") then
			for _, child in ipairs(impactFolder:GetChildren()) do
				if child:IsA("Sound") then
					table.insert(templates, child)
				end
			end
		end
	end

	return templates
end

local function playTurretExplosionSoundAt(position: Vector3)
	local soundTemplates = getExplosionSoundTemplates()
	if #soundTemplates == 0 then
		if not warnedMissingTurretExplosionSound then
			warn("[P2_AUDIO] Missing turret explosion sound templates in ReplicatedStorage.CombatAssets.Audio.Explosion")
			warnedMissingTurretExplosionSound = true
		end
		return
	end

	local soundPart = Instance.new("Part")
	soundPart.Name = "TurretExplosionSound"
	soundPart.Size = Vector3.new(0.25, 0.25, 0.25)
	soundPart.Transparency = 1
	soundPart.Anchored = true
	soundPart.CanCollide = false
	soundPart.CanQuery = false
	soundPart.CanTouch = false
	soundPart.CFrame = CFrame.new(position)
	soundPart.Parent = ensureDestructionEffectsFolder()

	local cleanupDelay = 1
	for _, soundTemplate in ipairs(soundTemplates) do
		local sound = soundTemplate:Clone()
		sound.Looped = false
		sound.Parent = soundPart
		sound:Play()
		cleanupDelay = math.max(cleanupDelay, sound.TimeLength + 0.2)
	end

	Debris:AddItem(soundPart, cleanupDelay)
end

local function getExplosionParticleTemplateFolder(): Folder?
	local combatAssets = ReplicatedStorage:FindFirstChild("CombatAssets")
	if combatAssets == nil or not combatAssets:IsA("Folder") then
		return nil
	end

	local impactParticles = combatAssets:FindFirstChild("ImpactParticles")
	if impactParticles == nil or not impactParticles:IsA("Folder") then
		return nil
	end

	local turretTemplate = impactParticles:FindFirstChild("turretExplosion")
	if turretTemplate ~= nil and turretTemplate:IsA("Folder") then
		return turretTemplate
	end

	local fallback = impactParticles:FindFirstChild("bulletHit")
	if fallback ~= nil and fallback:IsA("Folder") then
		return fallback
	end

	return nil
end

local function getBurstCount(emitter: ParticleEmitter): number
	local attributeBurstCount = emitter:GetAttribute("EmitCount")
	if type(attributeBurstCount) == "number" then
		return math.max(0, math.floor(attributeBurstCount + 0.5))
	end

	local mapped = EXPLOSION_BURST_COUNTS[emitter.Name]
	if mapped ~= nil then
		return mapped
	end

	return 18
end

local function scaleNumberSequence(sequence: NumberSequence, scale: number): NumberSequence
	local keypoints = sequence.Keypoints
	local scaled: { NumberSequenceKeypoint } = table.create(#keypoints)
	for index, keypoint in ipairs(keypoints) do
		scaled[index] = NumberSequenceKeypoint.new(
			keypoint.Time,
			keypoint.Value * scale,
			keypoint.Envelope * scale
		)
	end
	return NumberSequence.new(scaled)
end

local function spawnTurretExplosionEffect(position: Vector3)
	local template = getExplosionParticleTemplateFolder()
	if template == nil then
		if not warnedMissingTurretExplosionParticles then
			warn("[P2_IMPACT] Missing ReplicatedStorage.CombatAssets.ImpactParticles.turretExplosion (or bulletHit fallback).")
			warnedMissingTurretExplosionParticles = true
		end
		return
	end

	local particleScale = math.max(0.1, readConfigNumber("TurretDeathExplosionParticleScale", 1.8))
	local emitMultiplier = math.max(0.1, readConfigNumber("TurretDeathExplosionParticleEmitMultiplier", 2.2))
	local speedScale = math.max(0.1, 0.85 + particleScale * 0.4)

	local effectPart = Instance.new("Part")
	effectPart.Name = "TurretExplosionEffect"
	effectPart.Transparency = 1
	effectPart.Size = Vector3.new(8, 8, 8)
	effectPart.Anchored = true
	effectPart.CanCollide = false
	effectPart.CanTouch = false
	effectPart.CanQuery = false
	effectPart.CastShadow = false
	effectPart.CFrame = CFrame.new(position)
	effectPart.Parent = ensureDestructionEffectsFolder()

	local attachmentMap: { [Attachment]: Attachment } = {}
	for _, descendant in ipairs(template:GetDescendants()) do
		if descendant:IsA("Attachment") then
			local attachmentClone = descendant:Clone()
			attachmentClone.Parent = effectPart
			attachmentMap[descendant] = attachmentClone
		end
	end

	local spawnedEffects: { Instance } = {}
	for _, descendant in ipairs(template:GetDescendants()) do
		if descendant:IsA("ParticleEmitter") or descendant:IsA("PointLight") then
			local effectClone = descendant:Clone()
			local targetParent: Instance = effectPart
			local templateParent = descendant.Parent
			if templateParent ~= nil and templateParent:IsA("Attachment") then
				local mappedAttachment = attachmentMap[templateParent]
				if mappedAttachment ~= nil then
					targetParent = mappedAttachment
				end
			end

			if effectClone:IsA("ParticleEmitter") then
				effectClone.Size = scaleNumberSequence(effectClone.Size, particleScale)
				effectClone.Speed = NumberRange.new(effectClone.Speed.Min * speedScale, effectClone.Speed.Max * speedScale)
			elseif effectClone:IsA("PointLight") then
				effectClone.Range *= particleScale
			end

			effectClone.Parent = targetParent
			table.insert(spawnedEffects, effectClone)
		end
	end

	for _, effect in ipairs(spawnedEffects) do
		if effect:IsA("ParticleEmitter") then
			local emitCount = math.max(1, math.floor(getBurstCount(effect) * emitMultiplier + 0.5))
			effect:Emit(emitCount)
		elseif effect:IsA("PointLight") then
			effect.Enabled = true
		end
	end

	task.delay(0.18, function()
		if effectPart.Parent == nil then
			return
		end
		for _, effect in ipairs(spawnedEffects) do
			if effect.Parent ~= nil and (effect:IsA("ParticleEmitter") or effect:IsA("PointLight")) then
				effect.Enabled = false
			end
		end
	end)

	Debris:AddItem(effectPart, 6)
end

local function ensureCameraShakeStep()
	if cameraShakeBound then
		return
	end
	cameraShakeBound = true

	cameraShakeConnection = RunService.RenderStepped:Connect(function(dt)
		local camera = Workspace.CurrentCamera
		if camera == nil or #activeShakeBursts == 0 then
			return
		end

		local totalOffset = Vector3.zero
		local totalRoll = 0

		for index = #activeShakeBursts, 1, -1 do
			local burst = activeShakeBursts[index]
			burst.age += dt

			local remaining = 1 - (burst.age / math.max(burst.duration, 1e-4))
			if remaining <= 0 then
				table.remove(activeShakeBursts, index)
			else
				local intensity = burst.magnitude * remaining * remaining
				local phase = burst.age * burst.frequency + burst.seed
				totalOffset += Vector3.new(
					math.sin(phase * 1.23 + burst.seed * 0.71),
					math.sin(phase * 1.89 + burst.seed * 0.43),
					math.sin(phase * 2.57 + burst.seed * 0.29)
				) * intensity
				totalRoll += math.sin(phase * 2.17 + burst.seed) * intensity * 2.8
			end
		end

		if totalOffset.Magnitude > 1e-4 or math.abs(totalRoll) > 1e-4 then
			camera.CFrame = camera.CFrame * CFrame.new(totalOffset * 1.45) * CFrame.Angles(0, 0, math.rad(totalRoll * 1.75))
		end
	end)
end

local function pushExplosionCameraShake(explosionPosition: Vector3, explosionRadius: number?)
	local camera = Workspace.CurrentCamera
	if camera == nil then
		return
	end

	local configuredRadius = math.max(1, readConfigNumber("TurretDeathExplosionShakeRadius", 60))
	local radius = if type(explosionRadius) == "number" and explosionRadius > 0
		then math.max(configuredRadius, explosionRadius * 2)
		else configuredRadius
	local distance = (camera.CFrame.Position - explosionPosition).Magnitude
	if distance > radius then
		return
	end

	local distanceAlpha = math.clamp(1 - (distance / radius), 0, 1)
	local baseStrength = math.max(0, readConfigNumber("TurretDeathExplosionShakeStrength", 0.45))
	local magnitude = baseStrength * distanceAlpha * distanceAlpha
	if magnitude <= 1e-4 then
		return
	end

	table.insert(activeShakeBursts, {
		age = 0,
		duration = math.max(0.05, readConfigNumber("TurretDeathExplosionShakeDuration", 0.42)),
		magnitude = magnitude,
		frequency = 22 + math.random() * 8,
		seed = math.random() * 1000,
	})
	ensureCameraShakeStep()
end

local function findEntityById(entityId: string): Model?
	for _, tagged in ipairs(CollectionService:GetTagged("CombatEntity")) do
		if tagged:IsA("Model") and tagged:GetAttribute("EntityId") == entityId then
			return tagged
		end
	end
	return nil
end

local function findWeaponMount(entityModel: Model): BasePart?
	for _, descendant in ipairs(entityModel:GetDescendants()) do
		if descendant:IsA("BasePart") and CollectionService:HasTag(descendant, "WeaponMount") then
			return descendant
		end
	end
	return nil
end

local function isLocalPlayerSeatedInModel(entityModel: Model): boolean
	local character = localPlayer.Character
	if character == nil then
		return false
	end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if humanoid == nil then
		return false
	end

	local seatPart = humanoid.SeatPart
	if seatPart == nil then
		return false
	end

	return seatPart:IsDescendantOf(entityModel)
end

local function destroyOverheatWorldEffect(entityId: string)
	local effect = overheatEffectsByEntityId[entityId]
	if effect == nil then
		return
	end

	if effect.attachment.Parent ~= nil then
		effect.attachment:Destroy()
	end
	if effect.soundPart ~= nil and effect.soundPart.Parent ~= nil then
		effect.soundPart:Destroy()
	end
	overheatEffectsByEntityId[entityId] = nil
end

local function ensureOverheatWorldEffect(entityId: string, entityModel: Model)
	local mount = findWeaponMount(entityModel)
	if mount == nil then
		destroyOverheatWorldEffect(entityId)
		return
	end

	local existing = overheatEffectsByEntityId[entityId]
	if existing ~= nil and (existing.mount.Parent == nil or not existing.mount:IsDescendantOf(entityModel)) then
		destroyOverheatWorldEffect(entityId)
		existing = nil
	end

	if existing == nil then
		local muzzleLocalOffset = getPrimaryMuzzleLocalOffset(mount)

		local attachment = Instance.new("Attachment")
		attachment.Name = "OverheatWorldFX"
		attachment.Position = muzzleLocalOffset
		attachment.Parent = mount

		local smoke = Instance.new("ParticleEmitter")
		smoke.Name = "OverheatSmoke"
		smoke.Enabled = true
		smoke.Rate = 34
		smoke.Speed = NumberRange.new(0.45, 1.6)
		smoke.Lifetime = NumberRange.new(0.55, 1.3)
		smoke.SpreadAngle = Vector2.new(18, 18)
		smoke.RotSpeed = NumberRange.new(-25, 25)
		smoke.Rotation = NumberRange.new(0, 360)
		smoke.Acceleration = Vector3.new(0, 4, 0)
		smoke.Texture = "rbxassetid://716847870"
		smoke.Size = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.48),
			NumberSequenceKeypoint.new(0.5, 1.25),
			NumberSequenceKeypoint.new(1, 2.1),
		})
		smoke.Transparency = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.42),
			NumberSequenceKeypoint.new(1, 1),
		})
		smoke.Color = ColorSequence.new({
			ColorSequenceKeypoint.new(0, Color3.fromRGB(132, 132, 132)),
			ColorSequenceKeypoint.new(0.35, Color3.fromRGB(88, 88, 88)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(42, 42, 42)),
		})
		smoke.Parent = attachment

		local soundPart = Instance.new("Part")
		soundPart.Name = "OverheatWorldSound"
		soundPart.Size = Vector3.new(0.25, 0.25, 0.25)
		soundPart.Transparency = 1
		soundPart.Anchored = true
		soundPart.CanCollide = false
		soundPart.CanTouch = false
		soundPart.CanQuery = false
		soundPart.CFrame = mount.CFrame * CFrame.new(muzzleLocalOffset)
		soundPart.Parent = ensureDestructionEffectsFolder()

		local soundTemplate = getOverheatWorldSoundTemplate()
		if soundTemplate ~= nil then
			local sound = soundTemplate:Clone()
			sound.Looped = true
			sound.Parent = soundPart
			sound:Play()
		elseif not warnedMissingOverheatWorldSound then
			warn("[P1_AUDIO] Missing overheat world sound template in ReplicatedStorage.CombatAssets.Audio.Overheat")
			warnedMissingOverheatWorldSound = true
		end

		existing = {
			model = entityModel,
			mount = mount,
			muzzleLocalOffset = muzzleLocalOffset,
			attachment = attachment,
			smoke = smoke,
			soundPart = soundPart,
		}
		overheatEffectsByEntityId[entityId] = existing
	end

	if existing.soundPart ~= nil and existing.soundPart.Parent ~= nil and existing.mount.Parent ~= nil then
		existing.soundPart.CFrame = existing.mount.CFrame * CFrame.new(existing.muzzleLocalOffset)
	end
end

local function syncOverheatWorldEffects()
	local seenEntityIds: { [string]: boolean } = {}
	for _, tagged in ipairs(CollectionService:GetTagged("CombatEntity")) do
		if tagged:IsA("Model") then
			local entityModel = tagged :: Model
			local entityIdAttr = entityModel:GetAttribute("EntityId")
			if type(entityIdAttr) == "string" then
				local entityId = entityIdAttr
				seenEntityIds[entityId] = true

				local overheated = entityModel:GetAttribute("WeaponOverheated") == true
				local localSeated = isLocalPlayerSeatedInModel(entityModel)
				if overheated and not localSeated then
					ensureOverheatWorldEffect(entityId, entityModel)
				else
					destroyOverheatWorldEffect(entityId)
				end
			end
		end
	end

	for entityId, effect in pairs(overheatEffectsByEntityId) do
		if not seenEntityIds[entityId] or effect.model.Parent == nil then
			destroyOverheatWorldEffect(entityId)
		end
	end
end

local function normalizeEntityDestroyedPayload(payload: any): EntityDestroyedPayload?
	if type(payload) == "string" then
		return {
			entityId = payload,
		}
	end
	if type(payload) ~= "table" then
		return nil
	end

	local entityId = payload.entityId
	if type(entityId) ~= "string" then
		return nil
	end

	local normalized: EntityDestroyedPayload = {
		entityId = entityId,
	}

	if typeof(payload.explosionPosition) == "Vector3" then
		normalized.explosionPosition = payload.explosionPosition
	end
	if type(payload.explosionRadius) == "number" then
		normalized.explosionRadius = payload.explosionRadius
	end

	return normalized
end

local function onEntityDestroyed(rawPayload: any)
	local payload = normalizeEntityDestroyedPayload(rawPayload)
	if payload == nil then
		return
	end

	local model = findEntityById(payload.entityId)
	local explosionPosition = payload.explosionPosition
	if explosionPosition == nil and model ~= nil then
		explosionPosition = model:GetPivot().Position
	end

	if model ~= nil then
		for _, descendant in ipairs(model:GetDescendants()) do
			if descendant:IsA("BasePart") then
				descendant.Transparency = 1
			end
		end
	end

	if explosionPosition ~= nil then
		playTurretExplosionSoundAt(explosionPosition)
		spawnTurretExplosionEffect(explosionPosition)
		pushExplosionCameraShake(explosionPosition, payload.explosionRadius)
	end

	destroyOverheatWorldEffect(payload.entityId)
	CombatHUD.onEntityDestroyed(payload.entityId)
end

local function onEntityRespawned(payload)
	if type(payload) ~= "table" or type(payload.entityId) ~= "string" then
		return
	end

	local model = findEntityById(payload.entityId)
	if model ~= nil then
		for _, descendant in ipairs(model:GetDescendants()) do
			if descendant:IsA("BasePart") then
				if descendant:IsA("Seat") and CollectionService:HasTag(descendant, "TurretSeat") then
					descendant.Transparency = 1
				else
					descendant.Transparency = 0
				end
			end
		end
	end

	destroyOverheatWorldEffect(payload.entityId)
	CombatHUD.onEntityRespawned(payload)
end

CombatHUD.init()
TargetingClient.init(remotesFolder)
WeaponClient.init(remotesFolder)
ProjectileVisuals.init(remotesFolder)

-- Keep references so all required remotes are guaranteed to exist in pass 1.
local _ = fireWeaponRemote
_ = projectileFiredRemote
_ = projectileImpactRemote
_ = hitConfirmRemote

damageAppliedRemote.OnClientEvent:Connect(function(payload)
	CombatHUD.onDamageApplied(payload)
end)

hitConfirmRemote.OnClientEvent:Connect(function(payload)
	CombatHUD.onHitConfirm(payload)
end)

entityDestroyedRemote.OnClientEvent:Connect(onEntityDestroyed)
entityRespawnedRemote.OnClientEvent:Connect(onEntityRespawned)

if overheatSyncConnection == nil then
	overheatSyncConnection = RunService.Heartbeat:Connect(function(dt)
		overheatSyncAccumulator += dt
		if overheatSyncAccumulator < OVERHEAT_SYNC_INTERVAL then
			return
		end
		overheatSyncAccumulator = 0
		syncOverheatWorldEffects()
	end)
end
]]></string>
          </Properties>
        </Item>
        <Item class="Folder" referent="27">
          <Properties>
            <string name="Name">HUD</string>
          </Properties>
          <Item class="ModuleScript" referent="28">
            <Properties>
              <string name="Name">CombatHUD</string>
              <string name="Source"><![CDATA[--!strict

local CollectionService = game:GetService("CollectionService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")

local localPlayer = Players.LocalPlayer

local CombatHUD = {}

local screenGui: ScreenGui? = nil
local crosshairLabel: TextLabel? = nil
local hitmarkerFrame: Frame? = nil
local hitmarkerLines: { Frame } = {}
local hitmarkerTween: Tween? = nil
local cursorDot: Frame? = nil
local hpFrame: Frame? = nil
local hpLabel: TextLabel? = nil
local shieldFrame: Frame? = nil
local shieldFill: Frame? = nil
local shieldLabel: TextLabel? = nil
local ammoFrame: Frame? = nil
local ammoLabel: TextLabel? = nil
local heatFrame: Frame? = nil
local heatFill: Frame? = nil
local heatLabel: TextLabel? = nil
local readyLabel: TextLabel? = nil
local lockReadyLabel: TextLabel? = nil
local lockReticleFrame: Frame? = nil
local leadingIndicatorDot: Frame? = nil
local vignetteEdges: { Frame } = {}
local hitmarkerToken = 0
local readyCueToken = 0
local warnedMissingHitmarkerSoundTemplate = false
local warnedMissingKillSoundTemplate = false
local warnedMissingOverheatSoundTemplate = false
local warnedMissingOverheatWarningSoundTemplate = false
local lastOverheatWarningAt = 0
local wasOverheatedLastUpdate = false

local VIGNETTE_MAX_OPACITY = 0.45
local VIGNETTE_EDGE_SIZE_SCALE = 0.24
local HEAT_WARNING_THRESHOLD = 0.85
local HEAT_WARNING_SOUND_COOLDOWN = 0.7
local HEAT_PULSE_SPEED = 12
local SHIELD_LOW_THRESHOLD = 0.25
local SHIELD_PULSE_SPEED = 8
local SHIELD_HEALTHY_COLOR = Color3.fromRGB(80, 140, 255)
local SHIELD_LOW_COLOR = Color3.fromRGB(90, 240, 255)

local currentEntityId: string? = nil
local hpCache: { [string]: { currentHP: number, maxHP: number } } = {}
local shieldCache: { [string]: { currentShield: number, maxShield: number } } = {}

local function getHitmarkerSoundTemplate(): Sound?
	local combatAssets = ReplicatedStorage:FindFirstChild("CombatAssets")
	if combatAssets == nil or not combatAssets:IsA("Folder") then
		return nil
	end

	local audioFolder = combatAssets:FindFirstChild("Audio")
	if audioFolder == nil or not audioFolder:IsA("Folder") then
		return nil
	end

	local hitmarkerFolder = audioFolder:FindFirstChild("Hitmarker")
	if hitmarkerFolder == nil or not hitmarkerFolder:IsA("Folder") then
		return nil
	end

	for _, child in ipairs(hitmarkerFolder:GetChildren()) do
		if child:IsA("Sound") then
			return child
		end
	end

	return nil
end

local function getKillSoundTemplate(): Sound?
	local combatAssets = ReplicatedStorage:FindFirstChild("CombatAssets")
	if combatAssets == nil or not combatAssets:IsA("Folder") then
		return nil
	end

	local audioFolder = combatAssets:FindFirstChild("Audio")
	if audioFolder == nil or not audioFolder:IsA("Folder") then
		return nil
	end

	local killFolder = audioFolder:FindFirstChild("KillConfirm")
	if killFolder == nil or not killFolder:IsA("Folder") then
		return nil
	end

	for _, child in ipairs(killFolder:GetChildren()) do
		if child:IsA("Sound") then
			return child
		end
	end

	return nil
end

local function getOverheatWarningSoundTemplate(): Sound?
	local combatAssets = ReplicatedStorage:FindFirstChild("CombatAssets")
	if combatAssets == nil or not combatAssets:IsA("Folder") then
		return nil
	end

	local audioFolder = combatAssets:FindFirstChild("Audio")
	if audioFolder == nil or not audioFolder:IsA("Folder") then
		return nil
	end

	local warningFolder = audioFolder:FindFirstChild("OverheatWarning")
	if warningFolder == nil or not warningFolder:IsA("Folder") then
		return nil
	end

	for _, child in ipairs(warningFolder:GetChildren()) do
		if child:IsA("Sound") then
			return child
		end
	end

	return nil
end

local function getOverheatSoundTemplate(): Sound?
	local combatAssets = ReplicatedStorage:FindFirstChild("CombatAssets")
	if combatAssets == nil or not combatAssets:IsA("Folder") then
		return nil
	end

	local audioFolder = combatAssets:FindFirstChild("Audio")
	if audioFolder == nil or not audioFolder:IsA("Folder") then
		return nil
	end

	local overheatFolder = audioFolder:FindFirstChild("Overheat")
	if overheatFolder == nil or not overheatFolder:IsA("Folder") then
		return nil
	end

	for _, child in ipairs(overheatFolder:GetChildren()) do
		if child:IsA("Sound") then
			return child
		end
	end

	return nil
end

local function playGuiSound(soundTemplate: Sound)
	local gui = screenGui
	if gui == nil then
		return
	end

	local hitSound = soundTemplate:Clone()
	hitSound.Looped = false
	hitSound.Parent = gui
	hitSound:Play()
	local cleanupDelay = math.max(1, hitSound.TimeLength + 0.15)
	task.delay(cleanupDelay, function()
		if hitSound.Parent ~= nil then
			hitSound:Destroy()
		end
	end)
end

local function playHitmarkerSound()
	local soundTemplate = getHitmarkerSoundTemplate()
	if soundTemplate == nil then
		if not warnedMissingHitmarkerSoundTemplate then
			warn("[P1_AUDIO] Missing hitmarker sound template in ReplicatedStorage.CombatAssets.Audio.Hitmarker")
			warnedMissingHitmarkerSoundTemplate = true
		end
		return
	end

	playGuiSound(soundTemplate)
end

local function playKillConfirmSound()
	local soundTemplate = getKillSoundTemplate()
	if soundTemplate == nil then
		if not warnedMissingKillSoundTemplate then
			warn("[P1_AUDIO] Missing kill-confirm sound template in ReplicatedStorage.CombatAssets.Audio.KillConfirm")
			warnedMissingKillSoundTemplate = true
		end
		return
	end

	playGuiSound(soundTemplate)
end

local function playOverheatSound()
	local soundTemplate = getOverheatSoundTemplate()
	if soundTemplate == nil then
		if not warnedMissingOverheatSoundTemplate then
			warn("[P1_AUDIO] Missing overheat sound template in ReplicatedStorage.CombatAssets.Audio.Overheat")
			warnedMissingOverheatSoundTemplate = true
		end
		return
	end

	playGuiSound(soundTemplate)
end

local function playOverheatWarningSound()
	local soundTemplate = getOverheatWarningSoundTemplate()
	if soundTemplate == nil then
		if not warnedMissingOverheatWarningSoundTemplate then
			warn("[P1_AUDIO] Missing overheat warning sound template in ReplicatedStorage.CombatAssets.Audio.OverheatWarning")
			warnedMissingOverheatWarningSoundTemplate = true
		end
		return
	end

	playGuiSound(soundTemplate)
end

local function findEntityById(entityId: string): Model?
	for _, tagged in ipairs(CollectionService:GetTagged("CombatEntity")) do
		if tagged:IsA("Model") then
			local taggedEntityId = tagged:GetAttribute("EntityId")
			if taggedEntityId == entityId then
				return tagged
			end
		end
	end
	return nil
end

local function updateHpLabel(entityId: string)
	if hpLabel == nil then
		return
	end

	local hpData = hpCache[entityId]
	if hpData ~= nil then
		hpLabel.Text = string.format("Hull: %d / %d", hpData.currentHP, hpData.maxHP)
		return
	end

	local model = findEntityById(entityId)
	if model ~= nil then
		local currentHP = model:GetAttribute("HullHP")
		local maxHP = model:GetAttribute("MaxHullHP")
		if type(currentHP) == "number" and type(maxHP) == "number" then
			hpCache[entityId] = {
				currentHP = currentHP,
				maxHP = maxHP,
			}
			hpLabel.Text = string.format("Hull: %d / %d", currentHP, maxHP)
			return
		end
	end

	hpLabel.Text = "Hull: -- / --"
end

function CombatHUD.init()
	local playerGui = localPlayer:WaitForChild("PlayerGui")

	local existing = playerGui:FindFirstChild("CombatHUD")
	if existing ~= nil and existing:IsA("ScreenGui") then
		existing:Destroy()
	end

	local gui = Instance.new("ScreenGui")
	gui.Name = "CombatHUD"
	gui.ResetOnSpawn = false
	gui.Enabled = true
	gui.IgnoreGuiInset = true
	gui.Parent = playerGui

	table.clear(vignetteEdges)
	table.clear(hitmarkerLines)

	local function createVignetteEdge(name: string, size: UDim2, position: UDim2, anchorPoint: Vector2, rotation: number): Frame
		local edge = Instance.new("Frame")
		edge.Name = name
		edge.Size = size
		edge.Position = position
		edge.AnchorPoint = anchorPoint
		edge.BackgroundColor3 = Color3.new(0, 0, 0)
		edge.BackgroundTransparency = 1
		edge.BorderSizePixel = 0
		edge.Visible = false
		edge.ZIndex = 0
		edge.Parent = gui

		local gradient = Instance.new("UIGradient")
		gradient.Rotation = rotation
		gradient.Transparency = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0),
			NumberSequenceKeypoint.new(1, 1),
		})
		gradient.Parent = edge

		table.insert(vignetteEdges, edge)
		return edge
	end

	createVignetteEdge(
		"VignetteTop",
		UDim2.fromScale(1, VIGNETTE_EDGE_SIZE_SCALE),
		UDim2.fromScale(0.5, 0),
		Vector2.new(0.5, 0),
		90
	)
	createVignetteEdge(
		"VignetteBottom",
		UDim2.fromScale(1, VIGNETTE_EDGE_SIZE_SCALE),
		UDim2.fromScale(0.5, 1),
		Vector2.new(0.5, 1),
		-90
	)
	createVignetteEdge(
		"VignetteLeft",
		UDim2.fromScale(VIGNETTE_EDGE_SIZE_SCALE, 1),
		UDim2.fromScale(0, 0.5),
		Vector2.new(0, 0.5),
		0
	)
	createVignetteEdge(
		"VignetteRight",
		UDim2.fromScale(VIGNETTE_EDGE_SIZE_SCALE, 1),
		UDim2.fromScale(1, 0.5),
		Vector2.new(1, 0.5),
		180
	)

	local crosshair = Instance.new("TextLabel")
	crosshair.Name = "Crosshair"
	crosshair.AnchorPoint = Vector2.new(0.5, 0.5)
	crosshair.Position = UDim2.fromScale(0.5, 0.5)
	crosshair.Size = UDim2.fromOffset(22, 22)
	crosshair.BackgroundTransparency = 1
	crosshair.Text = "+"
	crosshair.TextColor3 = Color3.new(1, 1, 1)
	crosshair.TextScaled = true
	crosshair.Visible = false
	crosshair.ZIndex = 5
	crosshair.Parent = gui

	local lockReadyText = Instance.new("TextLabel")
	lockReadyText.Name = "LockReadyLabel"
	lockReadyText.AnchorPoint = Vector2.new(0.5, 1)
	lockReadyText.Position = UDim2.fromScale(0.5, 0.42)
	lockReadyText.Size = UDim2.fromOffset(320, 28)
	lockReadyText.BackgroundTransparency = 1
	lockReadyText.Text = "TARGET LOCK READY (T TO LOCK ON)"
	lockReadyText.TextColor3 = Color3.fromRGB(255, 225, 110)
	lockReadyText.TextStrokeColor3 = Color3.new(0, 0, 0)
	lockReadyText.TextStrokeTransparency = 0.35
	lockReadyText.Font = Enum.Font.GothamBold
	lockReadyText.TextSize = 20
	lockReadyText.Visible = false
	lockReadyText.ZIndex = 9
	lockReadyText.Parent = gui

	local lockReticle = Instance.new("Frame")
	lockReticle.Name = "LockReticle"
	lockReticle.AnchorPoint = Vector2.new(0.5, 0.5)
	lockReticle.Position = UDim2.fromScale(0.5, 0.5)
	lockReticle.Size = UDim2.fromOffset(42, 42)
	lockReticle.BackgroundTransparency = 1
	lockReticle.Rotation = 45
	lockReticle.Visible = false
	lockReticle.ZIndex = 9
	lockReticle.Parent = gui

	local lockStroke = Instance.new("UIStroke")
	lockStroke.Thickness = 2
	lockStroke.Color = Color3.fromRGB(255, 110, 110)
	lockStroke.Parent = lockReticle

	local leadDot = Instance.new("Frame")
	leadDot.Name = "LeadDot"
	leadDot.AnchorPoint = Vector2.new(0.5, 0.5)
	leadDot.Position = UDim2.fromScale(0.5, 0.5)
	leadDot.Size = UDim2.fromOffset(8, 8)
	leadDot.BackgroundColor3 = Color3.fromRGB(255, 190, 72)
	leadDot.BorderSizePixel = 0
	leadDot.Visible = false
	leadDot.ZIndex = 9
	leadDot.Parent = gui

	local leadDotCorner = Instance.new("UICorner")
	leadDotCorner.CornerRadius = UDim.new(1, 0)
	leadDotCorner.Parent = leadDot

	local hitmarker = Instance.new("Frame")
	hitmarker.Name = "HitMarker"
	hitmarker.AnchorPoint = Vector2.new(0.5, 0.5)
	hitmarker.Position = UDim2.fromScale(0.5, 0.5)
	hitmarker.Size = UDim2.fromOffset(28, 28)
	hitmarker.BackgroundTransparency = 1
	hitmarker.Visible = false
	hitmarker.ZIndex = 6
	hitmarker.Parent = gui

	local function createHitLine(name: string, xScale: number, yScale: number, rotation: number)
		local line = Instance.new("Frame")
		line.Name = name
		line.AnchorPoint = Vector2.new(0.5, 0.5)
		line.Position = UDim2.fromScale(xScale, yScale)
		line.Size = UDim2.fromOffset(3, 11)
		line.BackgroundColor3 = Color3.new(1, 1, 1)
		line.BorderSizePixel = 0
		line.Rotation = rotation
		line.ZIndex = 6
		line.Parent = hitmarker
		table.insert(hitmarkerLines, line)
	end

	createHitLine("TopLeft", 0.31, 0.31, -45)
	createHitLine("TopRight", 0.69, 0.31, 45)
	createHitLine("BottomLeft", 0.31, 0.69, 45)
	createHitLine("BottomRight", 0.69, 0.69, -45)

	local dot = Instance.new("Frame")
	dot.Name = "CursorDot"
	dot.AnchorPoint = Vector2.new(0.5, 0.5)
	dot.Position = UDim2.fromScale(0.5, 0.5)
	dot.Size = UDim2.fromOffset(6, 6)
	dot.BackgroundColor3 = Color3.new(1, 1, 1)
	dot.BorderSizePixel = 0
	dot.Visible = false
	dot.ZIndex = 6
	dot.Parent = gui

	local dotCorner = Instance.new("UICorner")
	dotCorner.CornerRadius = UDim.new(1, 0)
	dotCorner.Parent = dot

	local frame = Instance.new("Frame")
	frame.Name = "HullFrame"
	frame.AnchorPoint = Vector2.new(0.5, 1)
	frame.Position = UDim2.new(0.5, 0, 1, -86)
	frame.Size = UDim2.fromOffset(200, 40)
	frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	frame.BackgroundTransparency = 0.35
	frame.Visible = false
	frame.Parent = gui

	local label = Instance.new("TextLabel")
	label.Name = "HullLabel"
	label.Size = UDim2.fromScale(1, 1)
	label.BackgroundTransparency = 1
	label.TextColor3 = Color3.new(1, 1, 1)
	label.TextScaled = false
	label.TextSize = 20
	label.Font = Enum.Font.Code
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.Text = "Hull: -- / --"
	label.Parent = frame

	local shieldStatusFrame = Instance.new("Frame")
	shieldStatusFrame.Name = "ShieldFrame"
	shieldStatusFrame.AnchorPoint = Vector2.new(0.5, 1)
	shieldStatusFrame.Position = UDim2.new(0.5, 0, 1, -122)
	shieldStatusFrame.Size = UDim2.fromOffset(220, 28)
	shieldStatusFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	shieldStatusFrame.BackgroundTransparency = 0.35
	shieldStatusFrame.Visible = false
	shieldStatusFrame.Parent = gui

	local shieldBar = Instance.new("Frame")
	shieldBar.Name = "ShieldBar"
	shieldBar.Position = UDim2.fromOffset(8, 7)
	shieldBar.Size = UDim2.fromOffset(204, 14)
	shieldBar.BackgroundColor3 = Color3.fromRGB(22, 26, 42)
	shieldBar.BorderSizePixel = 0
	shieldBar.Parent = shieldStatusFrame

	local shieldBarFill = Instance.new("Frame")
	shieldBarFill.Name = "Fill"
	shieldBarFill.Size = UDim2.fromScale(0, 1)
	shieldBarFill.BackgroundColor3 = SHIELD_HEALTHY_COLOR
	shieldBarFill.BorderSizePixel = 0
	shieldBarFill.Parent = shieldBar

	local shieldText = Instance.new("TextLabel")
	shieldText.Name = "ShieldLabel"
	shieldText.AnchorPoint = Vector2.new(1, 0.5)
	shieldText.Position = UDim2.fromScale(1, 0.5)
	shieldText.Size = UDim2.fromOffset(140, 24)
	shieldText.BackgroundTransparency = 1
	shieldText.TextColor3 = Color3.fromRGB(160, 196, 255)
	shieldText.TextScaled = false
	shieldText.TextSize = 14
	shieldText.Font = Enum.Font.Code
	shieldText.TextXAlignment = Enum.TextXAlignment.Right
	shieldText.Text = "Shield: -- / --"
	shieldText.Parent = shieldStatusFrame

	local weaponHeatFrame = Instance.new("Frame")
	weaponHeatFrame.Name = "HeatFrame"
	weaponHeatFrame.AnchorPoint = Vector2.new(0.5, 1)
	weaponHeatFrame.Position = UDim2.new(0.5, 0, 1, -46)
	weaponHeatFrame.Size = UDim2.fromOffset(220, 28)
	weaponHeatFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	weaponHeatFrame.BackgroundTransparency = 0.35
	weaponHeatFrame.Visible = false
	weaponHeatFrame.Parent = gui

	local heatBar = Instance.new("Frame")
	heatBar.Name = "HeatBar"
	heatBar.Position = UDim2.fromOffset(8, 7)
	heatBar.Size = UDim2.fromOffset(204, 14)
	heatBar.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	heatBar.BorderSizePixel = 0
	heatBar.Parent = weaponHeatFrame

	local fill = Instance.new("Frame")
	fill.Name = "Fill"
	fill.Size = UDim2.fromScale(0, 1)
	fill.BackgroundColor3 = Color3.fromRGB(230, 230, 230)
	fill.BorderSizePixel = 0
	fill.Parent = heatBar

	local heatText = Instance.new("TextLabel")
	heatText.Name = "HeatLabel"
	heatText.AnchorPoint = Vector2.new(1, 0.5)
	heatText.Position = UDim2.fromScale(1, 0.5)
	heatText.Size = UDim2.fromOffset(120, 24)
	heatText.BackgroundTransparency = 1
	heatText.TextColor3 = Color3.new(1, 1, 1)
	heatText.TextScaled = false
	heatText.TextSize = 14
	heatText.Font = Enum.Font.Code
	heatText.TextXAlignment = Enum.TextXAlignment.Right
	heatText.Text = "Heat: 0%"
	heatText.Parent = weaponHeatFrame

	local weaponAmmoFrame = Instance.new("Frame")
	weaponAmmoFrame.Name = "AmmoFrame"
	weaponAmmoFrame.AnchorPoint = Vector2.new(0.5, 1)
	weaponAmmoFrame.Position = UDim2.new(0.5, 0, 1, -46)
	weaponAmmoFrame.Size = UDim2.fromOffset(220, 28)
	weaponAmmoFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	weaponAmmoFrame.BackgroundTransparency = 0.35
	weaponAmmoFrame.Visible = false
	weaponAmmoFrame.Parent = gui

	local ammoText = Instance.new("TextLabel")
	ammoText.Name = "AmmoLabel"
	ammoText.Size = UDim2.fromScale(1, 1)
	ammoText.BackgroundTransparency = 1
	ammoText.TextColor3 = Color3.fromRGB(235, 235, 235)
	ammoText.TextScaled = false
	ammoText.TextSize = 14
	ammoText.Font = Enum.Font.Code
	ammoText.TextXAlignment = Enum.TextXAlignment.Center
	ammoText.Text = "Ammo: -- / --"
	ammoText.Parent = weaponAmmoFrame

	local weaponsReadyLabel = Instance.new("TextLabel")
	weaponsReadyLabel.Name = "WeaponsReadyLabel"
	weaponsReadyLabel.AnchorPoint = Vector2.new(0.5, 1)
	weaponsReadyLabel.Position = UDim2.new(0.5, 0, 1, -104)
	weaponsReadyLabel.Size = UDim2.fromOffset(300, 32)
	weaponsReadyLabel.BackgroundTransparency = 1
	weaponsReadyLabel.Text = "WEAPONS READY"
	weaponsReadyLabel.TextColor3 = Color3.fromRGB(134, 255, 155)
	weaponsReadyLabel.TextTransparency = 1
	weaponsReadyLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
	weaponsReadyLabel.TextStrokeTransparency = 0.45
	weaponsReadyLabel.Font = Enum.Font.GothamBold
	weaponsReadyLabel.TextScaled = true
	weaponsReadyLabel.Visible = false
	weaponsReadyLabel.ZIndex = 8
	weaponsReadyLabel.Parent = gui

	screenGui = gui
	crosshairLabel = crosshair
	hitmarkerFrame = hitmarker
	cursorDot = dot
	hpFrame = frame
	hpLabel = label
	shieldFrame = shieldStatusFrame
	shieldFill = shieldBarFill
	shieldLabel = shieldText
	ammoFrame = weaponAmmoFrame
	ammoLabel = ammoText
	heatFrame = weaponHeatFrame
	heatFill = fill
	heatLabel = heatText
	readyLabel = weaponsReadyLabel
	lockReadyLabel = lockReadyText
	lockReticleFrame = lockReticle
	leadingIndicatorDot = leadDot
end

function CombatHUD.setZoomVignette(intensity: number)
	local clamped = math.clamp(intensity, 0, 1)
	local edgeOpacity = clamped * VIGNETTE_MAX_OPACITY
	local edgeTransparency = 1 - edgeOpacity
	local visible = clamped > 0.01

	for _, edge in ipairs(vignetteEdges) do
		edge.Visible = visible
		edge.BackgroundTransparency = edgeTransparency
	end
end

function CombatHUD.showCrosshair(visible: boolean)
	if crosshairLabel ~= nil then
		crosshairLabel.Visible = visible
		if not visible then
			crosshairLabel.TextColor3 = Color3.new(1, 1, 1)
		end
	end
	if cursorDot ~= nil then
		cursorDot.Visible = visible
		if not visible then
			cursorDot.BackgroundColor3 = Color3.new(1, 1, 1)
		end
	end
	if not visible then
		CombatHUD.showLockReady(false)
		CombatHUD.showLockReticle(false)
		CombatHUD.showLeadingIndicator(false)
	end
end

function CombatHUD.showLockReady(visible: boolean)
	if lockReadyLabel ~= nil then
		lockReadyLabel.Visible = visible
	end
end

function CombatHUD.showLockReticle(visible: boolean)
	if lockReticleFrame ~= nil then
		lockReticleFrame.Visible = visible
	end
end

function CombatHUD.setLockReticleScreenPosition(position: Vector2)
	if lockReticleFrame == nil then
		return
	end
	lockReticleFrame.Position = UDim2.fromOffset(position.X, position.Y)
end

function CombatHUD.showLeadingIndicator(visible: boolean)
	if leadingIndicatorDot ~= nil then
		leadingIndicatorDot.Visible = visible
	end
end

function CombatHUD.setLeadingIndicatorScreenPosition(position: Vector2)
	if leadingIndicatorDot == nil then
		return
	end
	leadingIndicatorDot.Position = UDim2.fromOffset(position.X, position.Y)
end

function CombatHUD.setCrosshairPosition(screenPosition: Vector2)
	if crosshairLabel == nil then
		return
	end

	crosshairLabel.Position = UDim2.fromOffset(math.floor(screenPosition.X + 0.5), math.floor(screenPosition.Y + 0.5))
end

function CombatHUD.setCursorDotPosition(screenPosition: Vector2)
	if cursorDot == nil then
		return
	end

	cursorDot.Position = UDim2.fromOffset(math.floor(screenPosition.X + 0.5), math.floor(screenPosition.Y + 0.5))
end

function CombatHUD.showHP(entityId: string)
	currentEntityId = entityId
	if hpFrame ~= nil then
		hpFrame.Visible = true
	end
	updateHpLabel(entityId)

	local shieldData = shieldCache[entityId]
	if shieldData ~= nil then
		CombatHUD.setShield(shieldData.currentShield, shieldData.maxShield)
	end
end

function CombatHUD.hideHP()
	currentEntityId = nil
	if hpFrame ~= nil then
		hpFrame.Visible = false
	end
end

function CombatHUD.showShield(visible: boolean)
	if shieldFrame ~= nil then
		shieldFrame.Visible = visible
	end
end

function CombatHUD.showAmmo(visible: boolean)
	if ammoFrame ~= nil then
		ammoFrame.Visible = visible
	end
end

function CombatHUD.setAmmo(currentAmmo: number, maxAmmo: number)
	local label = ammoLabel
	if label == nil then
		return
	end

	local clampedMax = math.max(0, math.floor(maxAmmo + 0.5))
	local clampedCurrent = math.clamp(math.floor(currentAmmo + 0.5), 0, math.max(clampedMax, 0))
	if clampedCurrent <= 0 then
		label.Text = string.format("Ammo: 0 / %d (EMPTY)", clampedMax)
		label.TextColor3 = Color3.fromRGB(255, 110, 110)
	else
		label.Text = string.format("Ammo: %d / %d", clampedCurrent, clampedMax)
		label.TextColor3 = Color3.fromRGB(235, 235, 235)
	end
end

function CombatHUD.setShield(currentShield: number, maxShield: number)
	local fill = shieldFill
	local label = shieldLabel
	if fill == nil or label == nil then
		return
	end

	local clampedMax = math.max(1, maxShield)
	local clampedCurrent = math.clamp(currentShield, 0, clampedMax)
	local ratio = math.clamp(clampedCurrent / clampedMax, 0, 1)
	fill.Size = UDim2.fromScale(ratio, 1)

	local fillColor = SHIELD_HEALTHY_COLOR
	if ratio < SHIELD_LOW_THRESHOLD then
		local pulse = 0.5 + 0.5 * math.sin(tick() * SHIELD_PULSE_SPEED)
		fillColor = SHIELD_HEALTHY_COLOR:Lerp(SHIELD_LOW_COLOR, pulse)
	end
	fill.BackgroundColor3 = fillColor

	label.Text = string.format("Shield: %d / %d", math.floor(clampedCurrent + 0.5), math.floor(clampedMax + 0.5))
end

function CombatHUD.showHeat(visible: boolean)
	if heatFrame ~= nil then
		heatFrame.Visible = visible
	end
	if not visible and readyLabel ~= nil then
		readyLabel.Visible = false
		lastOverheatWarningAt = 0
		wasOverheatedLastUpdate = false
	end
end

function CombatHUD.setWeaponHeat(currentHeat: number, maxHeat: number, overheated: boolean)
	local fill = heatFill
	local label = heatLabel
	if fill == nil or label == nil then
		return
	end

	local clampedMax = math.max(1, maxHeat)
	local ratio = math.clamp(currentHeat / clampedMax, 0, 1)
	fill.Size = UDim2.fromScale(ratio, 1)

	local fillColor = Color3.fromRGB(228, 228, 228)
	if overheated then
		fillColor = Color3.fromRGB(255, 80, 80)
	elseif ratio >= 0.8 then
		fillColor = Color3.fromRGB(255, 150, 66)
	elseif ratio >= 0.55 then
		fillColor = Color3.fromRGB(255, 214, 102)
	end
	fill.BackgroundColor3 = fillColor

	local percentage = math.floor(ratio * 100 + 0.5)
	if overheated then
		label.Text = string.format("Heat: %d%% (OVERHEAT)", percentage)
		label.TextColor3 = Color3.fromRGB(255, 120, 120)
	else
		label.Text = string.format("Heat: %d%%", percentage)
		label.TextColor3 = Color3.fromRGB(235, 235, 235)
	end

	if heatFrame ~= nil then
		if overheated then
			heatFrame.BackgroundTransparency = 0.16
		elseif ratio >= HEAT_WARNING_THRESHOLD then
			local pulse = 0.5 + 0.5 * math.sin(tick() * HEAT_PULSE_SPEED)
			heatFrame.BackgroundTransparency = math.clamp(0.34 - pulse * 0.14, 0.18, 0.46)
		else
			heatFrame.BackgroundTransparency = 0.35
		end
	end

	local criticalAlpha = math.clamp((ratio - HEAT_WARNING_THRESHOLD) / (1 - HEAT_WARNING_THRESHOLD), 0, 1)
	local crosshairColor = Color3.new(1, 1, 1)
	if overheated then
		crosshairColor = Color3.fromRGB(255, 78, 78)
	elseif criticalAlpha > 0 then
		local g = math.floor(245 - criticalAlpha * 135 + 0.5)
		local b = math.floor(240 - criticalAlpha * 185 + 0.5)
		crosshairColor = Color3.fromRGB(255, math.clamp(g, 70, 255), math.clamp(b, 55, 255))
	end

	if crosshairLabel ~= nil then
		crosshairLabel.TextColor3 = crosshairColor
	end
	if cursorDot ~= nil then
		cursorDot.BackgroundColor3 = crosshairColor
	end

	if ratio >= HEAT_WARNING_THRESHOLD and not overheated then
		local now = tick()
		if now - lastOverheatWarningAt >= HEAT_WARNING_SOUND_COOLDOWN then
			lastOverheatWarningAt = now
			playOverheatWarningSound()
		end
	end

	if overheated and not wasOverheatedLastUpdate then
		playOverheatSound()
	end
	wasOverheatedLastUpdate = overheated
end

local function showTransientStatusCue(message: string, textColor: Color3, textStrokeTransparency: number)
	local label = readyLabel
	if label == nil then
		return
	end

	readyCueToken += 1
	local token = readyCueToken
	label.Visible = true
	label.Text = message
	label.TextColor3 = textColor
	label.TextTransparency = 1
	label.TextStrokeTransparency = 1

	local fadeIn = TweenService:Create(label, TweenInfo.new(0.08, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		TextTransparency = 0.05,
		TextStrokeTransparency = textStrokeTransparency,
	})
	fadeIn:Play()

	task.delay(0.55, function()
		if token ~= readyCueToken or label.Parent == nil then
			return
		end
		local fadeOut = TweenService:Create(label, TweenInfo.new(0.22, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
			TextTransparency = 1,
			TextStrokeTransparency = 1,
		})
		fadeOut:Play()
		fadeOut.Completed:Connect(function()
			if token == readyCueToken and label.Parent ~= nil then
				label.Visible = false
			end
		end)
	end)
end

function CombatHUD.onWeaponRecoveredCue()
	playOverheatWarningSound()
	showTransientStatusCue("WEAPONS READY", Color3.fromRGB(134, 255, 155), 0.35)
end

function CombatHUD.onLockLostCue(reason: string?)
	local message = "TARGET LOCK LOST"
	if reason == "range" then
		message = "TARGET LOCK LOST: OUT OF RANGE"
	elseif reason == "arc" then
		message = "TARGET LOCK LOST: ARC LOST"
	elseif reason == "dead" or reason == "missing" or reason == "missing_target" then
		message = "TARGET LOCK LOST: TARGET LOST"
	end

	showTransientStatusCue(message, Color3.fromRGB(255, 176, 124), 0.32)
end

function CombatHUD.onDamageApplied(payload)
	if type(payload) ~= "table" then
		return
	end

	local entityId = payload.entityId
	local newHP = payload.newHP
	local maxHP = payload.maxHP
	if type(entityId) ~= "string" or type(newHP) ~= "number" or type(maxHP) ~= "number" then
		return
	end

	hpCache[entityId] = {
		currentHP = newHP,
		maxHP = maxHP,
	}

	local newShieldHP = payload.newShieldHP
	local maxShieldHP = payload.maxShieldHP
	if type(newShieldHP) == "number" and type(maxShieldHP) == "number" and maxShieldHP > 0 then
		shieldCache[entityId] = {
			currentShield = newShieldHP,
			maxShield = maxShieldHP,
		}
		if currentEntityId == entityId then
			CombatHUD.setShield(newShieldHP, maxShieldHP)
		end
	end

	if currentEntityId == entityId then
		updateHpLabel(entityId)
	end
end

function CombatHUD.onEntityDestroyed(entityId: string)
	if currentEntityId == entityId and hpLabel ~= nil then
		hpLabel.Text = "Hull: DESTROYED"
	end
	if currentEntityId == entityId then
		local existingShield = shieldCache[entityId]
		if existingShield ~= nil then
			CombatHUD.setShield(0, existingShield.maxShield)
		end
	end
end

function CombatHUD.onEntityRespawned(payload)
	if type(payload) ~= "table" then
		return
	end

	local entityId = payload.entityId
	local hullHP = payload.hullHP
	if type(entityId) ~= "string" or type(hullHP) ~= "number" then
		return
	end

	local existing = hpCache[entityId]
	hpCache[entityId] = {
		currentHP = hullHP,
		maxHP = existing and existing.maxHP or hullHP,
	}

	local shieldHP = payload.shieldHP
	if type(shieldHP) == "number" and shieldHP > 0 then
		shieldCache[entityId] = {
			currentShield = shieldHP,
			maxShield = shieldHP,
		}
		if currentEntityId == entityId then
			CombatHUD.setShield(shieldHP, shieldHP)
		end
	end

	if currentEntityId == entityId then
		updateHpLabel(entityId)
	end
end

function CombatHUD.onHitConfirm(payload)
	if type(payload) ~= "table" then
		return
	end

	local isKill = payload.isKill
	if type(isKill) ~= "boolean" then
		isKill = false
	end

	playHitmarkerSound()
	if isKill then
		playKillConfirmSound()
	end

	local marker = hitmarkerFrame
	if marker == nil then
		return
	end

	if crosshairLabel ~= nil then
		marker.Position = crosshairLabel.Position
	else
		marker.Position = UDim2.fromScale(0.5, 0.5)
	end

	local markerColor = if isKill then Color3.fromRGB(255, 110, 110) else Color3.fromRGB(245, 245, 245)
	for _, line in ipairs(hitmarkerLines) do
		line.BackgroundColor3 = markerColor
	end

	if hitmarkerTween ~= nil then
		hitmarkerTween:Cancel()
	end
	marker.Size = UDim2.fromOffset(36, 36)
	hitmarkerTween = TweenService:Create(marker, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
		Size = UDim2.fromOffset(28, 28),
	})
	hitmarkerTween:Play()
	marker.Visible = true

	hitmarkerToken += 1
	local token = hitmarkerToken
	task.delay(0.1, function()
		if token == hitmarkerToken and marker.Parent ~= nil then
			marker.Visible = false
		end
	end)
end

return CombatHUD
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="29">
          <Properties>
            <string name="Name">Projectiles</string>
          </Properties>
          <Item class="ModuleScript" referent="30">
            <Properties>
              <string name="Name">ProjectileVisuals</string>
              <string name="Source"><![CDATA[--!strict

local Debris = game:GetService("Debris")
local CollectionService = game:GetService("CollectionService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local sharedRoot = ReplicatedStorage:WaitForChild("CombatFramework")
local CombatConfig = require(sharedRoot:WaitForChild("CombatConfig"))
local CombatTypes = require(sharedRoot:WaitForChild("CombatTypes"))

type ProjectileFiredPayload = CombatTypes.ProjectileFiredPayload
type ProjectileImpactPayload = CombatTypes.ProjectileImpactPayload

type ProjectileVisualProfile = {
	boltLengthScale: number,
	boltWidthScale: number,
	bulletScale: number,
	trailWidthScale: number,
	lightBrightnessScale: number,
	lightRangeScale: number,
	whizPitchScale: number,
	impactScale: number,
	impactEmitScale: number,
}

type ActiveBolt = {
	boltPart: BasePart,
	bulletPart: BasePart?,
	origin: Vector3,
	direction: Vector3,
	speed: number,
	maxRange: number,
	createdAt: number,
	lastUpdatedAt: number,
	damageType: string?,
	targetEntityId: string?,
	homingTurnRate: number?,
	currentPosition: Vector3?,
}

local ProjectileVisuals = {}

local activeBolts: { [string]: ActiveBolt } = {}
local renderConnection: RBXScriptConnection? = nil
local projectileFiredConnection: RBXScriptConnection? = nil
local projectileImpactConnection: RBXScriptConnection? = nil
local boltFolder: Folder? = nil
local impactFolder: Folder? = nil
local warnedMissingTemplate = false
local warnedMissingImpactTemplate = false
local warnedMissingShieldImpactTemplate = false
local warnedMissingFireSoundTemplate = false
local warnedMissingFireSoundTemplateByDamageType: { [string]: boolean } = {}
local warnedMissingImpactSoundTemplate = false
local warnedMissingShieldImpactSoundTemplate = false
local warnedMissingShieldBreakSoundTemplate = false

local IMPACT_BURST_COUNTS: { [string]: number } = {
	Smoke = 18,
	Flash = 2,
	Sparks = 50,
	Explosion = 24,
}

local IMPACT_AUTO_DISABLE_TIME = 0.15
local IMPACT_CLEANUP_TIME = 5
local DEFAULT_VISUAL_PROFILE: ProjectileVisualProfile = {
	boltLengthScale = 1.0,
	boltWidthScale = 1.0,
	bulletScale = 1.0,
	trailWidthScale = 1.0,
	lightBrightnessScale = 1.0,
	lightRangeScale = 1.0,
	whizPitchScale = 1.0,
	impactScale = 1.0,
	impactEmitScale = 1.0,
}
local DAMAGE_TYPE_VISUAL_PROFILES: { [string]: ProjectileVisualProfile } = {
	blaster = DEFAULT_VISUAL_PROFILE,
	turbolaser = {
		boltLengthScale = 1.55,
		boltWidthScale = 1.8,
		bulletScale = 1.25,
		trailWidthScale = 1.9,
		lightBrightnessScale = 1.45,
		lightRangeScale = 1.35,
		whizPitchScale = 0.82,
		impactScale = 1.25,
		impactEmitScale = 1.35,
	},
	ion = {
		boltLengthScale = 1.15,
		boltWidthScale = 1.1,
		bulletScale = 1.05,
		trailWidthScale = 1.2,
		lightBrightnessScale = 1.25,
		lightRangeScale = 1.2,
		whizPitchScale = 1.2,
		impactScale = 1.1,
		impactEmitScale = 1.15,
	},
	proton_torpedo = {
		boltLengthScale = 2.2,
		boltWidthScale = 2.55,
		bulletScale = 2.0,
		trailWidthScale = 2.65,
		lightBrightnessScale = 1.95,
		lightRangeScale = 1.6,
		whizPitchScale = 0.7,
		impactScale = 1.85,
		impactEmitScale = 1.85,
	},
	concussion_missile = {
		boltLengthScale = 1.75,
		boltWidthScale = 2.0,
		bulletScale = 1.55,
		trailWidthScale = 2.2,
		lightBrightnessScale = 1.65,
		lightRangeScale = 1.45,
		whizPitchScale = 0.85,
		impactScale = 1.45,
		impactEmitScale = 1.5,
	},
}

local function getVisualProfileForDamageType(damageType: string?): ProjectileVisualProfile
	if type(damageType) == "string" then
		local mapped = DAMAGE_TYPE_VISUAL_PROFILES[damageType]
		if mapped ~= nil then
			return mapped
		end
	end
	return DEFAULT_VISUAL_PROFILE
end

local function scaleNumberSequence(sequence: NumberSequence, scale: number): NumberSequence
	local keypoints = sequence.Keypoints
	local scaledPoints: { NumberSequenceKeypoint } = table.create(#keypoints)
	for index, point in ipairs(keypoints) do
		scaledPoints[index] =
			NumberSequenceKeypoint.new(point.Time, math.max(0, point.Value * scale), math.max(0, point.Envelope * scale))
	end
	return NumberSequence.new(scaledPoints)
end

local function applyProjectilePartVisualProfile(
	part: BasePart,
	profile: ProjectileVisualProfile,
	isBolt: boolean
)
	if isBolt then
		part.Size = Vector3.new(
			part.Size.X * profile.boltWidthScale,
			part.Size.Y * profile.boltWidthScale,
			part.Size.Z * profile.boltLengthScale
		)
	else
		part.Size *= profile.bulletScale
	end

	for _, descendant in ipairs(part:GetDescendants()) do
		if descendant:IsA("Trail") then
			descendant.WidthScale = scaleNumberSequence(descendant.WidthScale, profile.trailWidthScale)
		elseif descendant:IsA("PointLight") then
			descendant.Brightness *= profile.lightBrightnessScale
			descendant.Range *= profile.lightRangeScale
		end
	end
end

local function ensureBoltFolder(): Folder
	if boltFolder ~= nil and boltFolder.Parent ~= nil then
		return boltFolder
	end

	local existing = Workspace:FindFirstChild("CombatBoltVisuals")
	if existing ~= nil and existing:IsA("Folder") then
		boltFolder = existing
		return existing
	end

	local folder = Instance.new("Folder")
	folder.Name = "CombatBoltVisuals"
	folder.Parent = Workspace
	boltFolder = folder
	return folder
end

local function ensureImpactFolder(): Folder
	if impactFolder ~= nil and impactFolder.Parent ~= nil then
		return impactFolder
	end

	local existing = Workspace:FindFirstChild("CombatImpactVisuals")
	if existing ~= nil and existing:IsA("Folder") then
		impactFolder = existing
		return existing
	end

	local folder = Instance.new("Folder")
	folder.Name = "CombatImpactVisuals"
	folder.Parent = Workspace
	impactFolder = folder
	return folder
end

local function destroyBolt(projectileId: string)
	local bolt = activeBolts[projectileId]
	if bolt == nil then
		return
	end

	if bolt.boltPart.Parent ~= nil then
		bolt.boltPart:Destroy()
	end
	if bolt.bulletPart ~= nil and bolt.bulletPart.Parent ~= nil then
		bolt.bulletPart:Destroy()
	end
	activeBolts[projectileId] = nil
end

local function getProjectileTemplateFolder(): Folder?
	local combatAssets = ReplicatedStorage:FindFirstChild("CombatAssets")
	if combatAssets == nil or not combatAssets:IsA("Folder") then
		return nil
	end

	local projectileTemplate = combatAssets:FindFirstChild("ProjectileTemplate")
	if projectileTemplate == nil or not projectileTemplate:IsA("Folder") then
		return nil
	end

	return projectileTemplate
end

local function getImpactTemplateFolder(impactType: string?): Folder?
	local combatAssets = ReplicatedStorage:FindFirstChild("CombatAssets")
	if combatAssets == nil or not combatAssets:IsA("Folder") then
		return nil
	end

	local impactParticles = combatAssets:FindFirstChild("ImpactParticles")
	if impactParticles == nil or not impactParticles:IsA("Folder") then
		return nil
	end

	local templateName = if impactType == "shield" then "shieldHit" else "bulletHit"
	local template = impactParticles:FindFirstChild(templateName)
	if template == nil or not template:IsA("Folder") then
		return nil
	end

	return template
end

local function getFirstSoundDescendant(folder: Folder): Sound?
	for _, child in ipairs(folder:GetChildren()) do
		if child:IsA("Sound") then
			return child
		end
	end

	return nil
end

local function getFireSoundTemplate(damageType: string?): Sound?
	local combatAssets = ReplicatedStorage:FindFirstChild("CombatAssets")
	if combatAssets == nil or not combatAssets:IsA("Folder") then
		return nil
	end

	local audioFolder = combatAssets:FindFirstChild("Audio")
	if audioFolder == nil or not audioFolder:IsA("Folder") then
		return nil
	end

	local fireFolder = audioFolder:FindFirstChild("Fire")
	if fireFolder == nil or not fireFolder:IsA("Folder") then
		return nil
	end

	if type(damageType) == "string" and damageType ~= "" then
		local damageTypeNode = fireFolder:FindFirstChild(damageType)
		if damageTypeNode ~= nil then
			if damageTypeNode:IsA("Sound") then
				return damageTypeNode
			end
			if damageTypeNode:IsA("Folder") then
				local typedSound = getFirstSoundDescendant(damageTypeNode)
				if typedSound ~= nil then
					return typedSound
				end
			end
		end
	end

	return getFirstSoundDescendant(fireFolder)
end

local function getImpactSoundTemplates(impactType: string?): { Sound }
	local templates: { Sound } = {}

	local combatAssets = ReplicatedStorage:FindFirstChild("CombatAssets")
	if combatAssets == nil or not combatAssets:IsA("Folder") then
		return templates
	end

	local audioFolder = combatAssets:FindFirstChild("Audio")
	if audioFolder == nil or not audioFolder:IsA("Folder") then
		return templates
	end

	local folderName = if impactType == "shield" then "ShieldImpact" else "Impact"
	local impactFolderAudio = audioFolder:FindFirstChild(folderName)
	if impactFolderAudio == nil or not impactFolderAudio:IsA("Folder") then
		return templates
	end

	for _, child in ipairs(impactFolderAudio:GetChildren()) do
		if child:IsA("Sound") then
			table.insert(templates, child)
		end
	end

	return templates
end

local function getShieldBreakSoundTemplates(): { Sound }
	local templates: { Sound } = {}

	local combatAssets = ReplicatedStorage:FindFirstChild("CombatAssets")
	if combatAssets == nil or not combatAssets:IsA("Folder") then
		return templates
	end

	local audioFolder = combatAssets:FindFirstChild("Audio")
	if audioFolder == nil or not audioFolder:IsA("Folder") then
		return templates
	end

	local breakFolder = audioFolder:FindFirstChild("ShieldBreak")
	if breakFolder == nil or not breakFolder:IsA("Folder") then
		return templates
	end

	for _, child in ipairs(breakFolder:GetChildren()) do
		if child:IsA("Sound") then
			table.insert(templates, child)
		end
	end

	return templates
end

local function prepareVisualPart(part: BasePart)
	part.Anchored = true
	part.CanCollide = false
	part.CanQuery = false
	part.CanTouch = false
	part.CastShadow = false
end

local function playFireSoundAt(position: Vector3, damageType: string?)
	local soundTemplate = getFireSoundTemplate(damageType)
	if soundTemplate == nil then
		local damageTypeKey = if type(damageType) == "string" and damageType ~= "" then damageType else "default"
		if damageTypeKey ~= "default" then
			if not warnedMissingFireSoundTemplateByDamageType[damageTypeKey] then
				warn(string.format(
					"[P3_AUDIO] Missing fire sound for damageType '%s' in ReplicatedStorage.CombatAssets.Audio.Fire.%s (or shared Audio.Fire fallback)",
					damageTypeKey,
					damageTypeKey
				))
				warnedMissingFireSoundTemplateByDamageType[damageTypeKey] = true
			end
		elseif not warnedMissingFireSoundTemplate then
			warn("[P1_AUDIO] Missing fire sound template in ReplicatedStorage.CombatAssets.Audio.Fire")
			warnedMissingFireSoundTemplate = true
		end
		return
	end

	local soundPart = Instance.new("Part")
	soundPart.Name = "ShotSound"
	soundPart.Size = Vector3.new(0.25, 0.25, 0.25)
	soundPart.Transparency = 1
	soundPart.Anchored = true
	soundPart.CanCollide = false
	soundPart.CanQuery = false
	soundPart.CanTouch = false
	soundPart.CFrame = CFrame.new(position)
	soundPart.Parent = ensureBoltFolder()

	local shot = soundTemplate:Clone()
	shot.Looped = false
	shot.Parent = soundPart
	shot:Play()

	local cleanupDelay = math.max(1, shot.TimeLength + 0.15)
	Debris:AddItem(soundPart, cleanupDelay)
end

local function playImpactSoundAt(position: Vector3, impactType: string?)
	local soundTemplates = getImpactSoundTemplates(impactType)
	if #soundTemplates == 0 then
		if impactType == "shield" then
			if not warnedMissingShieldImpactSoundTemplate then
				warn("[P2_AUDIO] Missing shield impact sound template in ReplicatedStorage.CombatAssets.Audio.ShieldImpact")
				warnedMissingShieldImpactSoundTemplate = true
			end
		elseif not warnedMissingImpactSoundTemplate then
			warn("[P1_AUDIO] Missing impact sound template in ReplicatedStorage.CombatAssets.Audio.Impact")
			warnedMissingImpactSoundTemplate = true
		end
		return
	end

	local soundPart = Instance.new("Part")
	soundPart.Name = "ImpactSound"
	soundPart.Size = Vector3.new(0.25, 0.25, 0.25)
	soundPart.Transparency = 1
	soundPart.Anchored = true
	soundPart.CanCollide = false
	soundPart.CanQuery = false
	soundPart.CanTouch = false
	soundPart.CFrame = CFrame.new(position)
	soundPart.Parent = ensureImpactFolder()

	local cleanupDelay = 1
	for _, soundTemplate in ipairs(soundTemplates) do
		local impact = soundTemplate:Clone()
		impact.Looped = false
		impact.Parent = soundPart
		impact:Play()
		cleanupDelay = math.max(cleanupDelay, impact.TimeLength + 0.15)
	end

	Debris:AddItem(soundPart, cleanupDelay)
end

local function playShieldBreakSoundAt(position: Vector3)
	local soundTemplates = getShieldBreakSoundTemplates()
	if #soundTemplates == 0 then
		soundTemplates = getImpactSoundTemplates("shield")
		if #soundTemplates == 0 then
			if not warnedMissingShieldBreakSoundTemplate then
				warn("[P2_AUDIO] Missing shield break sound template in ReplicatedStorage.CombatAssets.Audio.ShieldBreak")
				warnedMissingShieldBreakSoundTemplate = true
			end
			return
		end
	end

	local soundPart = Instance.new("Part")
	soundPart.Name = "ShieldBreakSound"
	soundPart.Size = Vector3.new(0.25, 0.25, 0.25)
	soundPart.Transparency = 1
	soundPart.Anchored = true
	soundPart.CanCollide = false
	soundPart.CanQuery = false
	soundPart.CanTouch = false
	soundPart.CFrame = CFrame.new(position)
	soundPart.Parent = ensureImpactFolder()

	local cleanupDelay = 1
	for _, soundTemplate in ipairs(soundTemplates) do
		local breakSound = soundTemplate:Clone()
		breakSound.Looped = false
		breakSound.Parent = soundPart
		breakSound:Play()
		cleanupDelay = math.max(cleanupDelay, breakSound.TimeLength + 0.15)
	end

	Debris:AddItem(soundPart, cleanupDelay)
end

local function getBurstCount(emitter: ParticleEmitter): number
	local attributeBurstCount = emitter:GetAttribute("EmitCount")
	if type(attributeBurstCount) == "number" then
		return math.max(0, math.floor(attributeBurstCount + 0.5))
	end

	local mapped = IMPACT_BURST_COUNTS[emitter.Name]
	if mapped ~= nil then
		return mapped
	end

	return 12
end

local function spawnImpactEffect(hitPosition: Vector3, hitNormal: Vector3, impactType: string?, damageType: string?)
	local visualProfile = getVisualProfileForDamageType(damageType)
	local impactTemplate = getImpactTemplateFolder(impactType)
	if impactTemplate == nil then
		if impactType == "shield" then
			if not warnedMissingShieldImpactTemplate then
				warn("[P2_IMPACT] Missing ReplicatedStorage.CombatAssets.ImpactParticles.shieldHit template folder.")
				warnedMissingShieldImpactTemplate = true
			end
		elseif not warnedMissingImpactTemplate then
			warn("[P1_IMPACT] Missing ReplicatedStorage.CombatAssets.ImpactParticles.bulletHit template folder.")
			warnedMissingImpactTemplate = true
		end
		return
	end

	local normal = hitNormal
	if normal.Magnitude <= 0.001 then
		normal = Vector3.new(0, 1, 0)
	else
		normal = normal.Unit
	end

	local effectPart = Instance.new("Part")
	effectPart.Name = if impactType == "shield" then "ShieldImpact" else "BulletImpact"
	effectPart.Transparency = 1
	effectPart.Size = Vector3.new(2, 2, 2) * visualProfile.impactScale
	effectPart.Anchored = true
	effectPart.CanCollide = false
	effectPart.CanTouch = false
	effectPart.CanQuery = false
	effectPart.CastShadow = false
	effectPart.CFrame = CFrame.lookAt(hitPosition + normal * 0.05, hitPosition + normal * 1.05)
	effectPart.Parent = ensureImpactFolder()

	local attachmentMap: { [Attachment]: Attachment } = {}
	for _, descendant in ipairs(impactTemplate:GetDescendants()) do
		if descendant:IsA("Attachment") then
			local attachmentClone = descendant:Clone()
			attachmentClone.Parent = effectPart
			attachmentMap[descendant] = attachmentClone
		end
	end

	local spawnedEffects: { Instance } = {}
	for _, descendant in ipairs(impactTemplate:GetDescendants()) do
		if descendant:IsA("ParticleEmitter") or descendant:IsA("Sound") or descendant:IsA("PointLight") then
			local effectClone = descendant:Clone()
			local targetParent: Instance = effectPart
			local templateParent = descendant.Parent
			if templateParent ~= nil and templateParent:IsA("Attachment") then
				local mappedAttachment = attachmentMap[templateParent]
				if mappedAttachment ~= nil then
					targetParent = mappedAttachment
				end
			end

			effectClone.Parent = targetParent
			table.insert(spawnedEffects, effectClone)
		end
	end

	for _, effect in ipairs(spawnedEffects) do
		if effect:IsA("ParticleEmitter") then
			effect.Size = scaleNumberSequence(effect.Size, visualProfile.impactScale)
			effect:Emit(math.max(0, math.floor(getBurstCount(effect) * visualProfile.impactEmitScale + 0.5)))
		elseif effect:IsA("Sound") then
			effect:Play()
		elseif effect:IsA("PointLight") then
			effect.Range *= visualProfile.impactScale
			effect.Brightness *= visualProfile.lightBrightnessScale
			effect.Enabled = true
		end
	end

	task.delay(IMPACT_AUTO_DISABLE_TIME, function()
		if effectPart.Parent == nil then
			return
		end

		for _, effect in ipairs(spawnedEffects) do
			if effect.Parent ~= nil and (effect:IsA("ParticleEmitter") or effect:IsA("PointLight")) then
				effect.Enabled = false
			end
		end
	end)

	Debris:AddItem(effectPart, IMPACT_CLEANUP_TIME)
end

local function playWhizSound(part: BasePart, profile: ProjectileVisualProfile)
	local whiz = part:FindFirstChild("Whiz", true)
	if whiz ~= nil and whiz:IsA("Sound") then
		whiz.PlaybackSpeed *= profile.whizPitchScale
		whiz:Play()
	end
end

local function applyBoltVisualColor(boltPart: BasePart, boltColor: Color3?)
	if boltColor == nil then
		return
	end

	boltPart.Color = boltColor
	for _, descendant in ipairs(boltPart:GetDescendants()) do
		if descendant:IsA("Trail") and descendant.Name == "BulletTrailColor" then
			descendant.Color = ColorSequence.new(boltColor)
		elseif descendant:IsA("PointLight") and descendant.Name == "PointLight" then
			descendant.Color = boltColor
		end
	end
end

local function createFallbackBoltPart(
	projectileId: string,
	boltColor: Color3?,
	visualProfile: ProjectileVisualProfile
): BasePart
	local boltPart = Instance.new("Part")
	boltPart.Name = "Bolt_" .. projectileId
	boltPart.Size = Vector3.new(CombatConfig.BoltWidth, CombatConfig.BoltWidth, CombatConfig.BoltLength)
	boltPart.Color = if boltColor ~= nil then boltColor else CombatConfig.BoltColor
	boltPart.Material = CombatConfig.BoltMaterial
	prepareVisualPart(boltPart)
	applyProjectilePartVisualProfile(boltPart, visualProfile, true)
	boltPart.Parent = ensureBoltFolder()
	return boltPart
end

local function createVisualPartsFromTemplate(
	projectileId: string,
	boltColor: Color3?,
	damageType: string?
): (BasePart, BasePart?)
	local visualProfile = getVisualProfileForDamageType(damageType)
	local templateFolder = getProjectileTemplateFolder()
	if templateFolder == nil then
		if not warnedMissingTemplate then
			warn("[P1_VISUAL] Missing ReplicatedStorage.CombatAssets.ProjectileTemplate. Using fallback bolt.")
			warnedMissingTemplate = true
		end
		return createFallbackBoltPart(projectileId, boltColor, visualProfile), nil
	end

	local boltTemplate = templateFolder:FindFirstChild("Bolt")
	if boltTemplate == nil or not boltTemplate:IsA("BasePart") then
		if not warnedMissingTemplate then
			warn("[P1_VISUAL] Missing template part 'Bolt'. Using fallback bolt.")
			warnedMissingTemplate = true
		end
		return createFallbackBoltPart(projectileId, boltColor, visualProfile), nil
	end

	local boltPart = boltTemplate:Clone()
	boltPart.Name = "Bolt_" .. projectileId
	prepareVisualPart(boltPart)
	applyProjectilePartVisualProfile(boltPart, visualProfile, true)
	boltPart.Parent = ensureBoltFolder()
	applyBoltVisualColor(boltPart, boltColor)
	playWhizSound(boltPart, visualProfile)

	local bulletPart: BasePart? = nil
	local bulletTemplate = templateFolder:FindFirstChild("Bullet")
	if bulletTemplate ~= nil and bulletTemplate:IsA("BasePart") then
		bulletPart = bulletTemplate:Clone()
		bulletPart.Name = "Bullet_" .. projectileId
		prepareVisualPart(bulletPart)
		applyProjectilePartVisualProfile(bulletPart, visualProfile, false)
		bulletPart.Parent = ensureBoltFolder()
	end

	return boltPart, bulletPart
end

local function findEntityModelById(entityId: string): Model?
	for _, tagged in ipairs(CollectionService:GetTagged("CombatEntity")) do
		if tagged:IsA("Model") and tagged:GetAttribute("EntityId") == entityId then
			return tagged
		end
	end
	return nil
end

local function rotateDirectionToward(currentDirection: Vector3, targetDirection: Vector3, maxTurnRadians: number): Vector3
	if currentDirection.Magnitude < 1e-4 then
		return targetDirection.Unit
	end
	if targetDirection.Magnitude < 1e-4 then
		return currentDirection.Unit
	end
	if maxTurnRadians <= 0 then
		return currentDirection.Unit
	end

	local currentUnit = currentDirection.Unit
	local targetUnit = targetDirection.Unit
	local dot = math.clamp(currentUnit:Dot(targetUnit), -1, 1)
	local angle = math.acos(dot)
	if angle <= maxTurnRadians then
		return targetUnit
	end

	local alpha = maxTurnRadians / math.max(angle, 1e-4)
	return (currentUnit:Lerp(targetUnit, alpha)).Unit
end

local function onRenderStepped()
	local now = tick()
	for projectileId, bolt in pairs(activeBolts) do
		local dt = math.max(0, now - bolt.lastUpdatedAt)
		bolt.lastUpdatedAt = now
		local position: Vector3

		local homingActive = type(bolt.targetEntityId) == "string"
			and type(bolt.homingTurnRate) == "number"
			and (bolt.homingTurnRate :: number) > 0
		if homingActive then
			local previousPosition = bolt.currentPosition or bolt.origin
			local targetModel = findEntityModelById(bolt.targetEntityId :: string)
			if targetModel ~= nil then
				local toTarget = targetModel:GetPivot().Position - previousPosition
				if toTarget.Magnitude > 1e-4 then
					bolt.direction = rotateDirectionToward(
						bolt.direction.Unit,
						toTarget.Unit,
						math.rad(bolt.homingTurnRate :: number) * dt
					)
				end
			end

			position = previousPosition + bolt.direction.Unit * bolt.speed * dt
			bolt.currentPosition = position
		else
			local elapsed = now - bolt.createdAt
			local distance = bolt.speed * elapsed
			position = bolt.origin + bolt.direction * distance
		end

		local traveledDistance = (position - bolt.origin).Magnitude
		if traveledDistance >= bolt.maxRange then
			destroyBolt(projectileId)
		else
			local projectileCFrame = CFrame.lookAt(position, position + bolt.direction)
			bolt.boltPart.CFrame = projectileCFrame
			if bolt.bulletPart ~= nil then
				bolt.bulletPart.CFrame = projectileCFrame
			end
		end
	end
end

local function onProjectileFired(payload: ProjectileFiredPayload)
	if type(payload) ~= "table" then
		return
	end

	if type(payload.projectileId) ~= "string"
		or typeof(payload.origin) ~= "Vector3"
		or typeof(payload.direction) ~= "Vector3"
		or type(payload.speed) ~= "number"
		or type(payload.maxRange) ~= "number"
	then
		return
	end

	destroyBolt(payload.projectileId)
	local damageType = if type(payload.damageType) == "string" then payload.damageType else nil
	playFireSoundAt(payload.origin, damageType)
	local boltColor = if typeof(payload.boltColor) == "Color3" then (payload.boltColor :: Color3) else nil

	local boltPart, bulletPart = createVisualPartsFromTemplate(payload.projectileId, boltColor, damageType)

	activeBolts[payload.projectileId] = {
		boltPart = boltPart,
		bulletPart = bulletPart,
		origin = payload.origin,
		direction = payload.direction,
		speed = payload.speed,
		maxRange = payload.maxRange,
		createdAt = tick(),
		lastUpdatedAt = tick(),
		damageType = damageType,
		targetEntityId = if type(payload.targetEntityId) == "string" then payload.targetEntityId else nil,
		homingTurnRate = if type(payload.homingTurnRate) == "number" then payload.homingTurnRate else nil,
		currentPosition = payload.origin,
	}
end

local function onProjectileImpact(payload: ProjectileImpactPayload)
	if type(payload) ~= "table" then
		return
	end

	if type(payload.projectileId) ~= "string"
		or typeof(payload.hitPosition) ~= "Vector3"
		or typeof(payload.hitNormal) ~= "Vector3"
	then
		return
	end

	local bolt = activeBolts[payload.projectileId]
	local impactType = if type(payload.impactType) == "string" then payload.impactType else nil
	local damageType = if bolt ~= nil then bolt.damageType else nil
	local shieldBroken = payload.shieldBroken == true
	local impactDelay = 0
	if bolt ~= nil then
		local speed = math.max(1e-4, bolt.speed)
		local travelDistance = (payload.hitPosition - bolt.origin).Magnitude
		local expectedImpactTime = bolt.createdAt + (travelDistance / speed)
		impactDelay = math.max(0, expectedImpactTime - tick())
	end

	if impactDelay > 0 then
		task.delay(impactDelay, function()
			destroyBolt(payload.projectileId)
			playImpactSoundAt(payload.hitPosition, impactType)
			if impactType == "shield" and shieldBroken then
				playShieldBreakSoundAt(payload.hitPosition)
			end
			spawnImpactEffect(payload.hitPosition, payload.hitNormal, impactType, damageType)
		end)
		return
	end

	destroyBolt(payload.projectileId)
	playImpactSoundAt(payload.hitPosition, impactType)
	if impactType == "shield" and shieldBroken then
		playShieldBreakSoundAt(payload.hitPosition)
	end
	spawnImpactEffect(payload.hitPosition, payload.hitNormal, impactType, damageType)
end

function ProjectileVisuals.init(remotes: Folder)
	if renderConnection == nil then
		renderConnection = RunService.RenderStepped:Connect(onRenderStepped)
	end

	if projectileFiredConnection == nil then
		local projectileFiredRemote = remotes:WaitForChild("ProjectileFired") :: RemoteEvent
		projectileFiredConnection = projectileFiredRemote.OnClientEvent:Connect(onProjectileFired)
	end

	if projectileImpactConnection == nil then
		local projectileImpactRemote = remotes:WaitForChild("ProjectileImpact") :: RemoteEvent
		projectileImpactConnection = projectileImpactRemote.OnClientEvent:Connect(onProjectileImpact)
	end
end

return ProjectileVisuals
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="31">
          <Properties>
            <string name="Name">Targeting</string>
          </Properties>
          <Item class="ModuleScript" referent="32">
            <Properties>
              <string name="Name">TargetingClient</string>
              <string name="Source"><![CDATA[--!strict

local CollectionService = game:GetService("CollectionService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local localPlayer = Players.LocalPlayer
local playerScripts = localPlayer:WaitForChild("PlayerScripts")
local clientRoot = playerScripts:WaitForChild("CombatFramework")

local CombatHUD = require(clientRoot:WaitForChild("HUD"):WaitForChild("CombatHUD"))
local sharedRoot = ReplicatedStorage:WaitForChild("CombatFramework")
local CombatConfig = require(sharedRoot:WaitForChild("CombatConfig"))
local LeadSolver = require(sharedRoot:WaitForChild("LeadSolver"))
local WeaponRig = require(sharedRoot:WaitForChild("WeaponRig"))

local TargetingClient = {}

local requestLockRemote: RemoteEvent? = nil
local clearLockRemote: RemoteEvent? = nil
local lockOnStateRemote: RemoteEvent? = nil
local renderConnection: RBXScriptConnection? = nil
local lockOnStateConnection: RBXScriptConnection? = nil

local candidateEntityId: string? = nil
local candidateModel: Model? = nil
local lockedEntityId: string? = nil
local lockedModel: Model? = nil
local lockedAttackerEntityId: string? = nil
local velocitySampleByModel: { [Model]: { lastPosition: Vector3, lastTime: number, velocity: Vector3 } } = {}
local smoothedLockScreenPos: Vector2? = nil
local smoothedLeadScreenPos: Vector2? = nil
local smoothedVisualLeadPoint: Vector3? = nil
local lastRenderTimestamp: number = 0

local MIN_SAMPLE_DT = 1 / 60
local VELOCITY_SMOOTH_ALPHA = 0.2
local LOCK_UI_SMOOTH_RATE = 14
local LOCK_UI_DEADZONE_PX = 2.5
local LEAD_WORLD_SMOOTH_RATE = 12
local LEAD_WORLD_DEADZONE_STUDS = 0.35

local function normalizeTeamOrFaction(raw: string?): string?
	if raw == nil then
		return nil
	end
	local trimmed = string.match(raw, "^%s*(.-)%s*$")
	if trimmed == nil or trimmed == "" then
		return nil
	end
	return string.lower(trimmed)
end

local function findTaggedDescendant(model: Model, tagName: string, className: string?): Instance?
	for _, descendant in ipairs(model:GetDescendants()) do
		if CollectionService:HasTag(descendant, tagName) then
			if className == nil or descendant:IsA(className) then
				return descendant
			end
		end
	end
	return nil
end

local function findEntityModelById(entityId: string): Model?
	for _, tagged in ipairs(CollectionService:GetTagged("CombatEntity")) do
		if tagged:IsA("Model") and tagged:GetAttribute("EntityId") == entityId then
			return tagged
		end
	end
	return nil
end

local function resolveLockedModel(): Model?
	if lockedEntityId == nil then
		return nil
	end
	if lockedModel ~= nil and lockedModel.Parent ~= nil then
		return lockedModel
	end
	lockedModel = findEntityModelById(lockedEntityId)
	return lockedModel
end

local function getCurrentTurretContext(): (Model?, BasePart?, string?, number?)
	local character = localPlayer.Character
	if character == nil then
		return nil, nil, nil, nil
	end

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if humanoid == nil then
		return nil, nil, nil, nil
	end

	local seatPart = humanoid.SeatPart
	if seatPart == nil or not CollectionService:HasTag(seatPart, "TurretSeat") then
		return nil, nil, nil, nil
	end

	local turretModel = seatPart:FindFirstAncestorWhichIsA("Model")
	if turretModel == nil then
		return nil, nil, nil, nil
	end

	local weaponMount = findTaggedDescendant(turretModel, "WeaponMount", "BasePart")
	if weaponMount == nil then
		return turretModel, nil, nil, nil
	end

	local attackerEntityId = turretModel:GetAttribute("EntityId")
	local lockRange = turretModel:GetAttribute("EffectiveWeaponLockRange")
	if type(lockRange) ~= "number" or lockRange <= 0 then
		lockRange = nil
	end

	return turretModel, weaponMount :: BasePart, if type(attackerEntityId) == "string" then attackerEntityId else nil, lockRange
end

local function isDirectionWithinMountArc(weaponMount: BasePart, desiredDirection: Vector3): boolean
	if desiredDirection.Magnitude < 1e-4 then
		return false
	end
	local neutralAimFrame = WeaponRig.getNeutralAimFrame(weaponMount)
	local clamped = WeaponRig.clampDirectionToMountLimits(weaponMount, neutralAimFrame, desiredDirection.Unit)
	if clamped.Magnitude < 1e-4 then
		return false
	end
	return math.clamp(clamped:Dot(desiredDirection.Unit), -1, 1) >= math.cos(math.rad(1.5))
end

local function getProjectileSpeedForTurret(turretModel: Model): number?
	local effectiveSpeed = turretModel:GetAttribute("EffectiveWeaponProjectileSpeed")
	if type(effectiveSpeed) == "number" and effectiveSpeed > 0 then
		return effectiveSpeed
	end
	return nil
end

local function estimateTargetVelocity(targetModel: Model, targetPosition: Vector3): Vector3
	local now = tick()
	local fallbackVelocity = Vector3.zero
	local rootPart = targetModel.PrimaryPart
	if rootPart == nil then
		rootPart = targetModel:FindFirstChildWhichIsA("BasePart", true)
	end
	if rootPart ~= nil then
		fallbackVelocity = rootPart.AssemblyLinearVelocity
	end

	local sample = velocitySampleByModel[targetModel]
	if sample == nil then
		velocitySampleByModel[targetModel] = {
			lastPosition = targetPosition,
			lastTime = now,
			velocity = fallbackVelocity,
		}
		return fallbackVelocity
	end

	local dt = now - sample.lastTime
	if dt >= MIN_SAMPLE_DT then
		local observedVelocity = (targetPosition - sample.lastPosition) / dt
		sample.velocity = sample.velocity:Lerp(observedVelocity, VELOCITY_SMOOTH_ALPHA)
		sample.lastPosition = targetPosition
		sample.lastTime = now
	end

	return sample.velocity
end

local function computeLeadPoint(source: Vector3, targetModel: Model, projectileSpeed: number): Vector3?
	if projectileSpeed <= 0 then
		return nil
	end

	local targetPosition = targetModel:GetPivot().Position
	local targetVelocity = estimateTargetVelocity(targetModel, targetPosition)
	local predicted, _travelTime = LeadSolver.solveInterceptPoint(source, targetPosition, targetVelocity, projectileSpeed)
	return predicted
end

local function smoothScreenPosition(current: Vector2?, target: Vector2, dt: number): Vector2
	if current == nil then
		return target
	end

	local delta = target - current
	if delta.Magnitude <= LOCK_UI_DEADZONE_PX then
		return current
	end

	local alpha = 1 - math.exp(-LOCK_UI_SMOOTH_RATE * dt)
	return current:Lerp(target, math.clamp(alpha, 0, 1))
end

local function smoothWorldPosition(current: Vector3?, target: Vector3, dt: number): Vector3
	if current == nil then
		return target
	end

	local delta = target - current
	if delta.Magnitude <= LEAD_WORLD_DEADZONE_STUDS then
		return current
	end

	local alpha = 1 - math.exp(-LEAD_WORLD_SMOOTH_RATE * dt)
	return current:Lerp(target, math.clamp(alpha, 0, 1))
end

local function resetHudSmoothing()
	smoothedLockScreenPos = nil
	smoothedLeadScreenPos = nil
	smoothedVisualLeadPoint = nil
end

local function computeSmoothedVisualLeadPoint(
	sourcePosition: Vector3,
	targetModel: Model,
	projectileSpeed: number,
	dt: number
): Vector3?
	local rawLeadPoint = computeLeadPoint(sourcePosition, targetModel, projectileSpeed)
	if rawLeadPoint == nil then
		smoothedVisualLeadPoint = nil
		return nil
	end

	local clampedDt = math.clamp(dt, 1 / 240, 0.12)
	smoothedVisualLeadPoint = smoothWorldPosition(smoothedVisualLeadPoint, rawLeadPoint, clampedDt)
	return smoothedVisualLeadPoint
end

local function updateLockedHud(camera: Camera, turretModel: Model, weaponMount: BasePart, dt: number)
	local activeLockedEntityId = lockedEntityId
	if activeLockedEntityId == nil then
		CombatHUD.showLockReticle(false)
		CombatHUD.showLeadingIndicator(false)
		resetHudSmoothing()
		return
	end

	local activeLockedModel = resolveLockedModel()
	if activeLockedModel == nil then
		CombatHUD.showLockReticle(false)
		CombatHUD.showLeadingIndicator(false)
		resetHudSmoothing()
		return
	end

	local targetPosition = activeLockedModel:GetPivot().Position
	local targetViewport, targetOnScreen = camera:WorldToViewportPoint(targetPosition)
	if targetOnScreen then
		local rawTargetScreen = Vector2.new(targetViewport.X, targetViewport.Y)
		smoothedLockScreenPos = smoothScreenPosition(smoothedLockScreenPos, rawTargetScreen, dt)
		CombatHUD.showLockReticle(true)
		CombatHUD.setLockReticleScreenPosition(smoothedLockScreenPos :: Vector2)
	else
		CombatHUD.showLockReticle(false)
		smoothedLockScreenPos = nil
	end

	local projectileSpeed = getProjectileSpeedForTurret(turretModel)
	if projectileSpeed == nil then
		CombatHUD.showLeadingIndicator(false)
		smoothedLeadScreenPos = nil
		smoothedVisualLeadPoint = nil
		return
	end

	local leadPoint = computeSmoothedVisualLeadPoint(weaponMount.Position, activeLockedModel, projectileSpeed, dt)
	if leadPoint == nil then
		CombatHUD.showLeadingIndicator(false)
		smoothedLeadScreenPos = nil
		return
	end

	local leadViewport, leadOnScreen = camera:WorldToViewportPoint(leadPoint)
	if not leadOnScreen then
		CombatHUD.showLeadingIndicator(false)
		smoothedLeadScreenPos = nil
		return
	end

	local rawLeadScreen = Vector2.new(leadViewport.X, leadViewport.Y)
	smoothedLeadScreenPos = smoothScreenPosition(smoothedLeadScreenPos, rawLeadScreen, dt)

	CombatHUD.showLeadingIndicator(true)
	CombatHUD.setLeadingIndicatorScreenPosition(smoothedLeadScreenPos :: Vector2)
end

local function updateLockCandidate(camera: Camera, turretModel: Model, weaponMount: BasePart, lockRange: number)
	local cameraPosition = camera.CFrame.Position
	local cameraLook = camera.CFrame.LookVector
	local turretFaction = normalizeTeamOrFaction(turretModel:GetAttribute("Faction"))
	local maxDot = math.cos(math.rad(CombatConfig.LockOnScanRadius))

	local bestDot = maxDot
	local bestEntityId: string? = nil
	local bestModel: Model? = nil

	for _, tagged in ipairs(CollectionService:GetTagged("CombatEntity")) do
		if tagged:IsA("Model") then
			local targetModel = tagged :: Model
			if targetModel ~= turretModel then
				local targetEntityId = targetModel:GetAttribute("EntityId")
				if type(targetEntityId) == "string" then
					local hullHP = targetModel:GetAttribute("HullHP")
					if type(hullHP) == "number" and hullHP > 0 then
						local targetFaction = normalizeTeamOrFaction(targetModel:GetAttribute("Faction"))
						if turretFaction == nil or targetFaction == nil or targetFaction ~= turretFaction then
							local targetPosition = targetModel:GetPivot().Position
							local toTarget = targetPosition - cameraPosition
							local distance = toTarget.Magnitude
							if distance > 1e-4 and distance <= lockRange then
								local direction = toTarget.Unit
								local dot = cameraLook:Dot(direction)
								if dot >= bestDot and isDirectionWithinMountArc(weaponMount, targetPosition - weaponMount.Position) then
									bestDot = dot
									bestEntityId = targetEntityId
									bestModel = targetModel
								end
							end
						end
					end
				end
			end
		end
	end

	candidateEntityId = bestEntityId
	candidateModel = bestModel
end

local function onRenderStepped()
	for model, _sample in pairs(velocitySampleByModel) do
		if model.Parent == nil then
			velocitySampleByModel[model] = nil
		end
	end

	local camera = Workspace.CurrentCamera
	if camera == nil then
		return
	end

	local now = tick()
	local dt = if lastRenderTimestamp > 0 then math.clamp(now - lastRenderTimestamp, 1 / 240, 0.12) else 1 / 60
	lastRenderTimestamp = now

	local turretModel, weaponMount, attackerEntityId, lockRange = getCurrentTurretContext()
	if turretModel == nil or weaponMount == nil or attackerEntityId == nil or lockRange == nil then
		candidateEntityId = nil
		candidateModel = nil
		CombatHUD.showLockReady(false)
		CombatHUD.showLockReticle(false)
		CombatHUD.showLeadingIndicator(false)
		resetHudSmoothing()
		return
	end

	updateLockCandidate(camera, turretModel, weaponMount, lockRange)
	if lockedEntityId == nil then
		CombatHUD.showLockReady(candidateEntityId ~= nil)
		CombatHUD.showLockReticle(false)
		CombatHUD.showLeadingIndicator(false)
		resetHudSmoothing()
	else
		CombatHUD.showLockReady(false)
		updateLockedHud(camera, turretModel, weaponMount, dt)
	end
end

local function onLockOnState(payload: any)
	if type(payload) ~= "table" then
		return
	end

	local previousLockedEntityId = lockedEntityId
	local attackerEntityId = payload.attackerEntityId
	if type(attackerEntityId) == "string" then
		lockedAttackerEntityId = attackerEntityId
	end

	if payload.locked == true and type(payload.targetEntityId) == "string" then
		lockedEntityId = payload.targetEntityId
		lockedModel = findEntityModelById(payload.targetEntityId)
	else
		local reason = payload.reason
		if previousLockedEntityId ~= nil and type(reason) == "string" then
			if reason == "range" or reason == "arc" or reason == "dead" or reason == "missing" or reason == "missing_target" then
				CombatHUD.onLockLostCue(reason)
			end
		end
		lockedEntityId = nil
		lockedModel = nil
		resetHudSmoothing()
	end
end

function TargetingClient.init(remotes: Folder)
	requestLockRemote = remotes:WaitForChild("RequestLockOn") :: RemoteEvent
	clearLockRemote = remotes:WaitForChild("ClearLockOn") :: RemoteEvent
	lockOnStateRemote = remotes:WaitForChild("LockOnState") :: RemoteEvent

	if lockOnStateConnection == nil then
		lockOnStateConnection = lockOnStateRemote.OnClientEvent:Connect(onLockOnState)
	end

	if renderConnection == nil then
		renderConnection = RunService.RenderStepped:Connect(onRenderStepped)
	end
end

function TargetingClient.isLocked(): boolean
	return lockedEntityId ~= nil
end

function TargetingClient.getLockedEntityId(): string?
	return lockedEntityId
end

function TargetingClient.getLockedModel(): Model?
	return resolveLockedModel()
end

function TargetingClient.getLockedLeadPoint(sourcePosition: Vector3, turretModel: Model): Vector3?
	local activeLockedModel = resolveLockedModel()
	if activeLockedModel == nil then
		return nil
	end

	local projectileSpeed = getProjectileSpeedForTurret(turretModel)
	if projectileSpeed == nil then
		return nil
	end

	return computeLeadPoint(sourcePosition, activeLockedModel, projectileSpeed)
end

function TargetingClient.getLockedVisualLeadPoint(sourcePosition: Vector3, turretModel: Model, dt: number): Vector3?
	local activeLockedModel = resolveLockedModel()
	if activeLockedModel == nil then
		smoothedVisualLeadPoint = nil
		return nil
	end

	local projectileSpeed = getProjectileSpeedForTurret(turretModel)
	if projectileSpeed == nil then
		smoothedVisualLeadPoint = nil
		return nil
	end

	return computeSmoothedVisualLeadPoint(sourcePosition, activeLockedModel, projectileSpeed, dt)
end

function TargetingClient.requestLock()
	if requestLockRemote == nil then
		return
	end
	if candidateEntityId == nil then
		return
	end
	requestLockRemote:FireServer({
		targetEntityId = candidateEntityId,
		attackerEntityId = lockedAttackerEntityId,
	})
end

function TargetingClient.requestClearLock()
	if clearLockRemote == nil then
		return
	end
	clearLockRemote:FireServer()
end

function TargetingClient.onSeatExit()
	if lockedEntityId ~= nil then
		TargetingClient.requestClearLock()
	end

	candidateEntityId = nil
	candidateModel = nil
	lockedEntityId = nil
	lockedModel = nil
	lockedAttackerEntityId = nil
	table.clear(velocitySampleByModel)
	resetHudSmoothing()
	lastRenderTimestamp = 0
	CombatHUD.showLockReady(false)
	CombatHUD.showLockReticle(false)
	CombatHUD.showLeadingIndicator(false)
end

return TargetingClient
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="33">
          <Properties>
            <string name="Name">VFX</string>
          </Properties>
        </Item>
        <Item class="Folder" referent="34">
          <Properties>
            <string name="Name">Weapons</string>
          </Properties>
          <Item class="ModuleScript" referent="35">
            <Properties>
              <string name="Name">WeaponClient</string>
              <string name="Source"><![CDATA[--!strict

local CollectionService = game:GetService("CollectionService")
local ContextActionService = game:GetService("ContextActionService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")

local localPlayer = Players.LocalPlayer
local playerScripts = localPlayer:WaitForChild("PlayerScripts")
local clientRoot = playerScripts:WaitForChild("CombatFramework")

local CombatHUD = require(clientRoot:WaitForChild("HUD"):WaitForChild("CombatHUD"))
local TargetingClient = require(clientRoot:WaitForChild("Targeting"):WaitForChild("TargetingClient"))
local sharedRoot = ReplicatedStorage:WaitForChild("CombatFramework")
local CombatConfig = require(sharedRoot:WaitForChild("CombatConfig"))
local WeaponRig = require(sharedRoot:WaitForChild("WeaponRig"))

local WeaponClient = {}

local FIRE_ACTION_NAME = "CombatFireWeapon"
local EXIT_ACTION_NAME = "CombatExitTurret"
local ZOOM_ACTION_NAME = "CombatZoomWeapon"
local LOCK_ACTION_NAME = "CombatLockToggle"
local CAMERA_POINT_NAME = "CameraPoint"

local MIN_VERTICAL_ANGLE = math.rad(-25)
local MAX_VERTICAL_ANGLE = math.rad(50)
local CAMERA_MOUSE_SENSITIVITY = 0.0025
local AIM_DEADZONE_ANGLE = math.rad(1.5)
local TURN_RATE_GAIN = 3
local MIN_TURN_RATE = math.rad(20)
local MAX_TURN_RATE = math.rad(100)
local STOP_SMOOTH_ZONE = math.rad(3)
local STOP_SMOOTH_RATE = 8
local LOCK_CAMERA_DEADZONE_ANGLE = math.rad(1.0)
local LOCK_CAMERA_TURN_GAIN = 2.6
local LOCK_CAMERA_MIN_TURN_RATE = math.rad(10)
local LOCK_CAMERA_MAX_TURN_RATE = math.rad(55)
local CAMERA_FALLBACK_LOCAL_OFFSET = Vector3.new(0, 9, 22)
local CAMERA_LOOK_DISTANCE = 500
local DEFAULT_PROJECTILE_RANGE = 500
local MAX_PHYSICS_CAST_DISTANCE = 1024
local SHOT_KICK_IMPULSE = 7.2
local SHOT_KICK_SPRING = 44
local SHOT_KICK_DAMPING = 12
local SHOT_SHAKE_IMPULSE = 1.15
local SHOT_SHAKE_DAMPING = 5
local SHOT_SHAKE_FREQUENCY = 28
local MAX_SHAKE_AMPLITUDE = 2.6
local MAX_KICK_VELOCITY = 10
local SHOT_FOV_IMPULSE = 1.4
local SHOT_FOV_SPRING = 30
local SHOT_FOV_DAMPING = 10
local MAX_FOV_OFFSET = 3.4
local ZOOM_FOV_REDUCTION = 52
local ZOOM_IN_RATE = 18
local ZOOM_OUT_RATE = 11
local MIN_TURRET_FOV = 10
local HEAT_VFX_START_RATIO = 0.68
local HEAT_VFX_OVERHEAT_BURST_INTERVAL = 0.18
local AIM_UPDATE_INTERVAL = 1 / 30

type RigOverride = {
	mode: string?,
	minYawDeg: number?,
	maxYawDeg: number?,
	minPitchDeg: number?,
	maxPitchDeg: number?,
	pivotName: string?,
	pivotAttachment: Attachment?,
}

type DrivenPartState = {
	part: BasePart,
	neutralAimFrame: CFrame,
	clampOverride: RigOverride?,
}

local fireWeaponRemote: RemoteEvent? = nil
local updateTurretAimRemote: RemoteEvent? = nil

local activeTurretModel: Model? = nil
local activeSeat: BasePart? = nil
local activeWeaponMount: BasePart? = nil
local activeNeutralAimFrame: CFrame? = nil
local activeCameraPoint: Instance? = nil

local desiredAimDirection: Vector3? = nil
local currentAimDirection: Vector3? = nil
local lockedCameraLookDirection: Vector3? = nil
local cameraYaw = 0
local cameraPitch = 0
local cameraKickOffset = 0
local cameraKickVelocity = 0
local cameraShakeAmplitude = 0
local cameraShakeTime = 0
local cameraFovOffset = 0
local cameraFovVelocity = 0
local turretBaseFov = 70
local zoomHeld = false
local fireHeld = false
local zoomBlend = 0
local nextClientFireTime = 0
local nextAimUpdateTime = 0
local lastHeatRecoverCueId = 0
local heatVfxMount: BasePart? = nil
local heatVfxAttachment: Attachment? = nil
local heatVfxLight: PointLight? = nil
local heatVfxSmoke: ParticleEmitter? = nil
local heatVfxBurstAccumulator = 0
local activeDrivenParts: { DrivenPartState } = {}
local ensureWeaponMount: (() -> ())? = nil
local updateDrivenParts: ((Vector3) -> ())? = nil

local seatedConnection: RBXScriptConnection? = nil
local characterAddedConnection: RBXScriptConnection? = nil
local turretStepConnection: RBXScriptConnection? = nil
local aimRaycastParams = RaycastParams.new()
local aimRaycastExcludeList: { Instance } = {}

local function triggerFireCameraFeedback()
	local shakeImpulse = SHOT_SHAKE_IMPULSE
	if activeTurretModel ~= nil then
		local rawModifier = activeTurretModel:GetAttribute("WeaponScreenShakeModifier")
		local modifier: number? = nil
		if type(rawModifier) == "number" then
			modifier = rawModifier
		elseif type(rawModifier) == "string" then
			modifier = tonumber(rawModifier)
		end
		if modifier ~= nil then
			shakeImpulse *= math.max(0, 1 + modifier)
		end
	end

	cameraKickVelocity += SHOT_KICK_IMPULSE
	cameraKickVelocity = math.clamp(cameraKickVelocity, -MAX_KICK_VELOCITY, MAX_KICK_VELOCITY)
	cameraShakeAmplitude = math.min(MAX_SHAKE_AMPLITUDE, cameraShakeAmplitude + shakeImpulse)
	cameraFovVelocity += SHOT_FOV_IMPULSE
end

local function readModelNumberAttribute(instance: Instance, attributeName: string): number?
	local raw = instance:GetAttribute(attributeName)
	if type(raw) == "number" then
		return raw
	end
	if type(raw) == "string" then
		return tonumber(raw)
	end
	return nil
end

local function applyPercentModifier(baseValue: number, modifier: number?, minValue: number?): number
	local adjusted = baseValue
	if modifier ~= nil then
		adjusted = baseValue * (1 + modifier)
	end
	if minValue ~= nil then
		adjusted = math.max(minValue, adjusted)
	end
	return adjusted
end

local function smoothDirectionToward(
	currentDirection: Vector3,
	targetDirection: Vector3,
	dt: number,
	deadzoneAngle: number,
	rateGain: number,
	minTurnRate: number,
	maxTurnRate: number
): Vector3
	local currentUnit = if currentDirection.Magnitude > 1e-4 then currentDirection.Unit else targetDirection.Unit
	local targetUnit = if targetDirection.Magnitude > 1e-4 then targetDirection.Unit else currentUnit
	local dot = math.clamp(currentUnit:Dot(targetUnit), -1, 1)
	local angularError = math.acos(dot)

	if angularError <= deadzoneAngle then
		return currentUnit
	end

	local turnRate = math.clamp(angularError * rateGain, minTurnRate, maxTurnRate)
	local alpha = math.min(1, (turnRate * dt) / math.max(angularError, 1e-4))
	return (currentUnit:Lerp(targetUnit, alpha)).Unit
end

local function getActiveWeaponCooldown(): number
	if activeTurretModel == nil then
		return 0
	end

	local effectiveFireRate = readModelNumberAttribute(activeTurretModel, "EffectiveWeaponFireRate")
	if effectiveFireRate ~= nil and effectiveFireRate > 0 then
		return 1 / effectiveFireRate
	end

	local configId = activeTurretModel:GetAttribute("ConfigId")
	if type(configId) ~= "string" then
		return 0
	end

	local entityConfig = CombatConfig.Entities[configId]
	if entityConfig == nil or type(entityConfig.weaponId) ~= "string" then
		return 0
	end

	local weaponConfig = CombatConfig.Weapons[entityConfig.weaponId]
	if weaponConfig == nil or type(weaponConfig.fireRate) ~= "number" or weaponConfig.fireRate <= 0 then
		return 0
	end

	local fireRateModifier = readModelNumberAttribute(activeTurretModel, "WeaponFireRateModifier")
	local resolvedFireRate = applyPercentModifier(weaponConfig.fireRate, fireRateModifier, 0.01)
	return 1 / resolvedFireRate
end

local function isHoldToFireEnabled(): boolean
	return activeTurretModel ~= nil and activeTurretModel:GetAttribute("WeaponHoldToFire") == true
end

local function isLockRequiredForActiveWeapon(): boolean
	if activeTurretModel == nil then
		return false
	end

	local requiresLockAttr = activeTurretModel:GetAttribute("WeaponRequiresLock")
	if type(requiresLockAttr) == "boolean" then
		return requiresLockAttr
	end

	local configId = activeTurretModel:GetAttribute("ConfigId")
	if type(configId) ~= "string" then
		return false
	end

	local entityConfig = CombatConfig.Entities[configId]
	if entityConfig == nil or type(entityConfig.weaponId) ~= "string" then
		return false
	end

	local weaponConfig = CombatConfig.Weapons[entityConfig.weaponId]
	return weaponConfig ~= nil and weaponConfig.requiresLock == true
end

local function tryFireCurrentWeapon(): boolean
	if activeTurretModel == nil or fireWeaponRemote == nil then
		return false
	end

	if ensureWeaponMount ~= nil then
		ensureWeaponMount()
	end
	local weaponMount = activeWeaponMount
	if weaponMount == nil then
		return false
	end

	local aimDirection = currentAimDirection or desiredAimDirection or weaponMount.CFrame.LookVector
	if aimDirection.Magnitude < 1e-4 then
		return false
	end

	if activeTurretModel:GetAttribute("WeaponOverheated") == true then
		return false
	end
	if isLockRequiredForActiveWeapon() and not TargetingClient.isLocked() then
		return false
	end

	local ammoMaxRaw = activeTurretModel:GetAttribute("WeaponAmmoMax")
	if type(ammoMaxRaw) == "number" and ammoMaxRaw > 0 then
		local ammoRaw = activeTurretModel:GetAttribute("WeaponAmmo")
		if type(ammoRaw) == "number" and ammoRaw <= 0 then
			return false
		end
	end

	local now = tick()
	local cooldown = getActiveWeaponCooldown()
	if cooldown > 0 and now < nextClientFireTime then
		return false
	end

	fireWeaponRemote:FireServer(aimDirection.Unit)
	triggerFireCameraFeedback()
	if cooldown > 0 then
		nextClientFireTime = now + cooldown
	end
	return true
end

local function sendAimUpdate(aimDirection: Vector3)
	if updateTurretAimRemote == nil or activeTurretModel == nil then
		return
	end
	if aimDirection.Magnitude < 1e-4 then
		return
	end

	local now = tick()
	if now < nextAimUpdateTime then
		return
	end
	nextAimUpdateTime = now + AIM_UPDATE_INTERVAL
	updateTurretAimRemote:FireServer(aimDirection.Unit)
end

local function findTaggedDescendant(model: Model, tagName: string, className: string?): Instance?
	for _, descendant in ipairs(model:GetDescendants()) do
		if CollectionService:HasTag(descendant, tagName) then
			if className == nil or descendant:IsA(className) then
				return descendant
			end
		end
	end
	return nil
end

local function findCameraPoint(model: Model): Instance?
	for _, descendant in ipairs(model:GetDescendants()) do
		if descendant.Name == CAMERA_POINT_NAME and (descendant:IsA("BasePart") or descendant:IsA("Attachment")) then
			return descendant
		end
	end
	return nil
end

local function clampDirectionPitch(direction: Vector3): Vector3
	local horizontal = Vector3.new(direction.X, 0, direction.Z)
	if horizontal.Magnitude < 1e-4 then
		horizontal = Vector3.new(0, 0, -1)
	end

	local rawPitch = math.asin(math.clamp(direction.Y, -1, 1))
	local clampedPitch = math.clamp(rawPitch, MIN_VERTICAL_ANGLE, MAX_VERTICAL_ANGLE)
	local horizontalMagnitude = math.cos(clampedPitch)

	return (horizontal.Unit * horizontalMagnitude + Vector3.new(0, math.sin(clampedPitch), 0)).Unit
end

local function directionToYawPitch(direction: Vector3): (number, number)
	local unitDirection = direction.Unit
	local yaw = math.atan2(-unitDirection.X, -unitDirection.Z)
	local pitch = math.asin(math.clamp(unitDirection.Y, -1, 1))
	return yaw, pitch
end

local function yawPitchToDirection(yaw: number, pitch: number): Vector3
	local cosPitch = math.cos(pitch)
	return Vector3.new(-math.sin(yaw) * cosPitch, math.sin(pitch), -math.cos(yaw) * cosPitch).Unit
end

local function isMuzzleAttachment(candidate: Instance): boolean
	if not candidate:IsA("Attachment") then
		return false
	end

	if CollectionService:HasTag(candidate, "MuzzlePoint") then
		return true
	end

	return candidate.Name == "MuzzlePoint" or string.sub(candidate.Name, 1, 11) == "MuzzlePoint"
end

local function getPrimaryMuzzleLocalOffset(weaponMount: BasePart): Vector3
	local attachments: { Attachment } = {}
	for _, descendant in ipairs(weaponMount:GetDescendants()) do
		if isMuzzleAttachment(descendant) then
			table.insert(attachments, descendant :: Attachment)
		end
	end

	table.sort(attachments, function(a: Attachment, b: Attachment)
		return a:GetFullName() < b:GetFullName()
	end)

	local muzzlePoint = attachments[1]
	if muzzlePoint ~= nil then
		return weaponMount.CFrame:PointToObjectSpace(muzzlePoint.WorldPosition)
	end

	return Vector3.new(0, 0, -weaponMount.Size.Z * 0.5)
end

local function performAimCast(origin: Vector3, directionUnit: Vector3, totalDistance: number): RaycastResult?
	local remainingDistance = totalDistance
	local castOrigin = origin

	while remainingDistance > 0 do
		local segmentDistance = math.min(remainingDistance, MAX_PHYSICS_CAST_DISTANCE)
		local segmentDirection = directionUnit * segmentDistance
		local castResult = Workspace:Raycast(castOrigin, segmentDirection, aimRaycastParams)
		if castResult ~= nil then
			return castResult
		end

		castOrigin += segmentDirection
		remainingDistance -= segmentDistance
	end

	return nil
end

local function updateAimReticle(camera: Camera, aimDirection: Vector3)
	local weaponMount = activeWeaponMount
	if weaponMount == nil then
		return
	end

	local maxRange = DEFAULT_PROJECTILE_RANGE
	local hasRangeOverride = false
	if activeTurretModel ~= nil then
		local effectiveMaxRange = readModelNumberAttribute(activeTurretModel, "EffectiveWeaponMaxRange")
		if effectiveMaxRange ~= nil and effectiveMaxRange > 0 then
			maxRange = effectiveMaxRange
			hasRangeOverride = true
		end
	end
	local turretConfigId = if activeTurretModel ~= nil then activeTurretModel:GetAttribute("ConfigId") else nil
	if not hasRangeOverride and type(turretConfigId) == "string" then
		local entityConfig = CombatConfig.Entities[turretConfigId]
		if entityConfig ~= nil and type(entityConfig.weaponId) == "string" then
				local weaponConfig = CombatConfig.Weapons[entityConfig.weaponId]
				if weaponConfig ~= nil and type(weaponConfig.maxRange) == "number" then
					local rangeModifier = readModelNumberAttribute(activeTurretModel :: Instance, "WeaponMaxRangeModifier")
					maxRange = applyPercentModifier(weaponConfig.maxRange, rangeModifier, 1)
				end
			end
		end

	local muzzleLocalOffset = getPrimaryMuzzleLocalOffset(weaponMount)

	local originFrame = WeaponRig.getAimFrame(weaponMount, aimDirection)
	local muzzleOrigin = originFrame:PointToWorldSpace(muzzleLocalOffset)

	table.clear(aimRaycastExcludeList)
	if activeTurretModel ~= nil then
		aimRaycastExcludeList[1] = activeTurretModel
	end
	aimRaycastParams.FilterDescendantsInstances = aimRaycastExcludeList

	local aimDirectionMagnitude = aimDirection.Magnitude
	if aimDirectionMagnitude <= 0 then
		return
	end
	local castDirectionUnit = aimDirection / aimDirectionMagnitude
	local fullRangeDirection = castDirectionUnit * maxRange
	local castResult = performAimCast(muzzleOrigin, castDirectionUnit, maxRange)

	local aimPoint = if castResult ~= nil then castResult.Position else (muzzleOrigin + fullRangeDirection)
	local viewportPoint, onScreen = camera:WorldToViewportPoint(aimPoint)
	local viewportSize = camera.ViewportSize

	local x = viewportPoint.X
	local y = viewportPoint.Y
	if not onScreen then
		x = math.clamp(x, 0, viewportSize.X)
		y = math.clamp(y, 0, viewportSize.Y)
	end

	CombatHUD.setCrosshairPosition(Vector2.new(x, y))
end

local function getCameraPointWorldPosition(point: Instance?): Vector3?
	if point == nil then
		return nil
	end

	if point:IsA("Attachment") then
		return point.WorldPosition
	end
	if point:IsA("BasePart") then
		return point.Position
	end

	return nil
end

local function getCameraAnchorWorldPosition(cameraPoint: Instance?, seatPart: BasePart?, mount: BasePart?): Vector3?
	local pointPosition = getCameraPointWorldPosition(cameraPoint)
	if pointPosition ~= nil then
		return pointPosition
	end

	if seatPart ~= nil then
		return seatPart.CFrame:PointToWorldSpace(CAMERA_FALLBACK_LOCAL_OFFSET)
	end

	if mount ~= nil then
		return mount.CFrame:PointToWorldSpace(CAMERA_FALLBACK_LOCAL_OFFSET)
	end

	return nil
end

local function initializeAimFromCurrentRig()
	if activeWeaponMount == nil then
		return
	end

	activeNeutralAimFrame = WeaponRig.getNeutralAimFrame(activeWeaponMount)
	local initialDirection = clampDirectionPitch(WeaponRig.getCurrentAimDirection(activeWeaponMount))
	if activeNeutralAimFrame ~= nil then
		initialDirection = WeaponRig.clampDirectionToMountLimits(activeWeaponMount, activeNeutralAimFrame, initialDirection)
	end

	desiredAimDirection = initialDirection
	currentAimDirection = initialDirection
	cameraYaw, cameraPitch = directionToYawPitch(initialDirection)
end

local rebuildDrivenParts: (() -> ())? = nil

ensureWeaponMount = function()
	if activeTurretModel == nil then
		activeWeaponMount = nil
		activeNeutralAimFrame = nil
		return
	end

	if activeWeaponMount ~= nil and activeWeaponMount.Parent ~= nil then
		return
	end

	local mount = findTaggedDescendant(activeTurretModel, "WeaponMount", "BasePart")
	if mount ~= nil then
		activeWeaponMount = mount :: BasePart
		activeNeutralAimFrame = WeaponRig.getNeutralAimFrame(activeWeaponMount)
		if rebuildDrivenParts ~= nil then
			rebuildDrivenParts()
		end
		if currentAimDirection == nil or desiredAimDirection == nil then
			initializeAimFromCurrentRig()
		end
	end
end

local function clearDrivenParts()
	table.clear(activeDrivenParts)
end

local function modeFromFolderName(folderName: string): string?
	local normalized = string.lower(string.gsub(folderName, "[%s_%-]", ""))
	if normalized == "yawonly" or normalized == "yawonlyparts" or normalized == "drivenyawonly" then
		return "yawonly"
	end
	if normalized == "pitchonly" or normalized == "pitchonlyparts" or normalized == "drivenpitchonly" then
		return "pitchonly"
	end
	if normalized == "yawpitch" or normalized == "yawpitchparts" or normalized == "drivenyawpitch" then
		return "yawpitch"
	end
	return nil
end

local function readNumberAttribute(instance: Instance, name: string): number?
	local raw = instance:GetAttribute(name)
	if type(raw) == "number" then
		return raw
	end
	if type(raw) == "string" then
		return tonumber(raw)
	end
	return nil
end

local function getClampOverride(folder: Instance, modeFromName: string?): RigOverride?
	local modeFromAttr = folder:GetAttribute("AimMode")
	local mode: string? = modeFromName
	if type(modeFromAttr) == "string" and modeFromAttr ~= "" then
		mode = modeFromAttr
	end

	local minYawDeg = readNumberAttribute(folder, "MinYawDeg")
	local maxYawDeg = readNumberAttribute(folder, "MaxYawDeg")
	local minPitchDeg = readNumberAttribute(folder, "MinPitchDeg")
	local maxPitchDeg = readNumberAttribute(folder, "MaxPitchDeg")
	local pivotName: string? = nil
	local pivotNameRaw = folder:GetAttribute("AimPivotName")
	if type(pivotNameRaw) == "string" and string.match(pivotNameRaw, "%S") ~= nil then
		pivotName = pivotNameRaw
	end

	local pivotAttachment: Attachment? = nil
	for _, child in ipairs(folder:GetChildren()) do
		if child:IsA("ObjectValue") and child.Value ~= nil and child.Value:IsA("Attachment") then
			local attachedValue = child.Value :: Attachment
			if child.Name == "AimPivotAttachment" or child.Name == "PivotAttachment" then
				pivotAttachment = attachedValue
				break
			end

			if pivotAttachment == nil then
				pivotAttachment = attachedValue
			end
		end
	end

	if
		mode == nil
		and minYawDeg == nil
		and maxYawDeg == nil
		and minPitchDeg == nil
		and maxPitchDeg == nil
		and pivotName == nil
		and pivotAttachment == nil
	then
		return nil
	end

	return {
		mode = mode,
		minYawDeg = minYawDeg,
		maxYawDeg = maxYawDeg,
		minPitchDeg = minPitchDeg,
		maxPitchDeg = maxPitchDeg,
		pivotName = pivotName,
		pivotAttachment = pivotAttachment,
	}
end

local function addDrivenPart(
	part: BasePart,
	seen: { [BasePart]: boolean },
	clampOverride: RigOverride?
)
	if activeWeaponMount ~= nil and part == activeWeaponMount then
		return
	end
	if seen[part] then
		return
	end

	seen[part] = true
	table.insert(activeDrivenParts, {
		part = part,
		neutralAimFrame = WeaponRig.getNeutralAimFrame(part),
		clampOverride = clampOverride,
	})
end

local function collectDrivenPartsFromContainer(
	container: Instance,
	seen: { [BasePart]: boolean },
	clampOverride: RigOverride?
)
	for _, descendant in ipairs(container:GetDescendants()) do
		if descendant:IsA("BasePart") then
			addDrivenPart(descendant, seen, clampOverride)
		elseif descendant:IsA("ObjectValue") and descendant.Value ~= nil and descendant.Value:IsA("BasePart") then
			addDrivenPart(descendant.Value, seen, clampOverride)
		end
	end
end

rebuildDrivenParts = function()
	clearDrivenParts()

	local turretModel = activeTurretModel
	if turretModel == nil then
		return
	end

	local seen: { [BasePart]: boolean } = {}
	if activeWeaponMount ~= nil then
		seen[activeWeaponMount] = true
	end

	local rigFolder = turretModel:FindFirstChild("TurretRig")
	if rigFolder == nil then
		return
	end

	local drivenPartsFolder = rigFolder:FindFirstChild("DrivenParts")
	if drivenPartsFolder ~= nil then
		local clampOverride = getClampOverride(drivenPartsFolder, nil)
		collectDrivenPartsFromContainer(drivenPartsFolder, seen, clampOverride)
	end

	for _, child in ipairs(rigFolder:GetChildren()) do
		if child:IsA("Folder") and child.Name ~= "DrivenParts" then
			local modeOverride = modeFromFolderName(child.Name)
			local clampOverride = getClampOverride(child, modeOverride)
			if modeOverride ~= nil or clampOverride ~= nil then
				collectDrivenPartsFromContainer(child, seen, clampOverride)
			end
		end
	end
end

updateDrivenParts = function(aimDirection: Vector3)
	if #activeDrivenParts == 0 then
		return
	end

	for index = #activeDrivenParts, 1, -1 do
		local driven = activeDrivenParts[index]
		if driven.part.Parent == nil then
			table.remove(activeDrivenParts, index)
		else
			local drivenDirection =
				WeaponRig.clampDirectionToMountLimits(driven.part, driven.neutralAimFrame, aimDirection, driven.clampOverride)
			if drivenDirection.Magnitude > 1e-4 then
				driven.part.CFrame = WeaponRig.getAimFrame(driven.part, drivenDirection, driven.clampOverride)
			end
		end
	end
end

local function clearHeatVfx()
	if heatVfxAttachment ~= nil and heatVfxAttachment.Parent ~= nil then
		heatVfxAttachment:Destroy()
	end
	heatVfxMount = nil
	heatVfxAttachment = nil
	heatVfxLight = nil
	heatVfxSmoke = nil
	heatVfxBurstAccumulator = 0
end

local function ensureHeatVfxForMount(weaponMount: BasePart)
	if heatVfxMount == weaponMount and heatVfxAttachment ~= nil and heatVfxAttachment.Parent == weaponMount then
		return
	end

	clearHeatVfx()

	local attachment = Instance.new("Attachment")
	attachment.Name = "WeaponHeatVFX"
	local muzzleLocalOffset = getPrimaryMuzzleLocalOffset(weaponMount)
	attachment.Position = muzzleLocalOffset
	attachment.Parent = weaponMount

	local glow = Instance.new("PointLight")
	glow.Name = "HeatGlow"
	glow.Enabled = false
	glow.Shadows = false
	glow.Brightness = 0
	glow.Range = 0
	glow.Color = Color3.fromRGB(255, 170, 95)
	glow.Parent = attachment

	local smoke = Instance.new("ParticleEmitter")
	smoke.Name = "HeatSmoke"
	smoke.Enabled = false
	smoke.Rate = 0
	smoke.Speed = NumberRange.new(0.35, 1.45)
	smoke.Lifetime = NumberRange.new(0.5, 1.2)
	smoke.SpreadAngle = Vector2.new(16, 16)
	smoke.RotSpeed = NumberRange.new(-25, 25)
	smoke.Rotation = NumberRange.new(0, 360)
	smoke.Acceleration = Vector3.new(0, 3, 0)
	smoke.Texture = "rbxassetid://716847870"
	smoke.Size = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.45),
		NumberSequenceKeypoint.new(0.5, 1.15),
		NumberSequenceKeypoint.new(1, 1.95),
	})
	smoke.Transparency = NumberSequence.new({
		NumberSequenceKeypoint.new(0, 0.45),
		NumberSequenceKeypoint.new(1, 1),
	})
	smoke.Color = ColorSequence.new({
		ColorSequenceKeypoint.new(0, Color3.fromRGB(120, 120, 120)),
		ColorSequenceKeypoint.new(0.35, Color3.fromRGB(82, 82, 82)),
		ColorSequenceKeypoint.new(1, Color3.fromRGB(38, 38, 38)),
	})
	smoke.Parent = attachment

	heatVfxMount = weaponMount
	heatVfxAttachment = attachment
	heatVfxLight = glow
	heatVfxSmoke = smoke
end

local function updateWeaponHeatVfx(dt: number, heatRatio: number, overheated: boolean)
	if activeWeaponMount == nil then
		clearHeatVfx()
		return
	end

	ensureHeatVfxForMount(activeWeaponMount)
	local glow = heatVfxLight
	local smoke = heatVfxSmoke
	if glow == nil or smoke == nil then
		return
	end

	local visualRatio = math.clamp((heatRatio - HEAT_VFX_START_RATIO) / (1 - HEAT_VFX_START_RATIO), 0, 1)
	if overheated then
		visualRatio = 1
	end

	local enabled = visualRatio > 0.01
	glow.Enabled = enabled
	smoke.Enabled = enabled

	if not enabled then
		smoke.Rate = 0
		heatVfxBurstAccumulator = 0
		return
	end

	local heatColor: Color3
	if overheated then
		heatColor = Color3.fromRGB(255, 74, 52)
	else
		local g = math.floor(212 - visualRatio * 118 + 0.5)
		local b = math.floor(128 - visualRatio * 64 + 0.5)
		heatColor = Color3.fromRGB(255, math.clamp(g, 94, 212), math.clamp(b, 62, 128))
	end

	glow.Color = heatColor
	glow.Brightness = 0.35 + visualRatio * 2.4
	glow.Range = 2.4 + visualRatio * 5.4
	smoke.Rate = 2 + visualRatio * (if overheated then 42 else 24)

	if overheated then
		heatVfxBurstAccumulator += dt
		if heatVfxBurstAccumulator >= HEAT_VFX_OVERHEAT_BURST_INTERVAL then
			heatVfxBurstAccumulator = 0
			smoke:Emit(5)
		end
	else
		heatVfxBurstAccumulator = 0
	end
end

local function updateWeaponHeatHud(): (number, boolean)
	local turretModel = activeTurretModel
	if turretModel == nil then
		return 0, false
	end

	local heatValue = turretModel:GetAttribute("WeaponHeat")
	if type(heatValue) ~= "number" then
		CombatHUD.setWeaponHeat(0, 100, false)
		return 0, false
	end

	local heatMax = turretModel:GetAttribute("WeaponHeatMax")
	local maxHeat = if type(heatMax) == "number" and heatMax > 0 then heatMax else 100
	local heatDecayPerSecond = turretModel:GetAttribute("WeaponHeatDecayPerSecond")
	local heatUpdatedAt = turretModel:GetAttribute("WeaponHeatUpdatedAt")
	local overheated = turretModel:GetAttribute("WeaponOverheated") == true

	local displayHeat = math.clamp(heatValue, 0, maxHeat)
	if type(heatDecayPerSecond) == "number" and heatDecayPerSecond > 0 and type(heatUpdatedAt) == "number" then
		local elapsed = math.max(0, Workspace:GetServerTimeNow() - heatUpdatedAt)
		local coolingRate = heatDecayPerSecond / maxHeat
		displayHeat = math.max(0, displayHeat * math.exp(-coolingRate * elapsed))
	end

	CombatHUD.setWeaponHeat(displayHeat, maxHeat, overheated)
	local heatRatio = math.clamp(displayHeat / math.max(1, maxHeat), 0, 1)

	local cueId = turretModel:GetAttribute("WeaponHeatRecoverCueId")
	if type(cueId) == "number" then
		local cueCounter = math.floor(cueId)
		if cueCounter > lastHeatRecoverCueId then
			lastHeatRecoverCueId = cueCounter
			CombatHUD.onWeaponRecoveredCue()
		end
	end

	return heatRatio, overheated
end

local function updateWeaponAmmoHud(): boolean
	local turretModel = activeTurretModel
	if turretModel == nil then
		return false
	end

	local ammoMaxRaw = turretModel:GetAttribute("WeaponAmmoMax")
	if type(ammoMaxRaw) ~= "number" or ammoMaxRaw <= 0 then
		return false
	end

	local ammoRaw = turretModel:GetAttribute("WeaponAmmo")
	local ammoCurrent = if type(ammoRaw) == "number" then ammoRaw else ammoMaxRaw
	CombatHUD.setAmmo(ammoCurrent, ammoMaxRaw)
	return true
end

local function updateShieldHud()
	local turretModel = activeTurretModel
	if turretModel == nil then
		CombatHUD.showShield(false)
		return
	end

	local maxShieldRaw = turretModel:GetAttribute("MaxShieldHP")
	if type(maxShieldRaw) ~= "number" or maxShieldRaw <= 0 then
		CombatHUD.showShield(false)
		return
	end

	local currentShieldRaw = turretModel:GetAttribute("ShieldHP")
	local currentShield = if type(currentShieldRaw) == "number" then currentShieldRaw else maxShieldRaw
	CombatHUD.showShield(true)
	CombatHUD.setShield(currentShield, maxShieldRaw)
end

local function updateTurretAndCamera(dt: number)
	if activeTurretModel == nil then
		return
	end

	ensureWeaponMount()
	local weaponMount = activeWeaponMount
	if weaponMount == nil then
		return
	end

	local camera = workspace.CurrentCamera
	if camera == nil then
		return
	end

	local mouseDelta = UserInputService:GetMouseDelta()
	cameraYaw += -mouseDelta.X * CAMERA_MOUSE_SENSITIVITY
	cameraPitch = math.clamp(cameraPitch - mouseDelta.Y * CAMERA_MOUSE_SENSITIVITY, MIN_VERTICAL_ANGLE, MAX_VERTICAL_ANGLE)
	local cameraLookDirection = yawPitchToDirection(cameraYaw, cameraPitch)

	if activeNeutralAimFrame == nil then
		activeNeutralAimFrame = WeaponRig.getNeutralAimFrame(weaponMount)
	end

	local aimDirection = clampDirectionPitch(currentAimDirection or WeaponRig.getCurrentAimDirection(weaponMount))
	local targetDirection = aimDirection
	local lockedTargetModel = TargetingClient.getLockedModel()
	local hasLockedAim = false
	local cameraLockTargetDirection: Vector3? = nil
	if lockedTargetModel ~= nil and lockedTargetModel.Parent ~= nil then
		local aimWorldPoint = lockedTargetModel:GetPivot().Position
		local cameraWorldPoint = aimWorldPoint
		if activeTurretModel ~= nil then
			local rawLeadPoint = TargetingClient.getLockedLeadPoint(weaponMount.Position, activeTurretModel)
			if rawLeadPoint ~= nil then
				aimWorldPoint = rawLeadPoint
				cameraWorldPoint = rawLeadPoint
			end

			local visualLeadPoint = TargetingClient.getLockedVisualLeadPoint(weaponMount.Position, activeTurretModel, dt)
			if visualLeadPoint ~= nil then
				cameraWorldPoint = visualLeadPoint
			end
		end

		local toLockedAimPoint = aimWorldPoint - weaponMount.Position
		if toLockedAimPoint.Magnitude > 1e-4 then
			targetDirection = toLockedAimPoint.Unit
			hasLockedAim = true
		end

		local toLockedCameraPoint = cameraWorldPoint - weaponMount.Position
		if toLockedCameraPoint.Magnitude > 1e-4 then
			cameraLockTargetDirection = toLockedCameraPoint.Unit
		end
	end

	if hasLockedAim then
		local cameraFollowDirection = lockedCameraLookDirection
		if cameraFollowDirection == nil then
			cameraFollowDirection = cameraLookDirection
		end

		local desiredCameraDirection = cameraLockTargetDirection or targetDirection
		cameraLookDirection = smoothDirectionToward(
			cameraFollowDirection,
			desiredCameraDirection,
			dt,
			LOCK_CAMERA_DEADZONE_ANGLE,
			LOCK_CAMERA_TURN_GAIN,
			LOCK_CAMERA_MIN_TURN_RATE,
			LOCK_CAMERA_MAX_TURN_RATE
		)
		lockedCameraLookDirection = cameraLookDirection
		cameraYaw, cameraPitch = directionToYawPitch(cameraLookDirection)
	else
		lockedCameraLookDirection = nil
	end

	if not hasLockedAim then
		local cameraToAimError = math.acos(math.clamp(aimDirection:Dot(cameraLookDirection), -1, 1))
		if cameraToAimError > AIM_DEADZONE_ANGLE then
			targetDirection = cameraLookDirection
		end
	end
	if activeNeutralAimFrame ~= nil then
		targetDirection = WeaponRig.clampDirectionToMountLimits(weaponMount, activeNeutralAimFrame, targetDirection)
	end
	desiredAimDirection = targetDirection

	if hasLockedAim then
		-- Locked aim should track prediction directly; smoothing here makes the reticle lag behind moving targets.
		aimDirection = targetDirection
	else
		local dot = math.clamp(aimDirection:Dot(targetDirection), -1, 1)
		local angularError = math.acos(dot)

		if angularError > 1e-4 then
			local alpha: number
			if angularError <= STOP_SMOOTH_ZONE then
				alpha = math.min(1, dt * STOP_SMOOTH_RATE)
			else
				local turnRate = math.clamp(angularError * TURN_RATE_GAIN, MIN_TURN_RATE, MAX_TURN_RATE)
				alpha = math.min(1, (turnRate * dt) / angularError)
			end
			aimDirection = (aimDirection:Lerp(targetDirection, alpha)).Unit
		else
			aimDirection = targetDirection
		end
	end

	currentAimDirection = aimDirection
	sendAimUpdate(aimDirection)

	local mountFrame = WeaponRig.getAimFrame(weaponMount, aimDirection)
	weaponMount.CFrame = mountFrame
	if updateDrivenParts ~= nil then
		updateDrivenParts(aimDirection)
	end

	local baseCameraPosition = getCameraAnchorWorldPosition(activeCameraPoint, activeSeat, weaponMount)
	if baseCameraPosition == nil then
		baseCameraPosition = camera.CFrame.Position
	end

	local finalCameraPosition = baseCameraPosition :: Vector3
	local finalCameraLook = cameraLookDirection

	local kickAcceleration = -cameraKickOffset * SHOT_KICK_SPRING - cameraKickVelocity * SHOT_KICK_DAMPING
	cameraKickVelocity += kickAcceleration * dt
	cameraKickOffset += cameraKickVelocity * dt
	if math.abs(cameraKickOffset) < 1e-4 and math.abs(cameraKickVelocity) < 1e-3 then
		cameraKickOffset = 0
		cameraKickVelocity = 0
	end

	cameraShakeTime += dt
	cameraShakeAmplitude = math.max(0, cameraShakeAmplitude - SHOT_SHAKE_DAMPING * dt)
	local zoomTarget = if zoomHeld then 1 else 0
	local zoomRate = if zoomTarget > zoomBlend then ZOOM_IN_RATE else ZOOM_OUT_RATE
	zoomBlend += (zoomTarget - zoomBlend) * math.min(1, dt * zoomRate)

	local forward = finalCameraLook.Unit
	local right = forward:Cross(Vector3.new(0, 1, 0))
	if right.Magnitude <= 1e-4 then
		right = Vector3.new(1, 0, 0)
	else
		right = right.Unit
	end
	local up = right:Cross(forward).Unit

	local shakePhase = cameraShakeTime * SHOT_SHAKE_FREQUENCY
	local shakeX = math.sin(shakePhase * 1.9) * cameraShakeAmplitude * 0.03
	local shakeY = math.sin(shakePhase * 2.3 + 1.3) * cameraShakeAmplitude * 0.02
	local shakeZ = math.sin(shakePhase * 3.1 + 0.7) * cameraShakeAmplitude * 0.04
	local recoilOffset = -forward * cameraKickOffset + right * shakeX + up * shakeY + forward * shakeZ
	local shakenCameraPosition = finalCameraPosition + recoilOffset

	local fovAcceleration = -cameraFovOffset * SHOT_FOV_SPRING - cameraFovVelocity * SHOT_FOV_DAMPING
	cameraFovVelocity += fovAcceleration * dt
	cameraFovOffset += cameraFovVelocity * dt
	cameraFovOffset = math.clamp(cameraFovOffset, -MAX_FOV_OFFSET, MAX_FOV_OFFSET)
	local zoomFovOffset = -ZOOM_FOV_REDUCTION * zoomBlend
	local desiredFov = turretBaseFov + cameraFovOffset + zoomFovOffset
	camera.FieldOfView = math.max(MIN_TURRET_FOV, desiredFov)
	CombatHUD.setZoomVignette(zoomBlend)

	camera.CFrame = CFrame.lookAt(shakenCameraPosition, shakenCameraPosition + finalCameraLook * CAMERA_LOOK_DISTANCE)

	local center = camera.ViewportSize * 0.5
	CombatHUD.setCursorDotPosition(Vector2.new(center.X, center.Y))
	updateAimReticle(camera, aimDirection)
	local usesAmmoHud = updateWeaponAmmoHud()
	if usesAmmoHud then
		CombatHUD.showAmmo(true)
		CombatHUD.showHeat(false)
		clearHeatVfx()
	else
		CombatHUD.showAmmo(false)
		CombatHUD.showHeat(true)
		local heatRatio, overheated = updateWeaponHeatHud()
		updateWeaponHeatVfx(dt, heatRatio, overheated)
	end
	updateShieldHud()
	if fireHeld and isHoldToFireEnabled() then
		tryFireCurrentWeapon()
	end
end

local function restoreDefaultCameraAndMouse()
	UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	UserInputService.MouseIconEnabled = true

	local camera = workspace.CurrentCamera
	if camera ~= nil then
		camera.FieldOfView = turretBaseFov
		camera.CameraType = Enum.CameraType.Custom
		local character = localPlayer.Character
		if character ~= nil then
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid ~= nil then
				camera.CameraSubject = humanoid
			end
		end
	end
end

local function activateTurretCameraAndMouse()
	local camera = workspace.CurrentCamera
	if camera ~= nil then
		turretBaseFov = camera.FieldOfView
		cameraFovOffset = 0
		cameraFovVelocity = 0
		camera.CameraType = Enum.CameraType.Scriptable
	end

	UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
	UserInputService.MouseIconEnabled = false
end

local function deactivateTurretMode()
	ContextActionService:UnbindAction(FIRE_ACTION_NAME)
	ContextActionService:UnbindAction(EXIT_ACTION_NAME)
	ContextActionService:UnbindAction(ZOOM_ACTION_NAME)
	ContextActionService:UnbindAction(LOCK_ACTION_NAME)

	if turretStepConnection ~= nil then
		turretStepConnection:Disconnect()
		turretStepConnection = nil
	end

	restoreDefaultCameraAndMouse()

	CombatHUD.showCrosshair(false)
	CombatHUD.hideHP()
	CombatHUD.showShield(false)
	CombatHUD.showAmmo(false)
	CombatHUD.showHeat(false)
	CombatHUD.setZoomVignette(0)
	clearHeatVfx()
	TargetingClient.onSeatExit()

	activeTurretModel = nil
	activeSeat = nil
	activeWeaponMount = nil
	activeNeutralAimFrame = nil
	clearDrivenParts()
	activeCameraPoint = nil
	desiredAimDirection = nil
	currentAimDirection = nil
	lockedCameraLookDirection = nil
	cameraYaw = 0
	cameraPitch = 0
	cameraKickOffset = 0
	cameraKickVelocity = 0
	cameraShakeAmplitude = 0
	cameraShakeTime = 0
	cameraFovOffset = 0
	cameraFovVelocity = 0
	zoomHeld = false
	fireHeld = false
	zoomBlend = 0
	nextClientFireTime = 0
	nextAimUpdateTime = 0
	lastHeatRecoverCueId = 0
end

local function onFireAction(_actionName: string, inputState: Enum.UserInputState, _inputObject: InputObject): Enum.ContextActionResult
	if activeTurretModel == nil or fireWeaponRemote == nil then
		return Enum.ContextActionResult.Pass
	end

	local holdToFireEnabled = isHoldToFireEnabled()
	if inputState == Enum.UserInputState.End or inputState == Enum.UserInputState.Cancel then
		fireHeld = false
		return Enum.ContextActionResult.Sink
	end

	if inputState ~= Enum.UserInputState.Begin then
		return Enum.ContextActionResult.Pass
	end

	if holdToFireEnabled then
		fireHeld = true
		tryFireCurrentWeapon()
		return Enum.ContextActionResult.Sink
	end

	tryFireCurrentWeapon()
	return Enum.ContextActionResult.Sink
end

local function onExitAction(_actionName: string, inputState: Enum.UserInputState, _inputObject: InputObject): Enum.ContextActionResult
	if inputState ~= Enum.UserInputState.Begin then
		return Enum.ContextActionResult.Pass
	end

	local character = localPlayer.Character
	if character ~= nil then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid ~= nil then
			humanoid.Sit = false
		end
	end

	return Enum.ContextActionResult.Sink
end

local function onZoomAction(_actionName: string, inputState: Enum.UserInputState, _inputObject: InputObject): Enum.ContextActionResult
	if activeTurretModel == nil then
		return Enum.ContextActionResult.Pass
	end

	if inputState == Enum.UserInputState.Begin then
		zoomHeld = true
	elseif inputState == Enum.UserInputState.End or inputState == Enum.UserInputState.Cancel then
		zoomHeld = false
	end

	return Enum.ContextActionResult.Sink
end

local function onLockToggleAction(
	_actionName: string,
	inputState: Enum.UserInputState,
	_inputObject: InputObject
): Enum.ContextActionResult
	if activeTurretModel == nil then
		return Enum.ContextActionResult.Pass
	end
	if inputState ~= Enum.UserInputState.Begin then
		return Enum.ContextActionResult.Pass
	end

	if TargetingClient.isLocked() then
		TargetingClient.requestClearLock()
	else
		TargetingClient.requestLock()
	end

	return Enum.ContextActionResult.Sink
end

local function activateTurretMode(turretSeat: BasePart)
	local turretModel = turretSeat:FindFirstAncestorWhichIsA("Model")
	if turretModel == nil then
		return
	end

	activeTurretModel = turretModel
	activeSeat = turretSeat
	activeWeaponMount = findTaggedDescendant(turretModel, "WeaponMount", "BasePart") :: BasePart?
	activeCameraPoint = findCameraPoint(turretModel)
	if rebuildDrivenParts ~= nil then
		rebuildDrivenParts()
	end
	initializeAimFromCurrentRig()
	clearHeatVfx()
	activateTurretCameraAndMouse()
	zoomHeld = false
	fireHeld = false
	zoomBlend = 0
	nextClientFireTime = 0
	nextAimUpdateTime = 0
	local cueId = turretModel:GetAttribute("WeaponHeatRecoverCueId")
	lastHeatRecoverCueId = if type(cueId) == "number" then math.floor(cueId) else 0
	CombatHUD.setZoomVignette(0)

	ContextActionService:BindAction(FIRE_ACTION_NAME, onFireAction, false, Enum.UserInputType.MouseButton1)
	ContextActionService:BindAction(EXIT_ACTION_NAME, onExitAction, false, Enum.KeyCode.F)
	ContextActionService:BindAction(ZOOM_ACTION_NAME, onZoomAction, false, Enum.UserInputType.MouseButton2)
	ContextActionService:BindAction(LOCK_ACTION_NAME, onLockToggleAction, false, Enum.KeyCode.T)

	if turretStepConnection == nil then
		turretStepConnection = RunService.RenderStepped:Connect(updateTurretAndCamera)
	end

	CombatHUD.showCrosshair(true)
	local usingAmmoHud = updateWeaponAmmoHud()
	CombatHUD.showAmmo(usingAmmoHud)
	CombatHUD.showHeat(not usingAmmoHud)
	if not usingAmmoHud then
		updateWeaponHeatHud()
	end
	local entityId = turretModel:GetAttribute("EntityId")
	if type(entityId) == "string" then
		CombatHUD.showHP(entityId)
	else
		CombatHUD.hideHP()
	end
	updateShieldHud()
end

local function onHumanoidSeated(isSeated: boolean, seatPart: BasePart?)
	if isSeated and seatPart ~= nil and CollectionService:HasTag(seatPart, "TurretSeat") then
		activateTurretMode(seatPart)
		return
	end

	deactivateTurretMode()
end

local function bindCharacter(character: Model)
	deactivateTurretMode()

	if seatedConnection ~= nil then
		seatedConnection:Disconnect()
		seatedConnection = nil
	end

	local humanoid = character:WaitForChild("Humanoid") :: Humanoid
	seatedConnection = humanoid.Seated:Connect(onHumanoidSeated)

	if humanoid.SeatPart ~= nil and CollectionService:HasTag(humanoid.SeatPart, "TurretSeat") then
		activateTurretMode(humanoid.SeatPart)
	end
end

function WeaponClient.init(remotes: Folder)
	fireWeaponRemote = remotes:WaitForChild("FireWeapon") :: RemoteEvent
	updateTurretAimRemote = remotes:WaitForChild("UpdateTurretAim") :: RemoteEvent
	aimRaycastParams.FilterType = Enum.RaycastFilterType.Exclude
	aimRaycastParams.IgnoreWater = true

	if characterAddedConnection == nil then
		characterAddedConnection = localPlayer.CharacterAdded:Connect(bindCharacter)
	end

	local existingCharacter = localPlayer.Character
	if existingCharacter ~= nil then
		bindCharacter(existingCharacter)
	end
end

return WeaponClient
]]></string>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
</roblox>