# Combat Framework — Project Protocol

**Read this file every pass, alongside the design doc.**

This project has challenges the generic pipeline docs don't cover: combat requires player interaction to test, ships need 3D models, and UI accumulates across passes. This file defines how we handle all of it.

---

## 1. Test Rig Protocol

Combat can't be tested by starting a playtest and watching things happen passively. Someone has to sit in a turret, aim, and fire. Codex can't do that via MCP.

**Solution: every pass includes a test harness script.**

The test harness is a server script that lives in the repo (syncs via Rojo) and runs automatically on playtest start. It exercises the combat system without player input:

- Spawns test entities (turret + target dummy, or ship + enemy ship)
- Simulates combat actions (auto-fires weapons, applies damage, triggers abilities)
- Logs results via AI build prints (`[PN_TEST]` tags)
- Prints `[PN_SUMMARY]` with pass/fail data

**What the test harness does NOT replace:**
- **Flight feel** — only the user can judge if flight controls feel right. User visual check.
- **VFX/audio quality** — only the user can judge if shield impacts look/sound right. User visual check.
- **Aiming feel** — auto-aim accuracy can be logged, but manual aim feel is a user check.

**Each design doc specifies the test harness for that pass.** The harness is pass-specific — it tests what that pass adds. Previous pass harnesses are kept for regression but don't run by default (activated via config flag to avoid noise).

**Test harness location:** `projects/combat-framework/src/ServerScriptService/TestHarness/` — one script per pass, a runner script that activates the current pass's harness.

**Test harness lifecycle:** Temporary. Removed during wrap-up protocol like all AI build prints. They do NOT ship.

---

## 2. Placeholder Model Protocol

Codex generates placeholder geometry from code. No real models needed until the user is ready.

**How placeholders work:**
- Codex creates simple Part-based geometry: a seat, a barrel (cylinder part), attachment points, hitbox parts
- Tagged with CollectionService tags exactly as the authoring system requires
- Config files reference these placeholder models
- The startup validator checks tags and config — works identically on placeholder or real models

**When placeholders are used:**
- Passes 1-4 (turrets): Placeholder turret = seat + barrel part + base part. Placeholder target = anchored part with health module.
- Passes 7-8 (fighters): Placeholder fighter = box with seat, engine attachment, weapon mount attachments. Enough to test flight and combat.
- Passes 11+ (multi-crew ships): Placeholder cruiser/capital = larger box with multiple seats, walkable interior floor, weapon mount points.

**When to swap in real models:**
- Whenever the user has a real model ready, they tag it per the authoring system and drop it in
- The validator confirms it's set up correctly
- The code doesn't care — it reads tags and config, not model geometry
- **The user decides when to swap.** Codex never blocks on real models.

**Placeholder model location:** Generated by the test harness or by a setup script in `projects/combat-framework/src/ServerScriptService/PlaceholderSetup/`. Placed in Workspace at playtest start.

---

## 3. UI Protocol

Each pass adds functional programmer-art UI for whatever it introduces. No dedicated UI polish pass.

**Rules:**
- Use basic Roblox UI elements: ScreenGui, Frame, TextLabel, TextButton, ImageLabel
- Functional first — if the player needs to see shield HP, add a TextLabel that shows shield HP
- Layout doesn't matter yet. Top-left stack of info is fine.
- Each pass's design doc specifies what UI elements to add
- New UI elements are additive — don't redesign previous UI, just add new elements
- Final visual polish (custom assets, animations, layout) is a separate scope outside this roadmap

**UI location:** `projects/combat-framework/src/StarterGui/CombatHUD/` — one ScreenGui, modules add/update elements within it.

---

## 4. Existing System Integration

This project touches two existing game systems that live outside this repo:

- **Weapon/blaster system** (working) — the combat framework's visual style must match this
- **Vehicle system** (working) — pass 5 bolts combat onto this, or rebuilds it (decision at design time)

**Rules for existing system integration:**
- The design doc for the relevant pass specifies exact integration points
- Codex reads the existing system's code (user provides file paths or copies relevant files into the project)
- If the existing system needs modification, the design doc specifies exactly what changes and the user confirms before Codex touches it
- The combat framework must NEVER break existing systems. If a change risks breaking something, flag it.

---

## 5. What the User Preps vs What Codex Generates

| Item | Who | When |
|------|-----|------|
| Placeholder turret/target geometry | Codex (via code) | Pass 1 |
| Placeholder ship geometry | Codex (via code) | Pass 7+ |
| Real ship models (tagged + configured) | User | Whenever ready |
| Test harness scripts | Codex (from design doc) | Every pass |
| Config files | Codex (from design doc) | Every pass |
| UI elements (programmer-art) | Codex (from design doc) | Every pass |
| Rojo project file updates | Codex | As needed |
| VFX/audio assets (final) | User | Outside this roadmap |
| Visual checks in Studio | User | Every pass (after automated tests pass) |
| Rojo + MCP running | User | Every session |

---

## 6. Code Structure — Module Independence

This project will grow large. Both Claude and Codex have context limits. If either AI has to read the entire codebase to work on one pass, the project stalls.

**The solution: strict module boundaries with readable API surfaces.**

### Folder Structure

```
projects/combat-framework/src/
├── Shared/                          # ReplicatedStorage
│   ├── CombatTypes.luau             # All shared type definitions
│   ├── CombatConfig.luau            # All config values (single file, sections per system)
│   └── CombatEnums.luau             # Damage types, ship classes, seat roles, etc.
├── Server/                          # ServerScriptService
│   ├── Projectiles/
│   │   └── ProjectileServer.luau    # Server-side projectile math + hit detection
│   ├── Health/
│   │   ├── HealthManager.luau       # Hull + shield HP, damage application
│   │   └── SubsystemManager.luau    # Subsystem HP, destruction effects
│   ├── Weapons/
│   │   └── WeaponServer.luau        # Fire validation, overheat, ammo tracking
│   ├── Targeting/
│   │   └── TargetingServer.luau     # Lock-on state, auto-aim calculations
│   ├── Ships/
│   │   ├── FlightServer.luau        # Ship movement (CFrame updates)
│   │   ├── CrewManager.luau         # Crew registry, seat management
│   │   ├── DespawnManager.luau      # Ship persistence + despawn timers
│   │   └── PowerRouter.luau         # Pip allocation, stat modifiers
│   ├── Authoring/
│   │   └── StartupValidator.luau    # Tag + config validation at server start
│   └── TestHarness/                 # Temporary, removed at wrap-up
│       ├── Runner.luau
│       └── PassN_Test.luau
├── Client/                          # StarterPlayerScripts
│   ├── Projectiles/
│   │   └── ProjectileVisuals.luau   # Client-side bolt rendering
│   ├── Weapons/
│   │   └── WeaponClient.luau        # Input handling, fire requests
│   ├── Targeting/
│   │   └── TargetingClient.luau     # Lock-on UI, leading indicator
│   ├── Ships/
│   │   ├── FlightClient.luau        # Input → server, camera control
│   │   └── CameraController.luau    # All camera modes + transitions
│   ├── HUD/
│   │   └── CombatHUD.luau           # All HUD elements
│   └── VFX/
│       └── ImpactVFX.luau           # Shield ripple, hull explosion
└── StarterGui/
    └── CombatHUD/                   # ScreenGui container
```

This is the target structure — it grows incrementally. Pass 1 creates only what it needs. Later passes add files. **No pass should need to read more than 3-4 modules.**

### Module API Convention

Every module follows this pattern:
- **Top of file:** Public API functions listed (what other modules can call)
- **Dependencies:** Required modules listed at the top
- **No circular dependencies.** If A needs B and B needs A, extract the shared piece into Shared/

### What Each AI Reads Per Pass

**Claude (designing):**
1. `state.md` + `feature-passes.md` (what pass, what it includes)
2. `CombatTypes.luau` + `CombatConfig.luau` + `CombatEnums.luau` (shared contracts)
3. Only the modules this pass touches or calls into
4. API surface of adjacent modules (top-of-file, not full implementation)

**Codex (building):**
1. `project-protocol.md` + `pass-N-design.md` (what to build)
2. `CombatTypes.luau` + `CombatConfig.luau` + `CombatEnums.luau` (shared contracts)
3. Only the modules being created or modified this pass
4. Full source of modules being modified, API-only for modules being called

**The shared files are the map.** Claude and Codex can always read `CombatTypes.luau` to know every data structure, `CombatConfig.luau` to know every tunable, and `CombatEnums.luau` to know every category — without reading any implementation.

### Rules

- **One responsibility per module.** `HealthManager` does health. It doesn't also handle VFX.
- **Shared types are the contract.** When two modules need to agree on a data shape, it's defined in `CombatTypes.luau`, not duplicated.
- **Config is centralized.** One file, sectioned. Not per-module configs scattered around.
- **New modules need justification.** Don't create a file for 20 lines of code. But don't dump 500 lines into an existing module either.
- **Each design doc lists exactly which files to read and which to create/modify.** Claude specifies this so Codex doesn't guess.

---

## 7. Multiplayer Testing Protocol

MCP runs Play Solo. Combat is multiplayer. Bugs that only appear with real network latency and two players will hide until you test with another person.

**Schedule: multiplayer smoke test every 3-4 passes.**

| After Pass | What to Test With a Second Player |
|------------|-----------------------------------|
| 4 (targeting) | Two players in turrets shooting each other. Lock-on, damage, shields, destruction — under real latency. |
| 8 (fighter combat) | Dogfight. Two fighters shooting each other. Does lock-on work on a real moving player? Do projectile visuals sync? |
| 12 (manned weapons) | Multi-crew ship. One pilots, one mans weapons. Does the gunner's aim stay correct while the pilot turns? |
| 15 (capital flight) | Two capital ships in proximity. Repulsion fields. Multiple crew on each. Does relative motion hold with network lag? |
| 18 (ownership/despawn) | Both players have ships. Board each other's ships. Disconnect and reconnect. Does persistence work? |

**How to test:**
- User invites one friend to a private test server
- Run through the specific scenarios above
- Report bugs with: what happened, what should have happened, which players saw what
- Bugs go through normal escalation (Codex tries to fix → Claude fix plan if stuck)

**What multiplayer testing catches that solo can't:**
- RemoteEvent ordering under latency (events arrive in different order for each client)
- Visual desync (bolt appears to hit on one screen, misses on the other)
- Authority disputes (both players think they hit first)
- Replication lag on fast-changing state (ship position, health, shield state)
- Client-side prediction errors

---

## 8. Memory + Connection Cleanup Discipline

Ships spawn, get destroyed, respawn. Projectiles fire constantly. A single leaked connection or uncleaned table entry will compound over a real play session.

**Rules for every module:**

- **Every `:Connect()` has a matching `:Disconnect()` or cleanup path.** When an entity is destroyed, every connection associated with it must be severed.
- **Use Maids/Janitors or manual cleanup tables.** Each entity (ship, turret, projectile) tracks its own connections. Destruction = iterate and disconnect all.
- **No global tables that grow forever.** If a table tracks active entities, removing an entity must remove its entry. No "mark as inactive" — delete it.
- **RemoteEvent listeners for per-player state clean up on `PlayerRemoving`.** If a player disconnects mid-combat, all their state (locks, crew membership, weapon state) must be released.
- **Test harness includes a leak check.** After a combat sequence (spawn 10 entities, destroy them all), log the count of active connections/table entries. Should be zero.

**The design doc for each pass specifies cleanup paths.** Claude designs them. Codex implements them. This isn't optional — it's part of the module contract.

---

## 9. Camera Complexity

This project requires multiple camera modes with smooth transitions between them:

| Mode | When | Behavior |
|------|------|----------|
| Default 3rd person | Walking around | Standard Roblox camera |
| Turret view | Seated in turret | Camera at weapon viewpoint, follows aim |
| Fighter flight | Piloting fighter | 3rd person, tight follow, mouse-look lag |
| Large ship flight | Piloting transport/cruiser/capital | 3rd person, pulled back to show whole ship |
| Manned weapon view | Seated at weapon station | Camera at weapon viewpoint, independent of ship heading |
| Interior walk | Walking inside moving ship | Relative to ship, standard controls |

**All camera logic lives in one file: `CameraController.luau`.** Not scattered across modules. The camera controller receives mode-switch signals and handles transitions.

**Transitions must be smooth.** Sitting in a turret shouldn't snap-cut to weapon view — it should tween. Walking to a weapon station shouldn't teleport the camera. Each transition gets a short tween (config-driven duration).

**Camera is tested during user visual checks.** The test harness can log mode switches, but only the user can judge if transitions feel right.

---

## 10. Network Budget Awareness

With 100 players, 30+ ships, and hundreds of shots per second, network replication is a hard constraint — not something to solve in the optimization pass if it's already broken.

**Rules:**
- **Never replicate per-frame.** Ship positions update via `Heartbeat` on the server, but replication to clients should use Roblox's built-in streaming or manual throttling — not raw RemoteEvent spam.
- **Projectiles are NOT replicated as objects.** Server calculates path, fires one RemoteEvent with (start, direction, speed, weapon type). Client renders locally. This is already in the idea doc — enforce it.
- **Batch where possible.** One "fire burst" event with shot count, not 4 separate "fire" events for a 4-gun turret.
- **Each design doc flags which RemoteEvents it adds.** Claude tracks the total count and pushes back if a pass adds too many.
- **If a pass introduces noticeable lag in Play Solo with 10+ test entities, stop.** Don't wait for the optimization pass. Fix the replication pattern now.

---

## 11. Handoff Prompt Format

Every handoff prompt for this project includes the protocol file:

```
Read: codex-instructions.md, projects/combat-framework/project-protocol.md, projects/combat-framework/state.md, projects/combat-framework/pass-N-design.md. Then read code in projects/combat-framework/src/. Build pass N.
```

---

## 12. Pass-Specific Test Expectations

Not every pass can be fully tested via MCP. Here's the split:

**Fully automatable (test harness covers it):**
- Damage calculations (fire → check HP change in logs)
- Shield absorption and regen timing
- Damage type multipliers
- Overheat and ammo depletion
- Lock-on acquisition and loss
- Subsystem destruction effects
- Ship health/destruction
- Config validation and startup checks
- Crew registry join/leave
- Despawn timers

**Partially automatable (harness + user visual check):**
- Projectile visuals (harness fires, user watches bolts)
- Shield/hull impact VFX (harness hits targets, user watches effects)
- HUD elements (harness triggers state, user checks display)
- Ship destruction sequence (harness destroys ship, user watches explosions)

**User-only (can't automate, user must fly/aim/walk):**
- Flight model feel (responsiveness, camera, momentum)
- Manual aiming feel
- Relative motion (walking on a moving ship)
- Landing approach and touchdown
- Interior navigation and teleporters
- Power routing feedback feel
- Camera transitions between modes
